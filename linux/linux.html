<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0042) -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Моя первая страничка
    </title>

    <link rel="stylesheet" href="./linux_files/default.css" type="text/css">
  </head>
  <body bgcolor="#FFDEAD">

    <center><h1><b>
          <a name="top"></a>linux</b></h1>
    </center>
      <br>
      <br>


          <!-- Начало справочника -->
      <div style="float: left; width: 100%">
          <!-- Первый столбец-->
        <div style="float: left; width: 25%">&nbsp</div>
          <!-- Второй столбец-->
        <div style="float: left; width: 25%">

<!--Содержание -->

             <!--Первый столбец-->

            <b>A</b>
            <ul type="disc">
              <li>
              <a href="#a">a</a>
              </li>
            </ul>


            <b>B</b>
            <ul type="disc">
              <li>
              <a href="#MC">b</a>
              </li>
            </ul>


            <b>C</b>
            <ul type="disc">
              <li>
              <a href="#cuneiform">cuneiform</a>
              </li>
            </ul>


           <b>D</b>
            <ul type="disc">
              <li>
              <a href="#vim">d</a>
              </li>
            </ul>


            <b>E</b>
            <ul type="disc">
              <li>
              <a href="#vim">e</a>
              </li>
            </ul>


            <b>F</b>
            <ul type="disc">
              <li>
              <a href="#fsck">fsck</a>
              </li>
            </ul>


            <b>G</b>
            <ul type="disc">
              <li>
              <a href="#vim">g</a>
              </li>
            </ul>


            <b>H</b>
            <ul type="disc">
              <li>
              <a href="#vim">h</a>
              </li>
            </ul>


            <b>I</b>
            <ul type="disc">
              <li>
              <a href="#vim">i</a>
              </li>
            </ul>


            <b>J</b>
            <ul type="disc">
              <li>
              <a href="#vim">j</a>
              </li>
            </ul>


            <b>K</b>
            <ul type="disc">
              <li>
              <a href="#vim">k</a>
              </li>
            </ul>


            <b>L</b>
            <ul type="disc">
              <li>
              <a href="#logrotate">logrotate</a>
              </li>
            </ul>


            <b>M</b>
            <ul type="disc">
              <li>
              <a href="#MC">MC</a>
              </li>
            </ul>


            <b>N</b>
            <ul type="disc">
              <li>
              <a href="#vim">n</a>
              </li>
            </ul>


            <b>O</b>
            <ul type="disc">
              <li>
              <a href="#vim">o</a>
              </li>
            </ul>


            <b>P</b>
            <ul type="disc">
              <li>
              <a href="#proxy">proxy</a>
              </li>
            </ul>


            <b>Q</b>
            <ul type="disc">
              <li>
              <a href="#vim">q</a>
              </li>
            </ul>


            <b>R</b>
            <ul type="disc">
              <li>
              <a href="#vim">r</a>
              </li>
            </ul>


            <b>S</b>
            <ul type="disc">
              <li>
              <a href="#vim">s</a>
              </li>
            </ul>


            <b>T</b>
            <ul type="disc">
              <li>
              <a href="#tops">top</a>
              </li>
            </ul>


            <b>U</b>
            <ul type="disc">
              <li>
              <a href="#vim">u</a>
              </li>
            </ul>


            <b>V</b>
            <ul type="disc">
              <li>
              <a href="#vim">vim</a>
              </li>
            </ul>


            <b>W</b>
            <ul type="disc">
              <li>
              <a href="#vim">w</a>
              </li>
            </ul>


            <b>X</b>
            <ul type="disc">
              <li>
              <a href="#vim">x</a>
              </li>
            </ul>


            <b>Y</b>
            <ul type="disc">
              <li>
              <a href="#vim">y</a>
              </li>
            </ul>


            <b>Z</b>
            <ul type="disc">
              <li>
              <a href="#vim">z</a>
              </li>
            </ul>

         </div>
    <!-- Третий столбец-->
  <div style="float: left; width: 25%">

            <!--Второй столбец-->


            <b>А</b>
            <ul type="disc">
              <li>
              <a href="#a">а</a>
              </li>
            </ul>


            <b>Б</b>
            <ul type="disc">
              <li>
              <a href="#MC">б</a>
              </li>
            </ul>


            <b>В</b>
            <ul type="disc">
              <li>
              <a href="#vim">в</a>
              </li>
            </ul>


           <b>Г</b>
            <ul type="disc">
              <li>
              <a href="#vim">г</a>
              </li>
            </ul>


            <b>Д</b>
            <ul type="disc">
              <li>
              <a href="#vim">д</a>
              </li>
            </ul>


            <b>Е</b>
            <ul type="disc">
              <li>
              <a href="#vim">е</a>
              </li>
            </ul>


            <b>Ж</b>
            <ul type="disc">
              <li>
              <a href="#vim">ж</a>
              </li>
            </ul>


            <b>З</b>
            <ul type="disc">
              <li>
              <a href="#vim">з</a>
              </li>
            </ul>


            <b>И</b>
            <ul type="disc">
              <li>
              <a href="#vim">и</a>
              </li>
            </ul>


            <b>Й</b>
            <ul type="disc">
              <li>
              <a href="#vim">й</a>
              </li>
            </ul>


            <b>К</b>
            <ul type="disc">
              <li>
              <a href="#vim">к</a>
              </li>
            </ul>


            <b>Л</b>
            <ul type="disc">
              <li>
              <a href="#vim">л</a>
              </li>
            </ul>


            <b>М</b>
            <ul type="disc">
              <li>
              <a href="#MC">м</a>
              </li>
            </ul>


            <b>Н</b>
            <ul type="disc">
              <li>
              <a href="#vim">н</a>
              </li>
            </ul>


            <b>О</b>
            <ul type="disc">
              <li>
              <a href="#vim">о</a>
              </li>
            </ul>


            <b>П</b>
            <ul type="disc">
              <li>
              <a href="#proxy">п</a>
              </li>
            </ul>


            <b>С</b>
            <ul type="disc">
              <li>
              <a href="#vim">с</a>
              </li>
            </ul>


            <b>Т</b>
            <ul type="disc">
              <li>
              <a href="#vim">е</a>
              </li>
            </ul>


            <b>У</b>
            <ul type="disc">
              <li>
              <a href="#prozess">Упрваление процессами</a>
              </li>
            </ul>


            <b>Ф</b>
            <ul type="disc">
              <li>
              <a href="#vim">ф</a>
              </li>
            </ul>


            <b>Х</b>
            <ul type="disc">
              <li>
              <a href="#vim">х</a>
              </li>
            </ul>


            <b>Ц</b>
            <ul type="disc">
              <li>
              <a href="#vim">ц</a>
              </li>
            </ul>


            <b>Ч</b>
            <ul type="disc">
              <li>
              <a href="#vim">ч</a>
              </li>
            </ul>


            <b>Ш</b>
            <ul type="disc">
              <li>
              <a href="#vim">ш</a>
              </li>
            </ul>


            <b>Щ</b>
            <ul type="disc">
              <li>
              <a href="#vim">щ</a>
              </li>
            </ul>


            <b>Э</b>
            <ul type="disc">
              <li>
              <a href="#vim">э</a>
              </li>
            </ul>

              <b>Ю</b>
            <ul type="disc">
              <li>
              <a href="#vim">ю</a>
              </li>
            </ul>

              <b>Я</b>
            <ul type="disc">
              <li>
              <a href="#vim">я</a>
              </li>
            </ul>

          </div>
    <!-- Четвертый столбец-->
<div style="float: left; width: 25%">&nbsp</div>
</div>
<div style="clear: both"></div>

        <!-- Начало справочника -->





          <br>  <h1>
            <a name="vim"></a>!Vim</h1>
          <a href="#top">Назад</a>
          <br>
          <br>    Для копирования текста в командном режиме ставим курсор и указываем число строк
          <br>
          <br>  прим. :4 и два раза нажимаем (yy) вставка в нужном месте (p)
          <br>
          <br>  vim test.txt и нажимаем i для включения режима набора текста.
          <br>
          <br>  Esc - выход из режима.
          <br>
          <br>  u - отмена (назад в history)
          <br>
          <br>  :u - тоже отмена. U - тоже.
          <br>
          <br>
          <br>  :redo - повторить (вперед в history) оно же Ctrl+r
          <br>
          <br>  :wq - Сохранить и выйти
          <br>
          <br>  :w - просто сохранить данный файл.
          <br>
          <br>  :w ПУТЬ/ИМЯ - сохранить копию как.
          <br>
          <br>  :q! - не сохранять и выйти.
          <br>
          <br>  [[ - вверх файла
          <br>
          <br>  ]] - вниз файла
          <br>
          <br>  Вообще, проще принцип работы в этом редакторе можно описать так:
          <br>
          <br>  Esc i - пишем
          <br>
          <br>  Esc v - выделяем
          <br>
          <br>  Esc : - командуем
          <br>
          <br>  Esc / - ищем
          <br>
          <br>  Для подсказок по командам есть кнопка TAB. Т.е. :TAB
          <br>
          <br>  :12345 - переходим на строку с номером 12345
          <br>
          <br>  :set number - показать номера строк
          <br>
          <br>  :set nonumber - скрыть нумерацию строк
          <br>
          <br>  :help команда
          <br>
          <br>
          <br>
          <br>  Выделение текста:
          <br>
          <br>  v и влево или вправо стрелками.
          <br>
          <br>  или Shift+v вся строка целиком.
          <br>
          <br>  или Ctrl+v прямоугольник. часть текста.
          <br>
          <br>  Копирование и вставка текста:
          <br>
          <br>  y - скопировать выделенный кусок
          <br>
          <br>  Shift+p или просто p - вставить.
          <br>
          <br>  d - удалить (т.е. вырезать)
          <br>
          <br>  dd –удалить строку целиком
          <br>
          <br>  Поиск:
          <br>
          <br>  Перейти на строку:
          <br>
          <br>  /ФРАЗА - поиск фразы во всем документе.
          <br>
          <br>  n - следующее найденное (вниз) N - предыдущее (вверх)
          <br>
          <br>  Окна и перемещение между окнами:
          <br>
          <br>  :vne ИМЯ_ФАЙЛА - поделить вертикально окно и открыть файл ИМЯ_ФАЙЛА во второй половине.
          <br>
          <br>  :new ИМЯ_ФАЙЛА - то же самое, но горизонтально.
          <br>
          <br>  :vs - один и тот же файл на 2 окна вертикально.
          <br>
          <br>  :sp - то же самое, но горизонтально.
          <br>
          <br>  перемещение между окнами vim - Ctrl+w Ctrl+w
          <br>
          <br>  или Ctrl+w и стрелка на какое окно перемещаться.
          <br>  Поиск
 <br>/word	Искать слово “word” сверху вниз
 <br>?word	Искать слово “word” снизу вверх
 <br>/jo[ha]n	Искать “john” или “joan”
 <br>/\&lt; the	Искать слова, начинающееся на “the”
 <br>/the\	Искать слова, заканчивающиеся на “the”
 <br>/\&lt; the\&gt;	Искать “the”
 <br>/\&lt; …. \&gt;	Искать слова из четырех символов
 <br>/fred\|joe	Искать “fred” или “joe”
 <br>/\&lt;\d\d\d\d\&gt;	Искать 4 цифры подряд
 <br>/^\n\{3}	Искать 3 пустые строки
 <br>:bufdo /searchstr/	Искать во всех открытых файлах
 <br>Замена
 <br>:%s/old/new/g	Заменить все вхождения “old” на “new”
 <br>:%s/old/new/gw	Заменить все вхождения “old” на “new” с запросом подтверждения
 <br>:2,35s/old/new/g	Заменить все вхождения “old” на “new” между 2 и 35 строками
 <br>:5,$s/old/new/g	Заменить все вхождения “old” на “new” начиная с 5 строки и до конца файла
 <br>:%s/^/hello/g	Добавить “hello” в начало каждой строки
 <br>:%s/$/Harry/g	Добавить “Harry” в конец каждой строки
 <br>:%s/onward/forward/gi	Заменить “onward” на “forward” с учетом регистра
 <br>:%s/ *$//g	Убрать все пробелы
 <br>:g/string/d	Удалить все строки, содержащие “string”
 <br>:v/string/d	Удалить все строки, не содержащие “string”
 <br>:s/Bill/Steve/	Заменить первое вхождение “Bill” на “Steve” в текущей строке
 <br>:s/Bill/Steve/g	Заменить все вхождения “Bill” на “Steve” в текущей строке
 <br>:%s/\r//g	Убрать символ возврата каретки (Такие тексты обычно приходят от windows-пользователей)
 <br>:%s#&gt;[^&lt;]\+&gt;##g	Очистить текст от HTML-тегов
 <br>:%s/^\(.*\)\n\1$/\1/	Удалить строки, повторяющиеся дважды
 <br>Ctrl+a	Увеличить число под курсором на единицу
 <br>Ctrl+x	Уменьшить число под курсором на единицу
 <br>ggVGg?	Преобразовать текст в Rot13
 <br>Регистр
 <br>Vu	Перевести строку в нижний регистр
 <br>VU	Перевести строку в верхний регистр
 <br>g~~	Инвертировать регистр
 <br>vEU	Перевести слово под курсором в верхний регистр
 <br>vE~	Инвертировать регистр слова
 <br>ggguG	Перевести весь текст в нижний регистр
 <br>:set ignorecase	Регистронезависимый поиск
 <br>:set smartcase	Игнорировать регистр при поиске, если в искомом выражении нет символов верхнего регистра
 <br>:%s/\&lt;./\u&amp;/g	Перевести первую букву каждого слова в верхний регистр
 <br>:%s/\&lt;./\l&amp;/g	Перевести первую букву каждого слова в нижний регистр
 <br>:%s/.*/\u&amp;	Перевести первую букву первого слова в каждой строке в верхний регистр
 <br>:%s/.*/\l&amp;	Перевести первую букву первого слова в каждой строке в нижний регистр
 <br>Чтение/запись файлов
 <br>:1,10 w outfile	Записать в outfile с первой по десятую строки
 <br>:1,10 w &gt;&gt; outfile	Добавить в outfile с первой по десятую строки
 <br>:r infile	Вставить содержимое файла infile
 <br>:23r infile	Вставить содержимое файла infile после 23 строки
 <br>Навигация по ФС
 <br>:e .	Открыть встроенный файл-менеджер
 <br>:Sex	Разбить окно и открыть встроенный файл менеджер
 <br>:browse e	Графический файл-менеджер
 <br>:ls	Список буферов
 <br>:cd ..	Перейти в родительскую директорию
 <br>:args	Список открытых файлов
 <br>:args *.php	Открыть все файлы с расширением *.php
 <br>:grep expression *.php	Показать список файлов с расширением php, содержащих в имени expression
 <br>gf	Открыть файл с именем, равным слову, находящемуся под курсором
 <br>Взаимодействие с ОС
 <br>:!pwd	Выполнить команду pwd и вернуться
 <br>!!pwd	Выполнить команду pwd и вставить результат в редактор
 <br>:sh	Открыть шелл
 <br>$exit	Вернуться в редактор из шелла
 <br>Выравнивание
 <br>:%!fmt	Выровнять все строки
 <br>!}fmt	Выровнять все строки в текущей позиции
 <br>5!!fmt	Выровнять следующие 5 строк
 <br>Вкладки
 <br>:tabnew	Создать новую вкладку
 <br>gt	Перейти на следующую вкладку
 <br>:tabfirst	Перейти на первую вкладку
 <br>:tablast	Перейти на последнюю вкладку
 <br>:tabm n(position)	Изменить порядок вкладок
 <br>:tabdo %s/foo/bar/g	Выполнить команду во всех вкладках
 <br>:tab ball	Поместить все открытые файлы во вкладки
 <br>Разделение окна
 <br>:e filename	Редактировать filename в текущем окне
 <br>:split filename	Разделить окно и открыть filename
 <br>ctrl-w + стрелка ВВЕРХ	Переместить курсор в верхнее окно
 <br>ctrl-w ctrl-w	Переместить курсор в следующее окно
 <br>ctrl-w_	Максимизировать текущее окно
 <br>ctrl-w=	Подогнать окна по размеру
 <br>10 ctrl-w+	Увеличить текущее окно на 10 строк
 <br>:vsplit file	Вертикально разделить окно
 <br>:sview file	Разделить окно и открыть file только для чтения
 <br>:hide	Закрыть текущее окно
 <br>:only	Закрыть все окна, кроме текущего
 <br>:b 2	Открыть #2 в текущем окне
 <br>Автодополнение
 <br>Ctrl+n Ctrl+p (в режиме вставки)	Дополнить слово
 <br>Ctrl+x Ctrl+l	Дополнить строку
 <br>:set dictionary=dict	Установить словарь
 <br>Ctrl+x Ctrl+k	Дополнение из словаря
 <br>Метки
 <br>mk	Пометить текущую позиция как k
 <br>‘k	Перейти к метке k
 <br>d’k	Удалить все до метки k
 <br>Сокращения
 <br>:ab mail mail@provider.org	Определить mail как сокращение от mail@provider.org
 <br>Отступы
 <br>:set autoindent	Включить автоматическую расстановку отступов
 <br>:set smartindent	Включить “умную” расстановку отступов
 <br>:set shiftwidth=4	Установить отступ равный 4 пробелам
 <br>ctrl-t, ctrl-d	Убрать/добавить отступ в режиме вставки
 <br>&lt;&lt;	Добавить отступ
 <br>&gt;&gt;	Убрать отступ
 <br>Подсветка синтаксиса
 <br>:syntax on	Включить подсветку
 <br>:syntax off	Выключить подсветку
 <br>:set syntax=perl	Установить режим подсветки
<br>Запускаем vim и вводим команду: ":e $HOME/.vimrc". Эта команда откроет для редактирования файл с настройками. В <br>графической версии можно просто вызвать команду меню "Edit-&gt;Startup Settings". Теперь нужно перейти в режим <br>редактирования — нажать i — и можно вписывать настройки...
<br>
<br>Мне, например, не нравится, когда vim находится в так называемом режиме совместимости с редактором vi (тоже хорошая <br>штука, но для непосвященных — просто жуть). Поэтому я такой режим обычно отключаю:
<br>
<br>set nocp " Переходим в режим nocompatible
<br>
<br>Текст после символа " — это комментарий, там сможно писать все, что угодно, лишь бы помогло :)
<br>
<br>Еще удобно, когда видно, на какой строке/позиции находится курсор:
<br>
<br>set ruler
<br>
<br>Эта команда включает показ статусной строки внизу экрана редактора, которая показывает координаты курсора в тексте, а <br>также примерное текущее положение в процентах.
<br>
<br>Еще есть полезная опция, хоть я ей обычно и не пользуюсь — нумерация строк:
<br>
<br>set number
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>
            <a name="proxy"></a>!Настройка интернета через proxy в Ubuntu</h1>
          <br>
          <a href="#top">Назад</a>
          <br>
          <br>  С помощью команды wdet www.dp.ua  можно проверить соединение
          <pre class="screen">
           #Vi /etc/profile
           export http_proxy=http://172.16.18.23:8080
           export ftp_proxy=http://172.16.18.23:8080
           </pre>
          <br>  Перегрузить профиль exit exit
          <br>  Проверить переменную $Echo $http_proxy должен быть наш прокси
          <br>  Проверить обновление
          <br>   #Apt-get update
          <br>  При получение ip через dhsp появилась проблема wget не разрешал имена
          <br>  Решение в /etc/wgtrc прописать
          <br>   http_proxy=http://172.16.18.23:8080
          <br>   ftp_proxy=http://172.16.18.23:8080
          <br>  Для работы apt-get через proxy
          <br>   /etc/apt/apt.conf.d/proxy
          <br>   Acquire::http::Proxy "http://proxy:port/";
          <br>   Acquire::ftp::Proxy "ftp://proxy:port/";

          <br>  Способ 2
          <br>  /etc/apt/apt.conf дописать http_proxy="http://172.16.18.23:8080/"
          <br>  /etc/apt/apt.conf.d/proxy создать и дописать http_proxy=" http://172.16.18.23:8080/"
          <br>  И обязательно
          <br>  /etc/environment!!! Дописать
          <br>  https_proxy="https://172.16.18.23:8080//"
          <br>  http_proxy="http://user:pass@proxy:port/"
          <br>  ftp_proxy="ftp://user:pass@proxy:port/"
          <br>  и вуаля!
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Настройка сетевых интерфейсов </h1>
          <br>
          <br>  Справка по интерфейсам
          <br>  $ man interfaces
          <br>  Все команды выполняем под rooyt
          <br>  Конфигурируем интерфейсы
		  <table>
 <tbody><tr bgcolor="#EEE9E9">
 	 <td>
          <br>  /etc/network/interfaces
          <br>  auto lo
          <br>                  iface lo inet loopback
          <br>
          <br>  auto eth0
          <br>                  iface eth0 inet static
          <br>                  address 192.168.0.13
          <br>                  netmask 255.255.255.0
          <br>                  gateway 192.168.0.1
		  </td>

 </tr>
 </tbody></table>
          <br>
          <br>  Перегрузить интерфейсы
          <br>  /etc/init.d/networking restart
          <br>  ВСЕ
          <br>
          <br>  <h1>!Настройка DNS разрешения имен</h1>
          <br>/etc/resolve.conf
          <br>Following is an example of resolv.conf file:
          <br>
          <br>search cyberciti.biz
          <br>nameserver 202.54.1.10
          <br>nameserver 202.54.1.11
          <br>
          <br>
          <br><h1>!Настройка виртуального интефейса</h1>
          <br>  Ifconfig eth0:0 ip net mask   Надо проверить.
          <br>
          <br>
          <br>  <h1>!Проверить на максимальной скорости потери в сети «флюидить»</h1>
          <br>  $ifconfig -f ip узла с которым хотим проверить соединение.
          <br>  cont+c завершение процесса.
          <br>
          <br>
          <br>  <h1>!Пропинговать сеть</h1>
          <br>
          <br>  # ping -s 28000 172.16.18.24 -i 0.2
          <br>
          <br>  #while true; do ping -s 28000 172.16.24.52 -i 0.2 -c 200 -q | tail -2; done
          <br>
          <br>  <h1>!Настройка шлюза по умолчанию </h1>
          <br>
          <br>
          <br>  route add –net 0.0.0.0 gw 172.16.24.252
          <br>  проверить настройки командой
          <br>   netstat –rn
          <br>  Установить шлюз по умолчаниею
          <br>
          <br>  # route add default gw 192.168.1.254 eth0
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Команды Linux: настройка сети.</h1>
          <br>
          <br>  Конфигурация сети
          <br>  ifconfig Показать параметры всех сетевых;
          <br>  ifconfig eth0 Показать параметры сетевого интерфейса eth0;
          <br>  [sudo] ethtool eth0 Показывает состояние сетевого интерфейса eth0 (для некоторых дистрибутивов требуется установка пакета ethtool). Команда ethtool применяется только для проводных подключений, не работает с беспроводными интерфейсами;
          <br>  [sudo] ethtool -s eth0 speed 100 duplex full autoneg off Принудительно задать скорость сетевому интерфейсу 100Mbit и режим Full duplex и отключить автоматическое определение;
          <br>  ifconfig eth0 192.168.50.254 netmask 255.255.255.0 Задать основной IP адрес сетевому интерфейсу eth0;
          <br>  ip addr add 192.168.50.254/24 dev eth0 Задать основной IP адрес сетевому интерфейсу eth0;
          <br>  ifconfig eth0:0 192.168.51.254 netmask 255.255.255.0 Задать дополнительный IP адрес сетевому интерфейсу eth0;
          <br>  ip addr add 192.168.51.254/24 dev eth0 label eth0:1 Задать дополнительный IP адрес сетевому интерфейсу eth0;
          <br>  [sudo] ifconfig eth0 up Запустить сетевой интерфейс eth0;
          <br>  [sudo] ifconfig eth0 down Отключить сетевой интерфейс eth0;
          <br>  ifconfig eth0 hw ether 00:01:02:03:04:05 Смена MAC адреса;
          <br>  [sudo] /etc/init.d/dhcpd restart Перезагрузка DHCP клиента;
          <br>
          <br>
          <br>  ping 192.168.0.2 Проверка сетевого соединения. Пингуется IP адрес 192.168.0.2 (пинговать можно ya.ru);
          <br>
          <br>  <h1>!Пропинговать диапазон сети fping</h1>
          <br>  Устанавливаем
          <br>  #apt-get instll fping
          <br>
          <br>  $fping -a 172.16.18.100 172.16.18.200 -g   #Сканируем диапазон сети
          <br>
          <br>  Или
          <br>
          <br>  $ fping -a 172.16.18.1/24 -g 2&gt; /dev/null
          <br>
	<br><h1>!Просканировать по arp локальную сеть</h1>
	<br>
	<br>$ arp-scan --interface=eth0 --localnet
	<br>
          <br>
          <br>  <h1>Маршрутизация</h1>
          <br>  route -n Выводит на экран таблицу маршрутизации;
          <br>  netstat -rn Выводит на экран таблицу маршрутизации;
          <br>  Управление портами (брандмауэр)
          <br>  netstat -an | grep LISTEN Показывает список всех открытых портов;
          <br>  lsof -i Показывает список всех открытых портов в сеть Internet;
          <br>  [sudo] netstat -tup Активные соединения с интернетом;
          <br>  socklist Показывает все открытые сокеты;
          <br>  [sudo] netstat -anp –udp –tcp | grep LISTEN Список приложений, которые открывают порты;
          <br>  [sudo] iptables -L -n -v Показывает статус firewall (статус iptables);
          <br>  [sudo] iptables -P INPUT ACCEPT Открывает доступ ко всем портам;
          <br>  [sudo] iptables -P FORWARD ACCEPT Открывает доступ ко всем портам;
          <br>  [sudo] iptables -P OUTPUT ACCEPT Открывает доступ ко всем портам;
          <br>  [sudo] iptables -X Удаляет все цепочки;
          <br>  <h1>!Посмотреть сетевые интерфейсы</h1>
          <br>
          <br>  #ifconfig
          <br>  Включить интерфейс командой:
          <br>  #ifconfig eth0 up
          <br>  Перегрузить сетевую службу
          <br>  # /etc/init.d/networking restart
          <br>  в файле находиться мак адресс
          <br>  /etc/udev/rules.d/70-persistent-net.rules contains the MAC address
          <br>  при такой ошибке No such device eth0 error while getting interface flags удалить интерфейс и перегрузиться
          <br>  Маршрут по умолчанию
          <br>     настраивается следующей командой:
          <br>
          <br>             route add default gw 192.168.1.1 eth0
          <br>
          <br>
          <br>  Сеть (LAN )
          <br>
          <br>  ip a s&nbsp; - вывод адресов протокола
          <br>  ip r s - вывод списка маршрутов
          <br>  ip ro add - добавить маршрут
          <br>  ifup eth0 - изменить параметры интерфейса на ВКЛЮЧЕН
          <br>  ifdown eth0 - изменить параметры интерфейса на ВЫКЛЮЧЕН
          <br>  ip ro del default # удалить старый дефаулт, каким бы он не был.
          <br>  ip ro del default&nbsp; via 10.0.0.1 # удалить дефаулт 10.0.0.1
          <br>  ip ro add default via 10.0.1.1 # задать ip-адрес шлюза по умолчанию (default gateway)
          <br>
          <br>  ip ro add&nbsp; 192.168.0.0/16 via 192.168.1.1 - добавить статический маршрут в сеть 192.168.0.0/16 через шлюз с ip-адресом 192.168.1.1
          <br>  ip ro del&nbsp; 192.168.0.0/16 via 192.168.1.1 - удалить этот маршрут
          <br>  ip ro add&nbsp; 192.168.0.0/16 via 192.168.1.1 src 192.168.1.16 -добавить статический маршрут в сеть 192.168.0.0/16 через шлюз с ip-адресом 192.168.1.1 через 192.168.1.16
          <br>  ip ro del 192.168.0.0/16 via 192.168.1.1 src 192.168.1.16 - удалить этот маршрут
          <br>  mii-tool eth0 -отобразить статус и тип соединения для интерфейса eth0
          <br>  ethtool eth0 -отображает статистику интерфеса eth0 с выводом такой информации, как поддерживаемые и текущие режимы соединения
          <br>  netstat -tupn -отображает все установленные сетевые соединения по протоколам TCP и UDP без разрешения имён в ip-адреса и PID'ы и имена процессов, обеспечивающих эти соединения
          <br>  netstat -tupln -отображает все сетевые соединения по протоколам TCP и UDP без разрешения имён в ip-адреса и PID'ы и имена процессов, слушающих порты
          <br>  tcpdump tcp port 80 - отобразить весь трафик на TCP-порт 80 (обычно - HTTP)
          <br>
          <br>  tracepath ya.ru&nbsp; - tracepath - показывает маршрут по сетевым узлам с MTU.&nbsp; Она похожа на traceroute, только не требует привилегий суперпользователя и не имеет расширенных настроек.
          <br>  mtr ya.ru - mtr — свободно доступная программа, выполняющая tracerouting и ping. Но mtr предоставляет и еще некоторые дополнительные возможности, которых нет у traceroute и ping вместе взятых.
          <br>  При запуске mtr начинает исследование сетевого соединения между локальной машиной и указанной пользователем машиной. После того как она определит адрес каждого транзитного узла на пути следования пакетов, она отправляет каждому из этих узлов последовательности запросов ICMP ECHO, пытаясь определить качество канала связи с каждым из них. По окончании исследования выдается статистика по каждому исследованному узлу.
          <br>  &nbsp;
          <br>  &nbsp;<h1>!Управление скоростью беспроводного подключения</h1>
          <br>  iwconfig eth0 rate 2M&nbsp; - заставляет сетевую карту синхронизироваться только на скорости 2Mbps.
          <br>  iwconfig eth0 rate 5.5M auto - Использование директивы auto означает, что можно работать на любой скорости до 5.5Mbps. Сетевые карты могут работать на больших расстояниях при скорости 1Mbps, чем при скорости 11Mbps. Разница между 1Mbps и 11Mbps — 12 децибел для карт Orinocco, т.е., теоретически, можно увеличить максимальную дистанцию работы в 4 раза, уменьшив скорость передачи.
          <br>  iwconfig eth0 rate auto&nbsp; - снять ограничение скорости, просто наберите:
          <br>
          <br>  <h1>!Определение драйвера сетевого интерфейса
            <br> </h1>
          <br>  $ sudo ethtool -i eth0
          <br>
          <br>
          <br>  <h1>! Детальная статистика о сетевой карточи
            <br> </h1>
          <br>  $ sudo ethtool -S eth0
          <br>
          <br>
          <br>  <h1>! Задать скорость работы сетевого интерфейса</h1>
          <br>
          <br>  $ sudo ethtool -s eth0 speed 100 duplex full autoneg off
          <br>
          <br>  <h1>! Для старых сетевых карточек нужно использовать команду </h1>
          <br>
          <br>  $ sudo mii-tool
          <br>
          <br>
          <br>  <h1>! Просмотр статистики на сетевом интерфейсе</h1>
          <br>
          <br>  $ watch netstat -i
          <br>
          <br>
          <br>
          <br>  <h1>! Калькулятор сетевых интерфейсов</h1>
          <br>
          <br>  $ ipcalc 192.168.1.0/27
          <br>
          <br>
          <br>
          <br>  <h1>!Как узнать какие порты открыты</h1>
          <br>
          <br>  # netstat -an -pt
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Просмотр маршрута</h1>
          <br>
          <br>  Просмотреть таблицу маршрутизации в Linux можно множеством способов. Наиболее распространённые это: использовать программы netstat, route или ip.
          <br>
          <br>  %$ netstat -rn
          <br>  Kernel IP routing table
          <br>  Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
          <br>  192.168.80.0    192.168.1.196   255.255.255.0   UG        0 0          0 eth0
          <br>  192.168.1.0     0.0.0.0         255.255.255.0   U         0 0          0 eth0
          <br>  0.0.0.0         192.168.1.198   0.0.0.0         UG        0 0          0 eth0
          <br>
          <br>  %$ /sbin/route -n
          <br>  Kernel IP routing table
          <br>  Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
          <br>  192.168.80.0    192.168.1.196   255.255.255.0   UG    0      0        0 eth0
          <br>  192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0
          <br>  0.0.0.0         192.168.1.198   0.0.0.0         UG    0      0        0 eth0
          <br>
          <br>  %$ ip r
          <br>  192.168.80.0/24 via 192.168.1.196 dev eth0
          <br>  192.168.1.0/24 dev eth0  proto kernel  scope link  src 192.168.1.197
          <br>  default via 192.168.1.198 dev eth0
          <br>
          <br>
          <br>
          <br>  <h1>!Смена маршрута
            <br> </h1>
          <br>  Процесс установки маршрута по умолчанию состоит из двух обязательных шагов:
          <br>
          <br>     1. удаления записи о существующем маршруте(фиктивном)
          <br>     2. добавления записи о новом.
          <br>
          <br>  # route delete default
          <br>  delete net default
          <br>  # route add default 192.168.137.2
          <br>  add net default: gateway 192.168.137.2
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Управление NAT</h1>
          <br>
          <br>  [sudo] iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE «Поднятие» NAT на интерфейсе eth0;
          <br>  [sudo] iptables -t nat -A PREROUTING -p tcp -d 78.31.70.238 –dport 20022 -j DNAT –to 192.168.16.44:22 Перенаправление порта 20022, который использется для ssh;
          <br>  [sudo] iptables -t nat -A PREROUTING -p tcp -d 78.31.70.238 –dport 993:995 -j DNAT –to 192.168.16.254:993-995 Перенаправление диапазона портов 993-995;
          <br>  iptables -L -t nat Проверка статуса NAT;
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Синхронизация по времени с NTP Ubuntu</h1>
          <br>
          <br>   #sudo apt-get install ntp
          <br>  And for ntpd edit /etc/ntp.conf to include additional server lines:
          <br>  server ntp.ubuntu.com
          <br>  server pool.ntp.org
          <br>
          <br>  Для синхронизации в домене делаю так # ntpdate название_AD
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Показать все переменные окружения</h1>
          <br>
          <br>  команды
          <br>  #printenv
          <br>  #env
          <br>  #set
          <br>
          <br>
          <br>
          <br>  <h1>!Информация о файловой системе и жестком диске</h1>
          <br>
          <br>  fdisk -l Информация о всех подключенных жестких и сменных дисках;
          <br>  [sudo] hdparm -I /dev/sda Полная информация о IDE/ATA жестких дисках;
          <br>  smartctl -a /dev/sda1 Выводит SMART-информацию о разделе жесткого диска /dev/sda1 (необходима установка пакета smartmontools);
          <br>  [sudo] blkid Выводит UUID всех доступных накопителей информации в системе;
          <br>  Производительность жесткого диска
          <br>  [sudo] hdparm -tT /dev/sda Показывает производительность жесткого диска;
          <br>  Монтирование разделов жесткого диска
          <br>  mount | column -t Показывает полную информацию о примонтированных устройсвах;
          <br>  cat /proc/partitions Показывает только примонтированные разделы жесткого диска;
          <br>  df Показывает свободное место на разделах;
          <br>  $[sudo] mount /dev/sda1 /mnt Монтирует раздел /dev/sda1 к точке монтирования /mnt;
          <br>  $[sudo] mount -t auto /dev/cdrom /mnt/cdrom Монтирует большинство CD-ROM`ов;
          <br>  $[sudo] mount /dev/hdc -t iso9660 -r /cdrom Монтирует IDE CD-ROM;
          <br>  $[sudo] mount /dev/scd0 -t iso9660 -r /cdrom Монтирует SCSI CD-ROM;
          <br>  $[sudo] mount -t ufs -o ufstype=ufs2,ro /dev/sda3 /mnt Монтирование FreeBSD разделов в Linux;
          <br>  $[sudo] mount -t smbfs -o username=vasja,password=pupkin //pup/Video Монтирование сетевых ресурсов (SMB);
          <br>  $[sudo] mount -t iso9660 -o loop /home/file.iso /home/iso Монтирование ISO-образов;
          <br>  $[sudo] mount /dev/sdb1 -t vfat -o rw /mnt Монтирование раздел с файловой системой FAT 16/32 (к примеру USB-накопитель) к точки монтирования /mnt с возможностью записи;
          <br>  [sudo] umount /mnt Отмонтирует раздел от точки монтирования /mnt;
          <br>
          <br>  <h1>!Автоматическое подключение, монтирование дисков с файловой ситемой ntfs</h1>
          <br>  Смотрим как обозначен наш диск
          <br>  #fdisk -l
          <br>  /dev/sdb5            3828        9729    47407783+   7  HPFS/NTFS
          <br>
          <br>  Определим его UUID
          <br>  # ls -l /dev/disk/by-uuid/
	  <br>итого 0
	  <br>
	  <br>lrwxrwxrwx 1 root root 10 Окт  1 13:14 01CB28E5A5888300 -&gt; ../../sdb5
	  <br>Создаем катаолг /media/data
	  <br>Для автоматического монтировани диска пропишем в /etc/fstab
          <br>UUID=01CB28E5A5888300   /media/extra ntfs  defaults 0 1
	<br>Пояснения:
	<br>/media/extra - папка, куда монтируется диск
	<br>ntfs - тип файловой системы
<br>defaults - параметры по-умолчанию: exec (разрешать запуск исп.файлов), auto (раздел автоматически монтируется при <br>загрузке системы), rw (монтируется для чтения-записи), nouser (запрет пользователям монтировать/демонтировать раздел).
<br>0 - без резервной копии
<br>1 - проверка на ошибки
          <br>
          <br>
          <br>
          <br>  <h1>!Монтирование </h1>
          <br>
          <br>  $ sudo mkdir /mnt/cdrom  создаем директорию куда будем монтировать диск
          <br>  $sudo mount  /dev/cdrom1   /mnt/cdrom  монтируем диск, устpойство находим cd+TAB
          <br>  $sudo umount /mnt/cdrom  размонтируем CD-ROM
          <br>  Устройства, которые в данный момент подключены к компьютеру, можно посмотреть набрав в консоли:
          <br>  # sudo fdisk -l
          <br>  Просмотр примонтированых устройств осуществляется командой:
          <br>  # sudo mount
          <br>  Этого же результата можно достигнуть посмотрев содержимое файла /etc/mtab (в некоторых системах Linux файл называется /etc/mnt/tab)
          <br>  # cat /etc/mtab
          <br>  Монтирование разделов жесткого диска
          <br>  Из приведенного примера видно, что жесткий диск /dev/sdb подключен, но не примонтирован. Примонтируем раздел жесткого диска /dev/sdb1 к диску /dev/sda. Точку монтирования выберем, к примеру - /home/user/Видео. Точку монтирования можно взять любую.
          <br>  # sudo mount /dev/sdb1 /home/user/Видео
          <br>  где user — это название Вашего имени пользователя.
          <br>  Все очень просто, сначала пишется команда mount, потом пишется то, что нужно присоединять (цифра показывает номер раздела, у нас он всего один), а потом куда присоединять. Почти всегда этого достаточно. Диск, командой mount, монтируется в указанную папку. В некоторых случаях, когда имеются логические ошибки на разделах подключаемого жесткого диска, нужно дополнительно указать тип файловой системы. В данном случае у нас ext3.
          <br>  # sudo mount -t ext3 /dev/sdb1 /home/user/Видео
          <br>  Так же этот параметр может принимать значения:
          <br>  -t ntfsили -t ntfs-3g
          <br>  -t vfat
          <br>  -t iso9660
          <br>  Соответственно для NTFS, FAT и CD-дисков файловых систем. Последний нужен только для подключения CD/DVD-ROM устройств и образа диска .iso.
          <br>  Чтобы вручную задать параметры доступа к примонтированному разделу следует указать параметр:
          <br>  -o rw
          <br>  -o ro
          <br>  Первый разрешает чтение и запись, второй только чтение. Ну например, так:
          <br>  # sudo mount -t ext3 -o rw /dev/sdb1 /home/user/Видео
          <br>  Дополнительные параметры, которые помогают в некоторых случаях:
          <br>  # sudo mount -t ext3 -o rw,iocharset=utf8,codepage=866 /dev/sdb1 /home/user/Видео
          <br>
          <br>  Первый явно задает кодировку системной локали, в нашем случае это utf8 (для разных дистрибутивов она своя, но чаще utf8), а другая добавляет поддержку русского языка.
          <br>  Если все же жесткий диск отказывается монтироваться в операционной системе Linux, то можно примонтировать его вручную. Параметр -o force позволяет принудительно монтировать разделы жесткого диска в линуксе. Ну, к примеру, так:
          <br>  # sudo mount -t ext3 -o force /dev/sdb1 /home/user/Видео
          <br>  У меня, к примеру, раздел жесткого диска не хотел монтироваться после подключения к Windows-машине, которая была заражена вирусами. Так получилось, что вирус кинул autorun.exe в корень моего раздела и Linux из-за этого не хотел монтировать этот раздел. Данный выше параметр команды mount помог примонтировать инфицированный раздел. После чего вирус успешно был удален вручную.
          <br>  Есть в Linux уникальная возможность указать зеркало папки, которое получает все права и доступные над папкой действия. Допустим, раздел /dev/sdb1 применяется еще и для хранения документов. Зеркалим его в /home/user/Документы:
          <br>  # sudo mount --bind /home/user/Видео /home/user/Документы
          <br>  Действие команды mount --bind напоминает DOS-овский subst.
          <br>  Посмотреть полную информацию(доступный объем диска, свободное место) о примонтированных устройствах можно командой:
          <br>  # df -h
          <br>  Отмонтироватние устройства производится командой:
          <br>  # sudo umount /dev/sdb1
          <br>  или
          <br>  # sudo umount /home/user/Видео
          <br>  Монтирование дисков CD/DVD-ROM
          <br>  Если Вам нужно примонтировать CD/DVD-ROM, то монтирование CD/DVD-ROM осуществляется точно так же, той же командой mount, которая были приведены выше:
          <br>  # sudo mount -t iso9660 -o ro /dev/cdrom /cd
          <br>  Только при монтировании CD-ROM нужно указать тип файловой системы iso9660.
          <br>  Монтирование образов диска ISO
          <br>  Наверх
          <br>  Если Вы хотите примонтировать образ диска ISO, то это тоже достаточно просто сделать командой mount:
          <br>  # sudo mount -t iso9660 -o loop /home/file.iso /home/iso
          <br>  Где /home/file.iso — путь и имя файла ISO
          <br>  /home/iso — точка монтирования
          <br>  Добавился только параметр -o loop, который указывает, что используется файл .iso.
          <br>  Монтирование сетевых дисков SMB
          <br>  В некоторых случаях необходимо примонтировать удаленный сетевой диск.
          <br>  # sudo mount -t smbfs -o username=vasja,password=pupkin //pupkin_v/Video /home/user/video
          <br>  Где username=vasja,password=pupkin — это имя и пароль доступа к удаленному сетевому ресурсу, а //pupkin_v/Video — имя сетевого ресурса, /home/user/video - точка монтирования
          <br>  Есть альтернатива - графические инструменты монтирования в Linux. Mount Manager
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Подключить диск P NOVEL</h1>
          <br>
          <br>  Пишем такой скрипт
          <br>  #!/bin/sh
          <br>  ncpmount -S FS_01 -A 172.16.16.16 -V 01 -U user.it.dom -y utf8 -p cp866 /mnt/
          <br>
          <br>
          <br>  <h1>!Монтирование дисков fstab</h1>
          <br>
          <br>  В файле
          <br>  #/etc/fstab
          <br>  Прописать
          <br>
          <br>  /dev/sda6       /srv/da6           ntfs            0       0
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>! Вывести информацию о дисках</h1>
          <br>
          <br>  $ sudo tune2fs -l /dev/sda1
          <br>  $ sudo dumpe2fs -h /dev/sda1
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Список устройств в Linux
            <br> </h1>
          <br>  Команды
          <br>  #Lspci
          <br>  #Lshw
          <br>  #Lsusb
          <br>  так же дополнительно пользуюсь таким приемом (требуются права рута)
          <br>  #tail -f /var/log/messages
          <br>  Показывает в "реальном времени" записи в системный лог.
          <br>  и попробовать при это включать и выключать устройство и смотреть что пишется в логии
          <br>  команда dmesg
          <br>
          <br>  #cat /proc/bus/usb/devices
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Подключение USB флешки</h1>
          <br>
          <br>  можно попробовать примонтировать вручную вот так:
          <br>  $sudo mkdir /mnt/flaska
          <br>  $sudo mount /dev/sdb1 /mnt/flaska -t vfat
          <br>  umount /dev/sdb1 размонтировать флешку
          <br>  fdisk -l  Показывает список устройств в том числе и флешку
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Отформатировать USB флешку</h1>
          <br>
          <br>  Командой #dmseg |tail куда при монтировалась флешка например sdc
          <br>  Флешку обязательно не монтируем
          <br>  Отформатировать в fat32 команда
          <br>  #mkfs.vfat -I /dev/sdc
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Узнать размер папок в директории</h1>
          <br>
          <br>  #du -sh * |sort -nr размер папок по убыванию
          <br>  #du -sh *    в алфавитном порядке
          <br>  #du  --max-depth=2 /home |sort -n
          <br>
          <br>  <h1>!Найти все файлы и отсортировать</h1>
          <br>
          <br>  #find Dropbox/ -type f -exec du -k {} \; | sort -rn |more
          <br>
          <br>
          <br>  /home/user/.local/share  корзина
          <br>
          <br>  <h1>!Copздание iso образа с помощью команды cat</h1>
          <br>  # cat /dev/cdrom &gt; /home/user/Рабочий\ стол/ubuntu_server.iso
          <br>
          <br>
          <br>  <h1>!Создание iso диска</h1>
          <br>   mkisofs -V "Label" -o /home/user/image.iso /home/user/Рабочий\ стол/
          <br>
          <br>  Где label метка диска image.iso название и путь к создаваемоемому iso образу после выполнения команды мы получим iso образ в который попадут все файлы с рабочего стола.
          <br>
          <br>
          <br>  <h1>!Создание iso образа диска утилитой dd</h1>
          <br>
          <br>  Сделал так:$dd if=/dev/sr0 of=/home/user/winser2008_64.iso bs=2048
          <br>  Параметр bs зависит от модели DVD-ROM и от степени изношенности DVD
          <br>  Я использовал 2048 чтобы прочиталось без ошибок.
          <br>
          <br>  Монтирование iso образа с удаленной машины.
          <br>  Образ находиться на хосте 172.16.19.10
          <br>  #dd if=/dev/cdrom | ssh 172.16.19.10 'dd of=/root/ubuntu-10.04.1-desktop-i386.iso'
          <br>  Соглашаемся с ключами и вводим пароль.
          <br>  Для того чтобы увидеть образ надо его смонтировать в каталог mnt
          <br>  #mount /dev/cdrom/  /mnt
          <br>
          <br>  $dd if=/dev/hda of=mymbrfile bs=512 count=1 Скопирует MBR загрузочного
          <br>  $dd if=/dev/zero of=/home/user/test/dd-10 count=1 bs=1000 Создаст бинарный файл размер  = 1000kb (count * bs= число байт котрое будет скопировано)
          <br>  $sudo dd if=whatever.iso of=/dev/sdb1
          <br>
          <br>
          <br>
          <br>  <h1>!Монтирование удаленных ресурсов с помощью Gigolo</h1>
          <br>
          <br>  Есть такой проект –&nbsp;Gigolo. Представляет собою оболочку для монтирования различных сетевых ресурсов.
          <br>  sudo apt-get install gigolo
          <br>  Так как файловый менеджер PCMan, установленный в CrunchBang не поддерживает URI вида&nbsp;sftp://user@192.168.0.5/, установим и&nbsp;настроим&nbsp;gvfs-fuse:
          <br>  sudo apt-get install gvfs-fuse
          <br>  Собственно, вся настройка заключается в добавлении пользователя в группуfuse:
          <br>  sudo gpasswd -a username fuse
          <br>  Вот и все,&nbsp;выходим из системы и заходим заново, подключаемся, щелкаем на иконке подключения и работаем с удаленным ресурсом как с обычной директорией.
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Записать CD диск.</h1>
          <br>  # cdrecord –v dev=/dev/cdrom image.iso –speed 8
          <br>
          <br>
          <br>
          <br>  <h1>!Команды Linux: пользователи и группы.</h1>
          <br>
          <br>  Команды Linux необходимые для работы с пользователями и группами пользователей.
          <br>  $id Показывает сводную информацию по текущему пользователю (логин, UID, GID, группы);
          <br>  finger millerd Показать информацию о пользователе millerd;
          <br>  last Показывает последних зарегистрированных пользователей;
          <br>  who Показывает имя текущего пользователя и время входа;
          <br>  useradd millerd Добавление нового пользователя millerd;
          <br>  groupadd interiotech Добавление группы interiotech
          <br>  usermod -a -G interiotech millerd Добавляет пользователя millerd в группу interiotech (для Debian-подобных дистрибутивов);
          <br>  groupmod -A millerd interiotech Добавляет пользователя Mut@NT в группу ITShaman (SuSE);
          <br>  userdel millerd Удаление пользователя Mut@NT;
          <br>  groupdel interiotech Удаление группы ITShaman;
          <br>Пользователи и группы
          <br>
          <br>
          <br>  groupadd group_name
          <br>  создать новую группу с именем group_name
          <br>  groupdel group_name
          <br>  удалить группу group_name
          <br>  groupmod -n new_group_name old_group_name
          <br>  переименовать группу old_group_name в new_group_name
          <br>  useradd -c "Nome Cognome" -g admin -d /home/user1 -s /bin/bash user1
          <br>  создать пользователя user1, назначить ему в качестве домашнего каталога /home/user1, в качестве shell'а /bin/bash, включить его в группу admin и добавить комментарий Nome Cognome
          <br>  useradd user1
          <br>  создать пользователя user1
          <br>  userdel -r user1
          <br>  удалить пользователя user1 и его домашний каталог
          <br>  usermod -c "User FTP" -g system -d /ftp/user1 -s /bin/nologin user1
          <br>  изменить атрибуты пользователя
          <br>  passwd
          <br>  сменить пароль
          <br>  passwd user1
          <br>  сменить пароль пользователя user1 (только root)
          <br>  chage -E 2005-12-31 user1
          <br>  установить дату окончания действия учётной записи пользователя user1
          <br>  pwck
          <br>  проверить корректность системных файлов учётных записей. Проверяются файлы /etc/passwd и /etc/shadow
          <br>  grpck
          <br>  проверяет корректность системных файлов учётных записей. Проверяется файл/etc/group
          <br>  newgrp [-] group_name
          <br>  изменяет первичную группу текущего пользователя. Если указать "-", ситуация будет идентичной той, в которой пользователь вышил из системы и снова вошёл. Если не указывать группу, первичная группа будет назначена из /etc/passwd
          <br> Требование, сменить пароль при первом входе
          <br>  $ sudo chage -d 0 tost
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Команды Linux: работа с процессами.</h1>
          <br>
          <br>  Все запущенные процессы имеют уникальные номера – PID.
          <br>  ps axjf Показать все загруженные процессы;
          <br>  pgrep -l sshd Показать PID определенного процесса – sshd;
          <br>  echo $$ Показать PID вашей оболочки;
          <br>  fuser -va 22/tcp Показать PID процесса использующий порт 22;
          <br>  fuser -va /home Показывает PID процесса имеющего доступ к /home;
          <br>  lsof /home Показывает список процессы, которые используют /home;
          <br>  killall 0 httpd Выводит на экран текущее состояние процесса httpd;
          <br>  kil 4712 «Убить» процесс с PID 4712;
          <br>  [sudo] killall TERM 4712 Посылает процессу с PID`ом 4712 сигнал TERM – завершить процесс;
          <br>  [sudo] killall HUP httpd Посылает процессу с именем httpd сигнал HUP – остановить процесс;
          <br>  [sudo] fuser -k -TERM -m /home “Убить” все процессы имеющие доступ к /hom
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Мониторинг и отладка </h1>
          <br>  <h1> <a name="prozess">Управление процессами</a></h1>
          <br>  <a href="#top">Назад</a>
          <br>
          <br> <h2> <a name="tops">top</a></h2>
          <br>
          <br>  Отобразить запущенные процессы, используемые ими ресурсы и другую полезную информацию (с автоматическим обновлением данных)
          <br>  Когда работает команда top, нажмите клавишу M (в верхнем регистре) для того, чтобы выдать процессы, отсортированные по объему загрузки памяти
          <br>  Для того, чтобы отсортировать данные по любому выходному столбцу, нажмите клавишу O (в верхнем регистре), будут указаны все столбцы, по которым вы можете выполнить сортировку:
          <br>  Нажмите R для того, чтобы выполнить сортировку в обратном (reverse) порядке
          <br>  Как только вы обнаружили процесс, который нужно уничтожить, нажмите клавишу k, будет запрошен идентификатор процесса id и будет послан сигнал на уничтожение процесса.
          <br>  Нажмите клавишу r, если вы хотите изменить приоритет процесса (не уничтожая сам процесс). Будет запрошен PID процесса для переопределения, введите PID и приоритет.
          <br>  Используйте top -u для того, чтобы в выходных данных изображались процессы только конкретного пользователя:
			 <br>  $ top -u geek
          <br>  По умолчанию команда top системы linux обновляет выходные данные каждые 3 секунды. Если вы хотите дать запрос на обновление выходных данных, нажмите клавишу пробела.
			 <br>  Для того, чтобы изменить частоту обновления выходных данных, нажмите в интерективном режиме клавишу d и введите время, указываемое в секунда
          <br>  Если вы хотите выполнить команду top в потоковом режиме, то используйте параметр -b так, как показано ниже:
			 <br>  $ top -b
          <br>  Для того, чтобы разделить выдачу данных на несколько частей, выдаваемых на терминал, нажмите клавишу A. Вы сможете циклически переходить от одной части к другой при помощи нажатия на клавишу a. Это очень полезно, когда вы сортируете выходные данные, выдаваемых в нескольких окнах, по различным столбцам выдачи данных.
          <br>  Нажмите клавишу n в интерактивном режиме — будет задан запрос на указание числа показыаемых процессов.
          <br>  Нажмите клавишу l для того, чтобы спрятать / показать строку со средним значением нагрузки.
          <br>  Нажмите клавишу t для того, чтобы спрятать / показать строку с состоянием процессоров CPU.
          <br>  Нажмите клавишу m для того, чтобы спрятать / показать строки 4 и 5 с информацией о состоянии памяти.
          <br>  Для того, чтобы сохранить конфигурацию команды top, нажмите клавишу W – конфигурация будет записана в конфигурационный файл ~/.toprc.
          <br>  Что бы увидеть загрузку всех процессоров в системе нажмите "1".
          <br>
          <br> <a href="#top">Назад</a>
          <br>
          <br>
          <br>
          <br>  ps -eafw
          <br>  отобразить запущенные процессы, используемые ими ресурсы и другую полезную информацию (единожды)
          <br>  ps -e -o pid,args --forest
          <br>  вывести PID'ы и процессы в виде дерева
          <br>  pstree
          <br>  отобразить дерево процессов
          <br>  kill -9 98989
          <br>  "убить" процесс с PID 98989 "на смерть" (без соблюдения целостности данных)
          <br>  kill -KILL 98989
          <br>  kill -TERM 98989
          <br>  Корректно завершить процесс с PID 98989
          <br>  kill -1 98989
          <br>  заставить процесс с PID 98989 перепрочитать файл конфигурации
          <br>  kill -HUP 98989
          <br>  lsof -p 98989
          <br>  отобразить список файлов, открытых процессом с PID 98989
          <br>  lsof /home/user1
          <br>  отобразить список открытых файлов из директории /home/user1
          <br>  strace -c ls &gt;/dev/null
          <br>  вывести список системных вызовов, созданных и полученных процессом ls
          <br>  strace -f -e open ls &gt;/dev/null
          <br>  вывести вызовы бибилотек
          <br>  watch -n1 'cat /proc/interrupts'
          <br>  отображать прерывания в режиме реального времени
          <br>  last reboot
          <br>  отобразить историю перезагрузок системы
          <br>  last user1
          <br>  отобразить историю регистрации пользователя user1 в системе и время его нахождения в ней
          <br>  lsmod
          <br>  вывести загруженные модули ядра
          <br>  free -m
          <br>  показать состояние оперативной памяти в мегабайтах
          <br>  smartctl -A /dev/hda
          <br>  контроль состояния жёсткого диска /dev/hda через SMART
          <br>  smartctl -i /dev/hda
          <br>  проверить доступность SMART на жёстком диске /dev/hda
          <br>  tail /var/log/dmesg
          <br>  вывести десять последних записей из журнала загрузки ядра
          <br>  tail /var/log/messages
          <br>  вывести десять последних записей из системного журнала
          <br>  Права на файлы в Linux
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Поиск файлов в linux</h1>
          <br>
          <br>  команда
          <br>  $find / -iname name_file  Ищет файл name_file в директории в котором не учитывается регистр символов
          <br>  $find / -name name_file  Ищет файл name_file в директории /
          <br>  $find / -name name_file 2&gt; /dev/null Ищет файл и при появлении ошибок их не показывает
          <br>  $find / -name '*name_file*'  Ищет все файлы где в имении файла есть наше название.
          <br>  $find /usr/bin/ -amin -2 -print Ищет все файлы доступ к которым был меньше 2 минут назад
          <br>  $find /home/chris/ -atime +60 Ищет все файлы доступ к которым за последнии 60 дней, -atime 60 ровно 60 дней, -atime -60 позже 60 дней
          <br>  $find /etc -type d Покажет все директории в каталоге /etc
          <br>  $find / -perm 750 2&gt; /dev/null Покажет все файлы с правами доступа 750
          <br>  $find /var -user user 2&gt; /dev/null  Ищет  в каталоге  фалы пользователя user
          <br>  $find /sbin/ -type f ! -perm /o+w -print | xargs ls -l
          <br>  $find / -xdev -size +10M -print | xargs ls -lS &gt; /tmp/bigfiles.txt
          <br>
          <br>  $find /home -type f -mtime +10 -name "*.txt" -exec cp {} old \;
          <br>   Ищет текстовые файлы старше 10 дней и копирует их в директорию old.
          <br>
          <br>  $ find /home/user \( -name "Dropbox" -prune \) -o \( -type f -name "*.txt" \)
          <br>   Ищет все текстовые файлы в домашней директории кроме директории Dropbox. Пробелы должны быть перед \( и сзади. И опция -о.
          <br>
          <br>  $ find . -type l -print
          <br>   Найти символические ссылки
          <br>  find . -name "*.htm" -exec mv '{}' '{}l' \; переименует все файлы .htm в .html.

          <br>
          <br>  <h1>!Find, или поиск в Linux.</h1>
          <br>
          <br>  find [-H] [-L] [-P] [путь...] [выражение]
          <br>  -P - никогда не следовать символьным ссылкам. Эта опция включена по умолчанию;
          <br>  -L - следовать символьным ссылкам. При этом команда find показывает информацию о файле, на который указывает данная ссылка.
          <br>  -H - не следовать символьным ссылкам за исключением когда обрабатываются аргументы командной строки. Информация берется из самой ссылки
          <br>  Путь по умолчанию: текущий каталог; выражение по умолчанию: -print; выражение может состоять из операторов, опций, тестов и действий:
          <br>  - name - поиск файлов, имена которых соответствуют заданному шаблону;
          <br>  - print - поместить запись полных имен найденных файлов в стандартный поток вывода;
          <br>  - perm - поиск файлов по режиму доступа;
          <br>  - user - поиск файлов принадлежащих данному пользователю
          <br>  -nouser - поиск файлов принадлежащих не существующему пользователю, т.е. которого нет в /etc/passwd;
          <br>  -group - аналогично с -user, только для группы;
          <br>  -nougroup - аналогично -nouser, только для несуществующей группы;
          <br>  - mtime -n (+n) - поиск файлов которые модифицировались менее чем -n или более чем +n дней назад;
          <br>  - atime - поиск по дате -последнего чтения;
          <br>  - ctime - -последнего изменения атрибутов файла;
          <br>  - type - поиск указанного типа файлов. Т.е. f - обычный файл, d - каталог и т.д.;
          <br>  - size n - поиск файлов размером n единиц; единицы: c - байт, k - килобайт, b -блок (в зависимости от системы);
          <br>  - mount - поиск в текущей файловой системе;
          <br>  - exec - выполнение команды shell для найденных файлов.
          <br>  Примеры использования команды find:
          <br>  $ find /home -user serhiy
          <br>  Найти все файлы в директории /home и всех поддиректориях принадлежащие пользователю serhiy
          <br>  $ find ~ -name *.c
          <br>  В вашей домашней директории найдет все файлы с расширением .с. Например helloworld.c
          <br>  $ find . -name "[A-Z]*"
          <br>  В текущем каталоге и его подкаталогах найдет файлы начинающиеся с большой буквы. Заметте что выражение для поиска задано в "..."
          <br>  $ find /var/www/ -mtime -10
          <br>  Найти файлы в каталоге /var/www/ и его подкаталогах которые были изменены менее чем 10 дней назад
          <br>  $ find /var/www/ -mtime -30 -name "*.php"
          <br>  Найти все .php файлы в каталоге /var/www/ и его подкаталогах которые были изменены более чем 30 дней назад
          <br>  $ find . -perm 777
          <br>  Найти все файлы в текущем каталоге, которые имеют права доступа 777.
          <br>  Я думаю, поняв эти примеры, Вы сможете легко найти нужные вам файлы в Linux. Следующим шагом будет совместное использование find и xargs.
          <br>  Выше я уже упоминал о опции -exec. С помощью этой опции команда find передает указанному интерпритатору shell все найденный файлы для исполнения, которые обрабатываются один раз. Но могут быть трудности с тем, что длина командной строки может быть ограничена, поэтому если файлов слишком много, система выдаст ошибку. Команда xargs как раз решает эту проблему. Дело в том, что эта команда обрабатывает файлы полученные от find не сразу все, как -exec, а порциями.
          <br>  Рассмотрим некоторые примеры использования find c xargs:
          <br>  $ find . -perm 777 | xargs rm
          <br>  Команда find находит в данном каталоге файлы с атрибутами 777, и команда rm удаляет их.
          <br>  Или скажем вы хотите найти в домашнем каталоге файл name.c и изменить его права доступа на 777:
          <br>  $ find ~ -name name.c | xargs chmod 777
          <br>
          <br>
          <br>  $ echo "splitXsplitXsplit" |xargs -d X -n 2
          <br>   При выполнение команды мы удаляем все X из строки и разбиваем на 2 столбца.
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Поиск текста в файлах grep</h1>
          <br>
          <br>  $ grep test myfile.txt &nbsp; &nbsp;	Поиск слова test в файле.
          <br>  $ grep -R test /home/user  &amp;emsp	Поиск слова test в директории /home/user
          <br>  $ grep [a-z] myfile.txt &amp;thinsp	Поиск любых символов от a-z в файле.
          <br>  $ grep -v test myfile.txt  &amp;emsp	Обратный поиск выведет все строки без test.
          <br>  $ grep -c test myfile.txt &amp;emsp	Выведет сумму строк где встречается test.
          <br>  $ grep -n test myfile.txt &amp;emsp	Выведет поиск и проставит номера строк.
          <br>  $ grep -i test myfile.txt &amp;emsp	Игнорирует поиск больших или маленьких букв.
          <br>  $ grep -e test1 -e test2 myfile.txt &amp;emsp	Выводит поиск одновременно по 2 и более словам.
          <br>  $ grep -o test myfile.txt &amp;emsp	-o указывает grep, что следует выводить лишь сопадение с шаблоном, а не всю строку
          <br>  $ grep -w test myfile.txt &amp;emsp	-w. Этот ключ ограничит область поиска только указанным словом
	  <br>  $ grep -E "(test1|test2)" myfile.txt &amp;emsp Опция -E позволяет выполнять дополнительное регулярное выражение, в примере будет найден текст test1 или test2 в файле myfile.txt
          <br>
          <br>  <h1>!Просмотр директории и фалов</h1>
          <br>
          <br>  $ls -l  Просмотр  файлов и директорий
          <br>  $ls -la Просмотр скрытых файлов и каталогов
          <br>  $ls -lt Просмотр по времени изменения файлов
          <br>  $ls -lu Просмотреть по времени доступа к файлам
          <br>  $ls -li Выведет список с инодами файлов
          <br>  $ls -lS Сортирует файлы по размеру
          <br>  $ls -lh Выведет список файлов в удобном виде размер фалов
          <br>  $ls -lR Просмотр файлов в текущей директории и поддеректориях
          <br>  $ls -d * Просмотр каталогов в текущей директории.
          <br>
          <br>
          <br>
          <br>  <h1>!Изменение атрибутов файлов</h1>
          <br>
          <br>  $lsattr /etc/host* Просмотр атрибутов файлов.
          <br>  $lsattr -aR /tmp/ | less
          <br>  $ sudo chattr +i whatever.iso
          <br>
          <br>
          <br>
          <br>  <h1>!Для просмотра дополнительных атрибутов существует команда lsattr</h1>
          <br>
          <br>  Если вы выполните команду lsattr /, то увидите дополнительные права для файловых систем ext2/ext3 и увидите сообщение об ошибке для других файловых систем. Изменять дополнительные атрибуты можно командой chattr. Принцип работы схож с командой chmod. Например, chattr +A file.txt добавит атрибут А к файлу file.txt.
          <br>  Установка  атрибута immutable  (т. е.  запрет любых  изменений) может использоваться для предот-
          <br>  вращения случайного удаления или перезаписи защищенного файла. Он также препятствует созданию сим-
          <br>  вольной  ссылки  к  файлу,  которая  может  использоваться  для  атаки,  основанной  на  удалении  файлов
          <br>  /etc/passwd, /etc/shadow, /etc/group или /etc/gshadow.
          <br>  Для установки атрибута immutable для файлов паролей и групп выполните:
          <br>  [root@drwalbr /]# chattr +i /etc/passwd
          <br>  снять  атрибут  immutable  с  файлов  /etc/passwd,  /etc/shadow,
          <br>  /etc/group и /etc/gshadow. Для этого:
          <br>  [root@drwalbr /]# chattr -i /etc/passwd
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Создать директории</h1>
          <br>
          <br>  $mkdir /tmp/new Создаст директорию new в каталоге /tmp.
          <br>  $mkdir -p /tmp/a/b/c/new Создаст директорию new а также директории /a/b/c если их не было.
          <br>  $mkdir -m 700 /tmp/new2 Создаст директорию new2 с правами 700.
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>! Скопировать файлы.</h1>
          <br>
          <br>  $cp -a /tmp/html  /tmp/back Копирует все файлы со всеми правами.
          <br>  $cp -R /tmp/hrml /tmp/back Копирует все файлы но назначает права текущего пользователя.
          <br>
          <br> cp test1 test2 test3 /home/test Скопировать несоколько файлов в директорию test.
          <br>
          <br>
          <br>  <h1>! Создать zip архив</h1>
          <br>
          <br>  $ zip -r vnc1.zip vnc1.exe
          <br>
          <br>
          <br>
          <br>  <h1>! Архивирование с помощью tar.</h1>
          <br>
          <br>  $tar -cvvf output.tar file1 file2 file3 	#Опция -c создает архив -vv подробный вывод -f определяет файл, название нашего архива, в нашем случае «output.tar»
          <br>
          <br>  $ tar czvf myfiles.tar.gz *.txt 	#Создаст архив с названием myfiles. Из файлов *.txt
          <br>  $ tar xzvf myfiles.tar.gz
          <br>  $ tar cjvf myfiles.tar.bz2 *.txt
          <br>  $ tar xjvf myfiles.tar.bz2
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Распаковка архивов *.tar.gz</h1>
          <br>
          <br>  tar xvfz *.tar.gz
          <br>  Используемые в команде ключи x - позволяет вам извлекать файлы из архива. v - делает вывод tar подробным. Это означает, что на экран будут выведены все найденные в архиве файлы. Если эта опция опущена, информация, выводимая в процессе обработки, будет ограничена. f - является обязательной опцией. Без неё tar пытается использовать магнитную ленту вместо файла архива. z - позволяет вам обрабатывать архив, сжатый gzip'ом (с расширением .gz). Если вы забудете указать эту опцию, tar выдаст ошибку. И наоборот, эта опция не должна использоваться для несжатых архивов.
          <br>  Контроль свободного пространства
          <br>  Команда df выводит информацию о монтированных файловых системах. опцию -T, к выводу будет добавлен тип файловой системы. -H для вывода результатов в удобном для пользователя формате
          <br>  $df –T –h
          <br>  Иногда необходимо узнать, сколько места занимает каталог home, или какой размер раздела потребуется, чтобы разместить каталог /usr в отдельной файловой системе. Для решения этих задач используется команда du.
          <br>  Если использовать du для получения информации о нескольких каталогах, можно добавить опцию -s для вывода суммарных данных. Также можно задавать формат вывода. Для этого применяются опции, аналогичные используемым в команде df (-h, -H, --si и т.п.)
          <br>  $du –shc /home
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Распаковка rar-архивов в ubuntu</h1>
          <br>
          <br>  Кодировка не правильная в менеджере архивов
          <br>  решение
          <br>  sudo apt-get remove rar
          <br>  sudo apt-get install unrar ок.
          <br>  Распаковка rar-архивов в ubuntu
          <br>  Однако rar-архивы иногда попадаются, и открывать их как-то надо. Наверное самый простой способ - установить небольшую программку unrar:
          <br>  sudo apt-get install unrar
          <br>  unrar умеет просматривать и распаковывать rar-архивы, и этого вполне достаточно. Запаковать файлы всегда можно в zip, используя тот же Archive Manager.
          <br>  Пользоваться unrar'ом можно из терминала, например так:
          <br>  unrar x /путь/к/архиву.rar /путь/к/папке/назначения
          <br>
          <br>
          <br>
          <br>  <h1>!Распаковка rar-архивов в ubuntu </h1>
          <br>
          <br>  Кодировка не правильная в менеджере архивов
          <br>  решение
          <br>  sudo apt-get remove rar
          <br>  sudo apt-get install unrar ок.
          <br>  Распаковка rar-архивов в ubuntu
          <br>
          <br>  Однако rar-архивы иногда попадаются, и открывать их как-то надо. Наверное самый простой способ - установить небольшую программку unrar:
          <br>  sudo apt-get install unrar
          <br>  unrar умеет просматривать и распаковывать rar-архивы, и этого вполне достаточно. Запаковать файлы всегда можно в zip, используя тот же Archive Manager.
          <br>  Пользоваться unrar'ом можно из терминала, например так:
          <br>  unrar x /путь/к/архиву.rar /путь/к/папке/назначения
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>! Найти отличие в файлах</h1>
          <br>
          <br>  $diff config config.old
 	  <br>  Сравнить каталоги
	  <br>  $diff -ru dir1 dir2
          <br>  Опции -r выполнить рекурсивное сравение -u использовать универсальный формат вывода.
          <br>
          <br>
          <br>  $ sdiff f1.txt f2.txt разбивает на два столбика
          <br>
          <br>  $vimdiff
          <br>   config config.old
          <br>    в редакторе  vim
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Копировать файлы с scp ssh</h1>
          <br>
          <br>  Надо копировать в существующую директорию.
          <br>  $scp vmware-vmrc-linux-x86.xpi user@172.16.18.23:/home/user
          <br>  $scp -r dir user@172.16.18.23:/home/user		Скопировать диркториию в /home/user
          <br>  $scp locl_file user@host:/tmp/remoute_file
          <br>  $scp user@host:/tmp/remote_file local_file
          <br>  $scp user1@host1:file user2@host2:
          <br>  $scp user@172.16.24.38:/etc/samba/smb.conf /home/user/Dropbox/linux/
          <br>   Скопировать с удаленного сервера в домашний каталог конфигурацыонный файл.
          <br>
          <br>
          <br>
          <br>  <h1>!Поключиться к Windows шаре с прбелами </h1>
          <br>
          <br>  $smbclient  -L //172.16.18.39/  Увидить все шары
          <br>  $smbclient //172.16.18.39/Windows\ Server\ 2003\ R2 -U         <br>  вводим пароль и все…
          <br>  Примонтироавть шару в каталог /mnt
          <br>  #mount -t cifs -o username=user,password=123 //172.16.18.23/beckap_Kasperp /mnt русские буквы не видит.
          <br>
          <br>  <h1>!Для настройки загрузки через init.d можно воспользоваться</h1>
          <br>
          <br>  # update-rc.d
          <br>   -f ____ remove отключает запуск службы
          <br>  # update-rc.d ____ defaults
          <br>   включает запуск службы
          <br>  Или можно воспользоваться графической утелитой
          <br>  #bum
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Проверка файлов на целостности</h1>
          <br>
          <br>  $ md5sum whatever.iso
          <br>  d41d8cd98f00b204e9800998ecf8427e whatever.iso
          <br>  $ sha1sum whatever.iso
          <br>  da39a3ee5e6b4b0d3255bfef95601890afd80709 whatever.iso
          <br>  $ md5sum -c md5sum.txt
          <br>
          <br>
          <br>
          <br>  <h1>!Как найти ключи репозиториев в&nbsp;Ubuntu</h1>
          <br>
          <br>  apt-key adv --recv-keys --keyserver keyserver.ubuntu.com `sudo aptitude update 2&gt;&amp;1 | grep -o '[0-9A-Z]\{16\}$' | xargs`
          <br>
          <br>  ОК
          <br>
          <br>
          <br>  <h1>!Настройка клавиатуры</h1>
          <br>
          <br>  # dpkg-reconfigure console-setup
          <br>  Чтобы их избежать необходимо локализовать вашу систему. Сделать это сравнительно просто.
          <br>  Во-первых, список поддерживаемых локалей нужно добавить нужную:
          <br>  $echo ru_RU UTF-8 &gt;&gt; /var/lib/locales/supported.d/local
          <br>  Далее необходимо, чтобы система сгенерировала локаль:
          <br>  $sudo dpkg-reconfigure locales
          <br>  Проверим, добавилась ли нужная локаль командой locale -a — на экране увидите список локалей доступных для использования, в списке должна появится ваша новая ru_RU. Если соответствующая локаль теперь имеется, то достаточно указать системе, что эту локаль теперь необходимо использовать:
          <br>  $echo LANG="ru_RU" &gt;&gt; /etc/environment
          <br>  $echo LANGUAGE="ru_RU:ru" &gt;&gt; /etc/environment
          <br>  Всё готово. После перезагрузки система будет наделена новой кириллической локалью.
          <br>  » 164 просмотра
          <br>  Re: Локализация консоли
          <br>  Комментарий от автора fjey поступил к нам в 18.01.2009 (Вс) 23:50:
          <br>  $ apt-get install console-cyrillic
          <br>  Enter Enter Enter
          <br>  $ cyr
          <br>  У меня не заработала
          <br>  не стану утверждать что этот метод лучше, но пока обхожусь именно им.
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>




          <br>  1. Основы
          <br>  С самого своего появления, UNIX позиционировался как мультипользовательская операционная система. Что соответственно повлекло за собой создание механизмов для защиты и обеспечения авторизорованного доступа к данным. Таким образом появился стандарт DAC (Discretionary Access Control). В соответствии с DAC, пользователь сам решает какие права доступа соответствуют файлам. Но с точки зрения разработки операционных систем эта модель оказалась неудовлетворительной. Из-за чего появились новые модели для организации доступа к файлам, такие как MAC (Mandatory Access Control), ACL (Access Control List), и их реализации, например SELinux, TrustedBSD, Trusted Solaris.
          <br>  2. Владелец файла
          <br>  Обычно, владельцем файла является пользователь, создавший этот файл. В UNIX-подобных операционных системах, все файлы имеют два типа владельцев: user (пользователь) и group (группа). Владельцы не должны совпадать друг с другом, т.е. user не должен быть членом group. Но фактически почти всегда, пользователь принадлежит к той группе, которая владеет файлом. Если пользователь не является владельцем файла и не принадлежит к группе, владеющей файлом, то он считается “левым” (others, остальные). Каждому пользователю в системе присваивается UID-номер (user identification number, идентификатор пользователя), с помощью этого система однозначно определяет пользователя. Пользователь root имеет UID = 0, а максимально возможный номер принадлежит пользователю “nobody” (”никто”) (для Ubuntu это 65534, для NetBSD — 32767). Следовательно права привязываются не в к имени пользователя, а к его UID. Аналогично каждой группе соответствует GID (group identification number). Для того что бы в консоле вывести владельцев файлов используйте команду ls с ключом -l:
          <br>  $ ls -l razem 1822 drwxr-xr-x 3 adam adam 120 2007-09-03 16:00 Desktop -rw-r–r– 1 adam adam 400 2007-08-22 18:49 prog_09.py
          <br>  Третья и четвертая колонка означают, что пользователь и группа владеют файлом.
          <br>  2.1. chgrp
          <br>  Эта команда позволяет изменить группу-владельца файла. Если эту команду использует простой пользователь, то он, во-первых, должен быть владельцем файла, а во-вторых, он должен быть членом группы, которой он хочет дать права. Интересный факт, пользователь не должен быть членом группы, которая владеет файлом. Синтаксис следующий: chgrp new-group files,можно использовать как и имя группы, так и GID группы.
          <br>  $ ls -l -rw-r–r– 1 adam root 0 2007-09-03 15:33 file.txt $ chgrp users file.txt $ ls -l -rw-r–r– 1 adam users 0 2007-09-03 15:33 file.txt
          <br>  Команду кстати можно использовать с ключом -R, что приведет к рекурсивному обходу всех файлов в каталоге и его подкаталогах.
          <br>  2.2. chown
          <br>  Эта команда используется для изменения как владельца так и группы. В большинстве систем, только root имеет право пользоваться этой командой. У команды следующий синтаксис: chown new user:new group files. Как и в команде chgrp, вы можете использовать как имена пользователей и групп, так и их GID и UID. Кстати команда не проверяет на существование пользователей и группы, так что можно задать несуществующие.
          <br>  $ ls -l -rw-r–r– 1 adam users 0 2007-09-03 15:33 file.txt root@laptop:# chown root:root file.txt adam@laptop:~$ ls -l -rw-r–r– 1 root root 0 2007-09-03 15:33 file.txt
          <br>  Смена группы и пользователя.
          <br>  root@laptop:# chown zoidberg file.txt
          <br>  Смена владельца на пользователя zoidberg, группа остается без изменений.
          <br>  # chown :futurama file.txt
          <br>  Смена группы на futurama, владелец без изменений.
          <br>  3. Права доступа
          <br>  В любой UNIX-подобной системе имеются 3 уровня доступа к файлу: чтение, read (r), запись, write (w) и выполнение, execute (x).
          <br>  &nbsp;
          <br>  Тип доступа
          <br>  Для файла
          <br>  Для каталога
          <br>  r
          <br>  Чтение содержимого файла
          <br>  Отображение содержимого каталога (например командой ls)
          <br>  w
          <br>  Запись в файл
          <br>  Изменение содержимого каталога
          <br>  x
          <br>  Запуск файла на исполнение
          <br>  Возможность войти в каталог командой cd
          <br>  &nbsp;
          <br>  Стоит заметить, что когда мы рассматриваем права на каталоги, нужно помнить, что каталог - это тоже файл, который содержит список файлов, т.е. их имена и расположение на диске. Для того что бы посмотреть содержимое каталога достаточно воспользоваться командой ls (без ключей), для этого необходимы только права на чтение, но для того что бы выполнить ls -l необходимы права на запись и выполнение. Обобщая вышесказанное, выполняя любую операцию над каталогом (кроме простого просмотра содержимого) вам необходимы права на выполнение, таким образом обладая этими правами вы получаете доступ к содержимому каталога использую имена файлов.
          <br>  drw-r–r– 2 adam adam 96 2007-09-05 18:04 blob drwxr-xr-x 2 adam adam 176 2007-09-04 15:57 tapety -rw-r–r– 1 adam adam 125 2007-08-29 18:31 fme.py
          <br>  Список прав доступен по команде ls с ключом -l. В первой колонке первый символ обозначает тип файла, а остальные 9 показывают права доступа. Первые 3 из 9 показывают права user, следующие 3 - это права group, и оставшиеся для “левых”.
          <br>  В приведенном примере blob - это каталог, user имеет права на запись и чтение, но не на выполнение (rw-), у группы и у остальных есть права только на чтение. Tapety - тоже каталог, и у user есть права на все (rwx), а у группы и у остальных есть права на чтение и выполнение (r-x). Fme.py - это файл.
          <br>  3.1. chmod
          <br>  Рассмотрим команду для смены прав доступа:
          <br>  chmod access rights files
          <br>  Перед выполнением команды необходимо выбрать класс пользователей, для кого мы хотим изменить права (ugo, User, Group, Others). Есть так же дополнительная группа a (all, все). Затем выбираем оператор: + (дать права), - (убрать права) и = (присвоить права). И в конце выбрать сами права (rwx, r-x и т.д.).
          <br>  $ chmod u+x skrypt.sh
          <br>  Пользователю (u) добавляется (+) право на выполнение (x) файла skrypt.sh.
          <br>  $ chmod go-r raport.odt
          <br>  У группы и остальных (go) отбирается (-) право на чтение (r).
          <br>  $ chmod a=w finanse.ods
          <br>  Всем (a) присваивается (=) право на запись (w), а остальные права стираются (=).
          <br>  $ chmod u+rwx,g+rwx,o+x trurl.py
          <br>  Пользователю прибавляются права на все, группе тоже, а остальным прибавляется право на выполнение.
          <br>  3.2. Числовое представление прав
          <br>  Для упрощения записи команды chmod можно использовать числовое представление прав. У каждого типа доступа есть числовое представление, для этого используется двоичное представление. Единица означает - есть право, 0 - нет права. Таким образом запись правила rwx r-x r-x в бинарном виде будет выглядить следующим образом: 111 101 101. Но двоичное представление не очень удобно, поэтому используют десятичное представлени. 111 в двоичной системе - это 7 в десятичной, а 101 - это 5, таким образом 111 101 101 - это 755. Итак получаем:
          <br>  –x 1 -w- 2 -wx 3 r– 4 r-x 5 rw- 6 rwx 7
          <br>  Таким образом вы можете записать как
          <br>  $ chmod u=rwx,g=rwx,o=x trurl.py
          <br>  так и
          <br>  $ chmod 771 trurl.py
          <br>  3.3. Специальные уровни доступа
          <br>  Рассмотрим несколько специальных уровней доступа, расширяющие стандартные.
          <br>  3.3.1. X
          <br>  Данная опция добавляет выбранным классам права на выполнение тогда и только тогда, когда другие классы тоже имеют права на выполнение:
          <br>  $ ls -l -rwx—— 1 adam users 14 2007-09-10 21:48 skrypt.sh drwx—— 1 adam users 14 2007-09-10 21:48 tapety -rw——- 1 root users 3665 2007-09-17 17:23 wynik.txt $ chmod go+X * $ ls -l -rwxr-xr-x 1 adam users 14 2007-09-10 21:48 skrypt.sh drwxr-xr-x 1 adam users 14 2007-09-10 21:48 tapety -rw-r–r– 1 adam users 3665 2007-09-17 17:23 wynik.txt
          <br>  3.3.2. Липкий бит
          <br>  Если такой типа установить на выполняемый файл, то результаты его работы будут храниться в оперативной памяти даже после завершения программы. Эта возможность редко используется в наши дни, но исторически это сделано было для уменьшения затрат при запуске программ, сегодня существуют более мощные средства кэширования и экономичного распределения памяти между процессами. Если поставить эту опцию на каталог, то всем будет разрешено создавать в ней содержимое, но удалять будет иметь права только владелец и root.
          <br>  drwxrwxrwt 10 root root 464 2007-09-20 12:45 tmp
          <br>  Эта возможность часто используется для каталога /tmp. Судя из названия, этот каталог используется как временный.
          <br>  Назначить липкий бит можно командой chmod:
          <br>  # chmod u+t test/ # ls -l drwxrwxrwt 2 adam users 48 2007-09-20 15:28 test
          <br>  или используя числовую запись
          <br>  # chmod 1000 test/
          <br>  3.3.3. setuid
          <br>  Если установить этот режим на исполняемый файл, то все смогут запускать программу от имени владельца. Например у программы ping владельцем является root (т.к. только root имеет право создавать сокеты, что и делает эта программа), но так как на ней стоит этот режим, то и все остальные могут пользоваться этой программой.
          <br>  $ ls -l /usr/bin/ | grep sudo -rwsr-xr-x 1 root root 91508 2006-10-09 13:37 sudo # chmod u+s program # chmod 4000 program
          <br>  3.3.4. setgid
          <br>  Полностью аналогична setuid, только для групп.
          <br>  # chmod g+s test/ # chmod 2000 test/ # ls -l drwxrwsrwt 2 adam adam 48 2007-09-20 15:28 test
          <br>  3.4. unmask
          <br>  Команда unmask используется для установки прав файлов для новосозданных файлов по умолчанию. Глобально, у всех новых файлов права по умолчанию 666. С помощью этой команды мы передаем те опции которые НЕ будут присутствовать в новых файлах. Т.е. если мы передадим параметр 0022, то по умолчанию права будут 644.
          <br>  $ umask 0022 $ touch file $ ls -l -rw-r–r– 2 adam adam 48 2007-09-20 15:28 file umask 0111 $ ls -l -rw-rw-rw- 1 adam adam 0 2007-09-20 17:31 file2 Оригинал: http://polishlinux.org/console/file-permissions-in-linux/
          <br>  Комментарии:IP 172.16.26.27 зафиксирован на DHCP. Нужно дать доступ к серверу name.global
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Установка java в Firefox</h1>
          <br>
          <br>  Installing Java plugin for Firefox on Ubuntu 10.10 (Maverick)
          <br>  Posted by aibrahim on
          <br>  Again after upgrading from Ubuntu 9.10 to 10.4, I had some issues getting Java to work with Firefox, after checking the software center, I found that the Java plugin for firefox is not working properly which broke my vpn connection.
          <br>  To get this fixed, I simply followed the steps :
          <br>  1- Backup your repositories files.
          <br>  sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup
          <br>  2- Open your repositories file:
          <br>  sudo gedit /etc/apt/sources.list
          <br>  3- Add the following line then close the sources.list file
          <br>  deb http://archive.canonical.com/ubuntu maverick partner
          <br>  4- Uninstall both icedtea6-plugin and openjdk-6-jre.
          <br>  sudo apt-get remove icedtea6-plugin openjdk-6-jre
          <br>  5- Install sun-java6-plugin
          <br>  sudo apt-get update
          <br>  sudo apt-get install sun-java6-plugin
          <br>  sudo update-alternatives --install /usr/lib/mozilla/plugins/mozilla-javaplugin.so mozilla-javaplugin.so /usr/lib/jvm/java-6-sun/jre/lib/i386/libnpjp2.so 1
          <br>  6- Close your firefox and reopen it again, it should be working smoothly.
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Работа с wget</h1>
          <br>
          <br>
          <br>  $ wget www.google.com -O www.txt -o log
          <br>
          <br>  опция -O  сохраняет по указаному имени
          <br>  опция -o сохраняет логи в файл log
          <br>
          <br>
          <br>
          <br>  <h1>!Ограничить скорость</h1>
          <br>  $ wget
          <br>   --limit-rate 20k http://example.com/file.iso
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Установит квоту на загрузку</h1>
          <br>  $ wget -Q 100m http://example.com/file1
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Скопировать весь сайт</h1>
          <br>  $ wget --mirror exampledomain.com
          <br>
          <br>  Or use:
          <br>
          <br>  $ wget -r -N -l DEPTH URL
          <br>
          <br>  -l specifies the DEPTH of web pages as levels. That means it will traverse only that much
          <br>
          <br>  number of levels. It is used along with –r (recursive). The -N argument is used to enable time
          <br>
          <br>  stamping for the file. URL is the base URL for a website for which the download needs to be
          <br>
          <br>  initiated.
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Firefox + wget Ubuntu</h1>
          <br>
          <br>  Как известно, встроенный менеджер закачек Firefox не поддерживает докачку в большинстве описанных случаев либо попытка возобновить скачивание приводит к ошибкам. Но… что, если использовать консольную утилиту wget вместо стандартного менеджера закачек Firefox? wget позволяет докачивать файлы даже после перезагрузки системы, а кроме того, процесс скачивания не прерывается, если вам внезапно пришлось перезапустить X-Server.
          <br>  Можно конечно вручную набирать в консоли «wget — c» и вставлять адрес http или ftp каждый раз, когда вы собираетесь что-либо скачать, но этот процесс можно существенно автоматизировать.
          <br>  1) Для начала создадим файл конфигурации «~/.wgetrc» следующего содержания:
          <br>  user-agent = «Mozilla/5.0»
          <br>  tries = 1000
          <br>  wait = 0
          <br>  continue = on
          <br>  dir_prefix = ~/Downloads/
          <br>  Разберем настройки по косточкам:
          <br>  а) user-agent = «Mozilla/5.0»
          <br>  Тут wget прикидывается браузером Firefox, чтобы у всяких хитрых сервисов не возникло подозрений: «ссылку попросил браузер, а качает качалка, — не порядок!»
          <br>  б) tries = 1000
          <br>  При обрывах соединения будем повторять попытки докачать файл тысячу раз.
          <br>  в) wait = 0
          <br>  Не будем ждать между попытками
          <br>  г) dir_prefix = ~/Downloads/
          <br>  Указываем папку, куда будут сохраняться все файлы, можете изменить параметр на свое усмотрение.
          <br>  2) Теперь необходимо установить расширения Flashgot и перезапустить Firefox.
          <br>  Затем в меню Firefox выбираем: Инструменты -&gt; FlashGot -&gt; Настройки… В появившемся диалоговом окне заполняем поля следующим образом:
          <br>  Менеджер загрузок: Добавить, имя — wget
          <br>  Путь запуска: здесь указываем путь до терминала /usr/bin/gnome-terminal
          <br>  Шаблон аргументов: –hide-menubar -t wget -x wget [URL]
          <br>  Теперь можно использовать wget для закачки файлов из контекстного меню Firefox при щелчке по любой ссылке или из контекстного меню, пунктом «Закачать ссылку при помощи FlashGot». Более того, докачка возможна даже при отсутствии прямых ссылок на скачиваемые файлы.
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Wine и русские буквы</h1>
          <br>
          <br>  Простое решение (http://v-i-y.livejournal.com/133902.html):
          <br>
          <br>  Создаем локаль:
          <br>  sudo localedef -c -i ru_RU -f CP1251 ru_RU.CP1251
          <br>  Теперь запускаем wine-приложение так:
          <br>  * из командной строки:
          <br>  LANG="ru_RU.cp1251" wine my.exe
          <br>  * из desktop launcher:
          <br>  env LANG="ru_RU.cp1251" wine my.exe
          <br>  ок
          <br>
          <br>
          <br>
          <br>  <h1>!UltraVNC </h1>
          <br>
          <br>  работает и без этого.
          <br>  Выполняем действия выше.
          <br>  Создаем ярлык на рабочем столе и добавляем LANG="ru_RU.CP1251" полчаем.
          <br>  env LANG="ru_RU.CP1251" WINEPREFIX="/home/user/.wine" wine C:\\windows\\command\\start.exe /Unix /home/user/.wine/dosdevices/c:/users/Public/???????\ ????/?????????/UltraVNC/UltraVNC\ Viewer/Run\ UltraVNC\ Viewer\ \(Listen\ Mode\).lnk
          <br>
          <br>  Раскладу надо переключать в ручную на удаленной машине и в параметрах клавиатуры обязательно «язык ввода по умолчанию Английский» в противном случае русских букв не будет. Ели стоял русский изменить на  английский и переподключиться.  На linux должна стоять английская раскладка при русской набора нет.
          <br>  Результат: ОК на ubuntu 10.04.
          <br>  Почему я не могу управлять интерфейсом Антивируса Касперского 6.0 с помощью программ RAdmin, WinVNC, UltraVNC и подобных им?
          <br>  Подобный механизм (как в автокликерах) используется в программах удаленного доступа типа RAdmin, WinVNC, UltraVNC. Поэтому при включенной самозащите&nbsp;удаленный доступ&nbsp;к&nbsp;интерфейсу Антивируса, используя указанные программы, невозможен.
          <br>  Для&nbsp;того чтобы иметь возможность удаленного управления интерфейсом Антивируса, отключите самозащиту Антивируса Касперского 6.0:
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Назначение квот</h1>
          <br>
          <br>  Ставим необходимый софт:
          <br>  #apt-get install -y quota quotatool
          <br>  открываем /etc/fstab и прописываем grpquota,usrquota
          <br>  UUID=833075a5-1fe8-47e5-ac8a-2abb07f52348 /       ext4   grpquota,usrquota,errors=remount-ro 0   1
          <br>  Теперь перемонтируем файловые системы (если же Вы активируете квоты для /, то рекомендую перезагрузиться):
          <br>  По умолчанию файлы квот хранятся в корневом каталоге файловой системы в файлах с именами aquota.user и aquota.group соответственно для пользовательских и групповых квот.
          <br>  Этой командой создадим файлы:
          <br>  quotacheck /  Просмотр Всех квот.
          <br>  (Для создания нового пользователя выполняем команду adduser)
          <br>  $sudo edquota -u user_test
          <br>  после этой команды откроется текстовый редактор, в которым указываем ограничения и сохраняем. Вы можете ограничивать размещение ресурсов на основе объема дискового пространства (квотирование блоков), количества файлов (квотирование inode) или их комбинации. Каждое из этих ограничений, в свою очередь, делится на две категории: мягкие (soft) и жёсткие (hard) ограничения. Жёсткое ограничение не может быть превышено. мягкие ограничения могут быть превышены в течении некоторого периода времени. Если пользователь превышает своё мягкое ограничение в течение периода времени, превышающего отсрочку, то это мягкое ограничение становится жестким и последующее выделение ресурсов будет запрещено.
          <br>  Например поставим ограничения: по объему – 1000 Мбайт, по количеству – 1000 файлов. Добавляя 10% запаса на жесткие пределы:
          <br>  Disk quotas for user petrov_ia (uid 1005):
          <br>  Filesystem                   blocks       soft       hard     inodes     soft     hard
          <br>  /dev/loop0                        7    1024000    1126400          4     1000     1100
          <br>  Размер указывается не в КБ, это число блоков. Но у меня в файловой системе один блок - 1024Б, поэтому в данном примере 1 блок = 1 КБ.
          <br>  Параметры blocks и inodes изменять бессмысленно, они ставятся автоматически.
          <br>  Параметр "grace period" позволяет вам установить время, прежде чем значение soft limit будет приведено в жизнь на файловой системе с включенными квотами:
          <br>  sudo edquota -t
          <br>  По умолчанию:
          <br>  Grace period before enforcing soft limits for users:
          <br>  Time units may be: days, hours, minutes, or seconds
          <br>  Filesystem             Block grace period     Inode grace period
          <br>  /dev/loop0                    7days                  7days
          <br>  Проверяем установленные квоты:
          <br>  sudo repquota /
          <br>  Иногда желательно установить ограничения квот на некоторый диапазон UID (идентификаторов пользователей). Это можно сделать при помощи параметра -p в команде edquota. Во-первых, установите желаемое ограничение для пользователя, а затем запустите команду edquota -p protouser startuid-enduid. Например, если пользователь test имеет желаемые ограничения, то для дублирования этих ограничений на пользователей с UID от 10000 до 19999 может быть использована такая команда:
          <br>  sudo edquota -p test 10000-19999
          <br>  Или для списка пользователей:
          <br>  sudo edquota -p test test1 test2 test3 ...
          <br>  Для квотирования групп пользователей (в моем примере это не используется, так, для справки) в /etc/fstab добавляем grpquota, туда же, куда и usrquota, создаем файл:
          <br>  quotacheck
          <br>  Добавляем квоты:
          <br>  sudo edquota -g smbusers
          <br>  И далее аналогично установкам квот на пользователя.
          <br>  http://linux-bash.ru/mseti/48-pdc.html
          <br>
          <br>
          <br>
          <br>  <h1>!APT источники и хранилища</h1>
          <br>
          <br>  Источники в файле /etc/apt/sources.list
          <br>  Все загруженные пакеты хранятся в папке
          <br>  /var/cache/apt/archives/
          <br>  Перечисление Пакетов
          <br>  Перечисление пакетов которые установлены в системе #dpkg –l |less
          <br>  Ручная установка пакетов
          <br>  статус пакетов хранится в /var/lib/dpkg/status
          <br>
          <br>  $sudo dpkg –i mc.deb
          <br>  Поиск в кеше пакетов и информации о них
          <br>  Найти пакет по фразе $apt-cache search “mc”
          <br>  Информация о пакете $apt-cache show mc
          <br>  Установка пакетов
          <br>  Командой $sudo apt-get install mc
          <br>  Удаление пакета
          <br>  $sudo apt-get remove mc   удалит пакет без удаления файлов настройки
          <br>  $sudo apt-get  purge mc   удалит пакет c файлами настройки
          <br>  Обновление системы
          <br>  $sudo apt-get update  список обновления системы
          <br>  $sudo apt-get upgrade запуск обновления
          <br>  Просмотр  списка файлов принадлежащих пакету
          <br>  $dpkg –L cron
          <br>  Поиск, к какому пакету относится файл
          <br>  $dpkg –S /etc/crontab
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Безопасность файловой системы</h1>
          <br>
          <br>  Желательно задать такие настройки
          <br>  /home –nosuid, nodev
          <br>  /tmp –noatime, noexec, nodev, nosuid
          <br>  /var- noexec, nodev, nosuid
          <br>  Ограничение системных ресурсов
          <br>  $ sudoedit /etc/security/limits.conf
          <br>  Файлы журнала системы
          <br>  Журналы обычно живут в каталоге
          <br>  /var/log
          <br>  Многие сжаты .gz
          <br>  /var/log/syslog-общий журнал системы
          <br>  /var/log/auth.log- журналы проверки подлинности в сети
          <br>  /var/log/mail.log- журнал почты
          <br>  /var/log/messages-общий журнал сообщений
          <br>  /var/log/dmesg- сообщения ядра начинаются с загрузки системы
          <br>  $tail –f /var/log/syslog инструмент для работы с журналами
          <br>   А также zgrep zcat zless
          <br>  $zgrep –i eth0 /var/log/*.gz  получем список строк сжатых журналов которые содержат слово eth0 не зависимо от регистра.
          <br>  Установка даты и времени
          <br>  Наберите команду date, чтобы посмотреть текущие дату и время. Если необходимо изменить их, воспользуйтесь следующим форматом команды:
          <br>  date MMDDhhmmCCYY.ss
          <br>  MM — месяц, DD — день месяца, hh — часы, mm — минуты, CCYY — 4 цифры года, ss — секунды
          <br>  Например:
          <br>  date 100615352006.30
          <br>  Эта команда установит текущие дату и время на 06 октября 2006 года, 15:35:30.
          <br>  Обратите внимание: дату и время может изменять только root-пользователь.
          <br>  Рабочий стол не отвечает
          <br>  Alt+Ctr+Backspace закроет и вновь запустить Х сервер
          <br>  Другой способ $sudo /etc/init.d/gdm stop
          <br>  Alt+F2 заходим в терминал и выполняем команду $sudo /etc/init.d/gdm start
          <br>  Как освободить место на диске
          <br>  Все загруженные пакеты хранятся в папке
          <br>  /var/cache/apt/archives/
          <br>  Можно удалить эти пакеты
          <br>  $sudo apt-get clean
          <br>  Найти самые большие файлы в системе можно командой
          <br>  $du –h /home |sort –nr|less
          <br>  $ls -lSa
          <br>  Sort упорядочивает результат
          <br>  Обновить до новой версии систему
          <br>  $sudo  apt-get update
          <br>  $sudo apt-get dist-upgrade
          <br>
          <br>
          <br><h1>!CRON- запуск заданий по времени</h1>
          <br>  $crontab –e открывает редактор для редактирования
          <br>  0-59 * * * *   data&gt; test.txt Каждую минуту записывает дату в файл test.txt
          <br>  * * * * * выполняемая команда
          <br>  | | | | |
          <br>  | | | | ----- День недели (0 - 7) (Воскресенье =0 или =7)
          <br>  | | | ------- Месяц (1 - 12)
          <br>  | | --------- День (1 - 31)
          <br>  | ----------- Час (0 - 23)
          <br>  ------------- Минута (0 - 59)
          <br>   $crontab –l показывает текущее задание
          <br>  $crontab –r удалит задания для пользователя
          <br>
          <p>Названия каталогов и файлов описаны для Linux(RedHat). Для других операционных систем, названия могут отличаться, но принцип работы cron точно такой же.
          </p>
          <p>Cron это программа, выполняющая задания по расписаню. Позволяет неоднократный запуск заданий. Т.е. задание можно запустить в определенное время или через определенный промежуток времени. Формат и значения полей, для пользовательских файлов crontab, будут приведены в конце статьи.
          </p>
          <p>При загрузке системы, запускается демон cron и проверяет очередь заданий at и заданий пользователей в файлах crontab. При запуске, демон cron сначала проверяет каталог /var/spool/cron на наличие файлов crontab, файлы crontab имеют имена пользователей, соответствующие именам пользователей из /etc/passwd Каждый пользователь может иметь только один файл crontab, записей в файле может быть несколько.
          </p>
          <p>Другими словами - файлы crontab содержат инструкции для демона cron, который запустит задание(я) описаное в файле crontab. Все файлы crontab из каталога /var/spool/cron загружаются в память, одновременно с ними загружаются файлы из /etc/cron.d После этого демон cron загружает содержимое файла /etc/crontab При стандартных настройках, содержимое /etc/crontab имеет следующий вид:
          </p>
<pre>SHELL=/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root
HOME=/
# run-parts
01 * * * * root run-parts /etc/cron.hourly
02 4 * * * root run-parts /etc/cron.daily
22 4 * * 0 root run-parts /etc/cron.weekly
42 4 1 * * root run-parts /etc/cron.monthly
</pre>
          <p>Информация файла указывает, что:
          </p>
          <ul>
            <li>содержимое каталога /etc/cron.hourly будет запускаться каждый час на первой минуте часа.
            </li>
            <li>содержимое каталога /etc/cron.daily будет запускаться каждый день на второй минуте четвертого часа.
            </li>
            <li>содержимое каталога /etc/cron.weekly будет запускаться каждое воскресенье на 22'ой минуте 4'го часа.
            </li>
            <li>содержимое каталога /etc/cron.monthly будет запускаться каждый первый день месяца на 42'ой минуте 4'го часа.
            </li>
          </ul>
          <p><b>SHELL</b>=/bin/bash означает использовать для запуска команд /bin/bash , если переменная не указана, то значение будет взято из /etc/passwd для пользователя являющимся владельцем файла.
          </p>
          <p><b>HOME</b>=/ корневой каталог для пользователя (параметр не обязательный) При необходимости доступа к специальным свойствам интерпретатора, значения переменных SHELL и HOME можно изменить, не зависимо от того, что прописано в /etc/passwd
          </p>
          <p><b>MAILTO</b>=root означает кому отсылать сообщение о результате работы команд.
          </p>
          <p>Все содержимое из этих каталогов будет запускаться с правами доступа пользователя root и файлы должны  иметь права доступа на "выполнение" (про права доступа читай статью http://rst.void.ru/texts/chmod.txt) Поэтому перед размещением файлов в одном из этих каталогов необходимо убедиться, что сценарии не насесут вред системе.
          </p>
          <p>После того, как демон cron запущен и прочел содержимое всех файлов crontab, он бездействует, просыпаясь каждую минуту и проверяя не требуется ли запуск какой-либо команды в данную минуту, или не появился ли новый файл crontab который необходимо обработать. Демон cron определяет изменения по времени модификации файлов или каталогов, такое его свойство избавляет от необходимости перезапуска демона.
          </p>
          <p>Как отмечалось выше, размещение файлов для cron в каталогах
          </p>
<pre>/etc/cron.hourly
/etc/cron.daily
/etc/cron.weekly
/etc/cron.monthly
</pre>
          <p>доступно только пользователю root, для использования файлов crontab пользователями, нужно использовать команду crontab. Команда служит для создания, изменения и добавления файла для демона cron
          </p><h2>Пример</h2>
          <p>Рассмотрим пример создания файла crontab для пользователя user ,домашняя директория /home/user
          </p>
          <p>Задача: запускать каждую минуту файл /home/user/mail, который будет отправлять почту
          </p>
<pre>#содержимое файла mail (файл должен быть с правами на запуск! например -rwxr-xr-x)
#!/bin/bash
mess="test cron"
echo "$mess" |mutt -s "subj" -m application/octet-stream bob@server.ru
</pre>
          <p>1.Создаем временный файл /home/user/test содержимое файла test такое:
          </p>
<pre>SHELL=/bin/bash
MAILTO=user
0-59 * * * * /home/user/mail
</pre>
          <p>2. Запускаем в терминале команду     crontab /home/user/test
          </p>
          <p>Все. После этого в каталоге /var/spool/cron будет создан файл "user" примерно с таким содержимым
          </p>
<pre># DO NOT EDIT THIS FILE - edit the master and reinstall.
# (/home/user/test installed on Mon Mar 29 02:31:34 2004)
# (Cron version -- $Id: crontab.c,v 2.13 1994/01/17 03:20:37 vixie Exp $)
SHELL=/bin/bash
MAILTO=user
0-59 * * * * /home/user/mail
</pre>
          <p>и файл /home/user/mail будет запускаться демоном cron каждую минуту.
          </p>
          <p>Доступ в каталог /var/spool/cron непривилегированому пользователю закрыт, что бы посмотреть юзером "user" есть ли у него файл crontab ,достаточно набрать команду crontab -l , если файл существует-будет показано его содержимое.
          </p>
          <p>Для удаления файла используется команда  crontab -r
          </p>
          <p>Для редактирования  crontab -e
          </p>
          <p>Для управления файлами crontab пользователем "root" используется синтаксис:
          </p>
<pre>-------------------------
crontab -u user_name file       -создание файла crontab
-------------------------        из файла "file" для
                                  юзера "user_name"
</pre>
          <p>-u    означает чей crontab будет обработан, Если опция не задана, то будет обработан crontab того        пользователя, который запустил команду crontab.
          </p>
<pre>-------------------------
crontab -u user_name -l       -просмотр файла crontab
-------------------------       юзера "user_name"
-------------------------
crontab -u user_name -r       -удаление файла crontab
-------------------------       юзера "user_name"
-------------------------
crontab -u user_name -e       -редактирование файла crontab
-------------------------      юзера "user_name" используя
                               редактор, заданный переменной
                               окружения VISUAL или EDITOR
</pre>  <h2>Формат и значения полей</h2>
          <p>Каждая команда в пользовательском файле crontab занимает одну строку и состоит из шести полей. Пользовательские файлы crontab находятся в каталоге /var/spool/cron
          </p>
          <p>Общий формат команды:
          </p>
<pre>------------------------------------------------
минута час день_месяца месяц день_недели команда
------------------------------------------------
Допустимые значения:
минута        от 0 до 59
час           от 0 до 23
день_месяца   от 1 до 31
месяц         от 1 до 12 (можно три буквы из названия месяца,
                          регистр не имеет значения от jan до dec)
день_недели   от 0 до 6  (0 это воскресенье,
                          можно писать от sun до sat)
</pre>
          <p>Каждое из полей даты и времени может быть обозначено символом * ,будет соответствовать любому возможному значению. Для этих полей можно указывать диапазоны значений, разделенных дефисом, например:
          </p>
<pre>* 5 4-10 0-3 * echo "HELLO"    -печать HELLO в 5:00 на 4,5,6,7,8,9,10
                                дни января, февраля, марта и апреля
</pre>
          <p>пошаговая запись
          </p>
<pre>* */2 * * sat echo "HELLO"     -печать HELLO каждый четный час,
                                каждую субботу
</pre>
          <p>равнозначная предыдущему примеру запись (списком)
          </p>
<pre>* 0,2,4,6,8,10,12,14,16,18,20,22 * * sat echo "HELLO"
                               -печать HELLO каждый четный
                                час, каждую субботу
</pre>
          <p>то же самое с указанием диапазона
          </p>
<pre>* 0-23/2 * * sat echo "HELLO"  -печать HELLO каждый четный
                                час, каждую субботу
59 23 31 dec * echo "Happy new year" -без комментариев :),
                                      поздравит с новым годом
</pre>
          <p>Для отладки задания cron, можно перенаправить результат в файл
          </p>
          <p>Пример:
          </p>
<pre>0-59 * * * * /home/user/mail 2&gt;/tmp/tmp.cron
</pre>
          <p>Если при запуске команды /home/user/mail возникнут ошибки, то они будут записаны в файл /tmp/tmp.cron и вы всегда сможете узнать причину. В случае перенаправления вывода в файл, письмо, юзеру указаному в переменной MAILTO отправлено не будет.
          </p>
          <p>Посмотреть информацию о всех командах запускаемых демоном cron можно в каталоге /var/log называются cron, cron1 и т.д.
          </p>
          <p>В файле /var/log/cron записано время запуска всех заданий cron за предыдущий день
          </p>
<pre>Mar 29 04:03:00 rst CROND[4434]: (user) CMD (/home/user/mail)
Mar 29 04:03:59 rst CROND[4493]: (user) CMD (/home/user/mail)
Mar 29 04:05:00 rst CROND[4507]: (user) CMD (/home/user/mail)
Mar 29 04:06:00 rst CROND[4549]: (user) CMD (/home/user/mail)
</pre>
          <p>В остальных файлах cron1,cron2 находится подобная информация, но более старая чем в cron
          </p>
          <p>Вот практически и все, что требуется знать для использования cron и crontab.
          </p>
          <br>У меня нету лог файла /var/log/cron.
          <br>Будем создавать
          <br>в Ubuntu по-умолчанию пишет все системные логи, в том числе и кроновские, в единый файл - /etc/rsyslog.conf.
          <br> Когда сервер нагружен проектами и утилитами, выуживать записи скриптов крона из общей кучи очень неудобно.
          <br>
          <br>Тем более, что вынести логи cron в отдельный файл проще простого:
          <br>Редактируем /etc/rsyslog.conf, добавляем строку cron.* -/var/log/cron
          <br>Перезапускаем rsyslog - service rsyslog restart
          <br>Готово! Теперь логи крона будут лежать в /var/log/cron.
          <br><h1> В Debian 6 ntpdate не работает!!!</h1>
          <br>Надо выполнять команду.
          <br># net time set -S имя_сервера_AD
          <br>
          <br>
          <br><h1>!Информация о системе</h1>
          <br>  $df –h показывает разделы жесткого диска
          <br>  $free –m отображает количество памяти в мегабайтах
          <br>
          <br>  $ uname –a информация о системе
          <br>  $lsb_release –a информация о версии UBUNTU
          <br>  $ps отображает запущенные процессы
          <br>  $lspci отображает все шины PCI
          <br>  $lsusb отображает все USB
          <br>  $lshal отображает все HAL
          <br>  $lshw отображает все оборудование вашей системы
          <br>  Забыл системный пароль
          <br>  При загрузке держать Shift появится меню GRAB выбрать режим восстановления (recovery mode ) и выбрать в меню root Drop to root shell….
          <br>   Сбросить пароль
          <br>  #passwd user вводим новый пароль
          <br>
          <br>  Выход из  системы через интервал времени
          <br>  добавить строку TMOUT=3600 в секундах
          <br>  #/etc/profile
          <br>  Выйти и снова зайти exit. Через 1 час произойдет выход из системы.
          <br>
          <br>
          <br>
          <br>  <h1>! Бекап с помощью tar</h1>
          <br>
          <br>  $ ssh francois@server1 ‘tar cf - myfile*’ | tar xvf -
          <br>  Эта команда сжимает все файлы myfk* в архив на удаленной машине server1 в домашнем каталоге пользователя francois и передает в текущий каталог пользователя предварительно разархивировав его.
          <br>  tar cf - myfile* | ssh francois@server1 \
          <br>  ‘cd /home/francois/myfolder; tar xvf -’
          <br>  $ ssh francois@server1 ‘tar czf - myfile*’ | cat &gt; myfiles.tgz
          <br>  $ tar cvzf - myfile* | ssh francois@server1 ‘cat &gt; myfiles.tgz’
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>! Запись дисков CD DVD</h1>
          <br>
          <br>  $ cdrecord --scanbus
          <br>  $cdrecord -v speed= 4 lupu-525.iso  Записать iso образ на скорости 4 надо убедиться что диск не используеться
          <br>  $ cdrecord -multi home.iso
          <br>
          <br>
          <br>
          <br>  <h1>!Мониторинг сетевых интерфейсов</h1>
          <br>
          <br>  #iptraf удобный интервес надо устанавливать
          <br>  #iftop -i eth0 надо дополнительно установливать
          <br>  # vnstat -l -i eth0
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Найти какой файл использует процесс команда</h1>
          <br>
          <br>  #fuser /boot
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>! Мониторинг памяти</h1>
          <br>
          <br>  $ free -ms 2
          <br>  $ vmstat -S M -s
          <br>  $ slabtopche information in a screen-oriented view
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  Examples lsof sockets
          <br>  The interesting option here is the -i option and it should be followed by the Internet address which is specified in the following form:
          <br>  [46][protocol][@hostname|hostaddr][:service|port]
          <br>  4 and 6 stand for ip protocol versions, the rest should be self expanded. So now i think is best time to provide some examples. Here they are:
          <br>  Show all open connections
          <br>  ?
          <br>  lsof -i
          <br>  Show all open TCP connections
          <br>  ?
          <br>  lsof -i TCP
          <br>  Show open TCP connection on on secure ldap port 636, http 80 and UDP protocol range
          <br>  ?
          <br>  lsof -i TCP:636
          <br>  lsof -i TCP:80
          <br>  lsof -i UDP:3000-3025
          <br>  Show LDAP incoming connections
          <br>  ?
          <br>  lsof -i TCP@192.168.0.1:636 ()
          <br>  #java&nbsp; 890 root&nbsp; 18u&nbsp; IPv6 8332031
          <br>  #TCP myserver.com:42936 myserver.com:ldaps (ESTABLISHED)
          <br>  Who use SMTP?
          <br>  ?
          <br>  lsof -i :25
          <br>  #COMMAND&nbsp; PID USER&nbsp;&nbsp; FD&nbsp;&nbsp; TYPE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEVICE SIZE/OFF NODE NAME
          <br>  #sendmail 401 root&nbsp;&nbsp;&nbsp; 5u&nbsp; IPv4 0x300023cc141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0t0&nbsp; TCP *:smtp (LISTEN)
          <br>  #sendmail 401 root&nbsp;&nbsp;&nbsp; 6u&nbsp; IPv6 0x3000243c200&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0t0&nbsp; TCP *:smtp (LISTEN)
          <br>  Further useful Examples of lsof
          <br>  -c option allows to see what files are open by a particular command.
          <br>  ?
          <br>  lsof -c mysq
          <br>  lsof -c ruby
          <br>  See what files are open by a particular device or a file
          <br>  ?
          <br>  lsof /dev/cdrom
          <br>  lsof /tmp/obscure.lock
          <br>  See what files are opened by a user shuron
          <br>  ?
          <br>  lsof –u shuron
          <br>  #vi&nbsp;&nbsp; 5200 shuron txt REG 3,1&nbsp;&nbsp; 242601 245773 /bin/vi
          <br>  Additional info
          <br>  And at last use -r option for monitoring. Here is example of periodically (every 10 seconds) refresh of connection status for a concrete application started as php.
          <br>  ?
          <br>  lsof -r 10 -c php -a -i :1521
          <br>  It gives periodically all 1521 port connections. 1521 is typical Oracle DB connection port, so that example may serve you as base for script that monitors connection growing of your PHP applications.
          <br>  So the last on is interesting also it uses the -t parameter which causes lsof return only a Processor id of a file using application. So following command allows you to kill all application that are using provided file.
          <br>  ?
          <br>  kill -9 `lsof -t /tmp/obscure.lock`
          <br>
          <br>
          <br>
          <br>  <h1>! Информация о жестком диске</h1>
          <br>
          <br>  $ sudo hdparm -I /dev/sda
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>! SSH</h1>
          <br>   настрока сервера /etc/ssh/sshd_config
          <br>  включаем X11 forwarding
          <br>
          <br>  на стороне клиента настраиваем /etc/ssh/ssh_config
          <br>  enable X11 forwarding
          <br>
          <br>  $ ssh –X francois@myserver xclock
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!PDF принтер</h1>
          <br>
          <br>  установка
          <br>  sudo apt-get install cups-pdf
          <br>
          <br>  добавить в принтерах pdf принтер
          <br>
          <br>  сохранят в домашнем каталоге в папке PDF
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>! Аналог UltraISO работа с образами дисков.</h1>
          <br>
          <br>  $sudo apt-get install isomaster
          <br>
          <br>
          <br>
          <br>  Linux Shell 26 мая 2011
          <br>
          <br>
          <br>  <h1>!Вывод на консоль цветного изображения</h1>
          <br>
          <br>  $echo -e "\e[1;31m This is red text \e[0m"
          <br>
          <br>  Цвета reset=0, black=30, red=31,
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Работа с переменными окружения</h1>
          <br>
          <br>  Находим ID  запущенного  процесса командой
          <br>
          <br>  $pgrep firefox-bin
          <br>  2256
          <br>
          <br>  Чтобы получить переменные окружения ассоциированная с данным процессом нужно выполнить команду
          <br>  $cat /proc/2256/environ
          <br>
          <br>
          <br>  <h1>!Добавить новый каталог в переменную окружения</h1>
          <br>  $export PATH=''$PATH:/home/user''
          <br>
          <br>
          <br>  <h1>!Определить какой shell запущен</h1>
          <br>
          <br>  echo $SHELL
          <br>  echo $0
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>! Cделать псевдоним команды</h1>
          <br>
          <br>  $ alias install='sudo apt-get install'
          <br>
          <br>  При закрытие терминала alias пропадает.
          <br>  Чтобы добавить постоянный alias для данного пользователя выполним команду
          <br>
          <br>  $echo 'alias install="sudo apt-get install"' &gt;&gt; ~/.bashrc
          <br>
          <br>
          <br>
          <br>
          <br>  #Настройка принтера cups
          <br>
          <br>  #apt-get install cups
          <br>
          <br>  Заходим на сайт
          <br>  http://localhost:631
          <br>  добавляем принтер
          <br>  выбираем
          <br>  Хост или принтер LPD/LPR
          <br>  socket ://172.16.18.6:9100
          <br>  Выбрать из списка
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!выбрать файлы из списка за последние 4 дня </h1>
          <br>  find /mnt/p1 -mtime -4 &gt;listf.lst
          <br>  делаем копирование файлов
          <br>    fgrep -v .LNG listf.lst | fgrep -v '/PROGRAM/' | while  read arg ; do cp -v -p --parents "$arg" /srv/crash16/; done
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>! REMMINA</h1>
          <br>  Не правильно работала раскладка.
          <br>
          <br>  И вот наткнулся на FreeRDP, который лишён этих недостатков. С версии 0.8 его начал использовать Remmina - графический клиент для удалённых рабочих столов на гтк, весьма удобный и умеющий ssh-тунелли.
          <br>
          <br>  В репозитории Ubuntu 10.04 лежит старая версия Remmina, которая ещё использует rdesktop, но есть PPA со свежей версией. Ставим:
          <br>
          <br>  sudo add-apt-repository ppa:llyzs/ppa
          <br>  sudo apt-get update
          <br>  sudo apt-get install remmina
          <br>
          <br>
          <br>  <h1>!BxLanguage </h1>
          <br>Вбрал для изучения английского языка под ubuntu я запускал версию BX Language acquision    4.3.5.4 младшие версии не работают.
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Проэк закрыли Stardic словарь который переводит  слова пи наведении</h1>
          <br>  установка
          <br>  #apt-get install stardic
          <br>  Добавление словарей с сайта http://xdxf.revdanica.com/down/index.php находим нжний словарь разархивировать в директорию /usr/share/stardict/dic/
          <br>  Вначале я использовал StarDict. Очень хорошая программа, но в дальнейшем перешел на GoldenDict. В нем возможностей больше. Основные свойства: поиск слов на сайте в онлайн переводчиках, поиск дополнительной информации с Википедиа, создание дополнительных языковых групп, добавление словарей от ABBYY Lingvo, StarDict, Dictd, Babylon, проверка орфографии, использование звуковых файлов, всплывающее окно перевода для выделенного слова.
          <br>  Установка на Debian/Ubuntu:
          <br>  sudo apt-get install goldendict
          <br>  Различные словари, в том числе и словари Lingvo, можно скачать с торрента rutracker.org.
          <br>  Добавить словари : Edit -&gt; Dictionary -&gt; Files -&gt; Add.
          <br>  http://forum.ru-board.com/topic.cgi?forum=5&amp;topic=30250&amp;start=540
          <br>  <h1>Увеличить шрифты</h1>
          <br>  В домашнеей директории заходим в скрытую директорию .goldendict
	  <br> Создаем файл с названием
          <br>  article-style.css и с  таким содержанием
          <br>  body
<br>{
<br>font-family: "Lucida Sans Unicode";
<br>font-size: 16px;
<br>}
          <br>  Сохраняем и перезапускаем Goldendict. ВСЕ.
          <br>
          <br>
          <br>  <h1>!Клавиатурный тренажер firfox в дополнениях добавляем</h1>
          <br>  kbTrainer
          <br>   официальный сайт http://code.google.com/p/kbtrainer/
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Добавить верхнюю панель</h1>
          <br>
          <br>  в терминал: gconftool --recursive-unset /apps/panel
          <br>
          <br>
          <br>  потом ALT + F1&nbsp; &nbsp;
          <br>  панель в первозданном виде.
          <br>
          <br>  Обнулить настройки Гнома
          <br>  Убить в домашнем каталоге папку ~.gconf перезагрузить ВСЕ настройки дефолтные
          <br>  появились все значки и раскладка клавиатуры. ОК
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Как открыть файлы с правами пользователя root с помощью правой кнопки мыши?</h1>
          <br>
          <br>  #gedit $HOME/.gnome2/nautilus-scripts/Open\ as\ root
          <br>  Вставьте следующие строки в новый файл
          <br>  for uri in $NAUTILUS_SCRIPT_SELECTED_URIS; do
          <br>   gksudo "gnome-open $uri" &amp;
          <br>  done
          <br>  Сохраните файл
          <br>  #chmod +x $HOME/.gnome2/nautilus-scripts/Open\ as\ root
          <br>  Открыть наутилус и првой кнопкой мыши выбрать сценарий «Open as root»
          <br>  Кликните правой кнопкой мыши на файле -&gt; Scripts -&gt; Open as root
          <br>
          <br>
          <br>  Только вот у меня после рестарта заработало
          <br>
          <br>
          <br>
          <br>  <h1>!Как найти ключи репозиториев в&nbsp;Ubuntu</h1>
          <br>
          <br>  apt-key adv --recv-keys --keyserver keyserver.ubuntu.com `sudo aptitude update 2&gt;&amp;1 | grep -o '[0-9A-Z]\{16\}$' | xargs`
          <br>
          <br>  ОК
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Установка Лотуса 8 Ubuntu 10.04</h1>
          <br>
          <br>
          <br>  1 Скачал образ из Лотуса IBM Lotus Notes 8.5 for Linux (Debian Install) English.tar
          <br>  2 Разархивировал tar –xfv
          <br>  3 Библиотеки sudo apt-get install libgnomeprint2.2-0 libgnomeprintui2.2-0
          <br>  4 установка sudo dpkg -i ibm-lotus-notes-8.5.2.i586.deb
          <br>  6 user     <br>  7 Lotus/Servers/IGNET
          <br>  8 user.id
          <br>  9 Разморозить окна лотуса  http://ymaltsev.livejournal.com/18986.html
          <br>  Скачать библиотеки
          <br>  libgdk_pixbuf-2.0.so.0
          <br>  libgdk_pixbuf_xlib-2.0.so.0
          <br>  libgdk-x11-2.0.so.0
          <br>  libgtk-x11-2.0.so.0
          <br>  сделать их исполняемыми (дал полные права 777) и переписать в каталог /opt/ibm/lotus/notes
          <br>  ВСЕ
          <br>  Проблему с шрифтами решил так
          <br>  #apt-get install ttf-xfree86-nonfree
          <br>  Ok
          <br>  12 Не показываются надписи на рабочей области. Решается путем обновления ср1 ссылка http://www-03.ibm.com/systems/i/software/domino/support/mr85.html
          <br>  Файл http://delivery04-bld.dhe.ibm.com/sar/CMA/LOA/00kxl/0/NotesClientStandard_85FP1_DebianInstall.tar
          <br>  Установить
          <br>  #dpkg –i  NotesClientStandard_85FP1
          <br>  Все ок.
          <br>  Не открываются файлы в Lotus
          <br>  ошибка
          <br>  Запустился с консоли, получил ошибочку:
          <br>  ./openwith: error while loading shared libraries: libeel-2.so.2: cannot open shared object file: No such file or directory
          <br>  Лечится
          <br>  sudo mv /opt/ibm/lotus/notes/openwith /opt/ibm/lotus/notes/openwith.old
          <br>  sudo ln -s $(which gnome-open) /opt/ibm/lotus/notes/openwith
          <br>  Все
          <br>  Запуск из консоли lotus
          <br>  $ /opt/ibm/lotus/notes/notes
          <br>  Все
          <br>  Для переноса файлов нужны файлы.
          <br>  1. *.id
          <br>  2. desktop6.mdk
          <br>  3. names.nsf
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Подключение к 3G UTEL с помощью Huawei E169 </h1>
          <br>
          <br>  Настроил через wvdial
          <br>  Правим /etc/wvdial.conf
          <br>  Код:
          <br>  [Dialer utel]
          <br>  Phone = *99#
          <br>  Username = *
          <br>  Password = *
          <br>  Modem = /dev/ttyUSB0
          <br>  Init = ATZ
          <br>  Init2 = AT Q0 V1 E1 S0=0 &amp;C1 &amp;D2 +FCLASS=0
          <br>  Init3 = AT+CGDCONT=1,"IP","3g.utel.ua"
          <br>  New PPPD = yes
          <br>  Auto DNS = 0
          <br>  Запускаем:
          <br>  Код:
          <br>  $wvdial utel
          <br>  Посмотреть драйвера устройств lsmod  Должен бить  usbserial
          <br>  Запустить драйвер вручную insmod имя драйвера.ko в директории lib\mood\rernel\drive…
          <br>  Список устройств в Linux
          <br>  Команды
          <br>  $Lspci
          <br>  $Lshw
          <br>  $Lsusb
          <br>  так же дополнительно пользуюсь таким приемом (требуются права рута)
          <br>  $tail -f /var/log/messages (показывает в "реальном времени" записи в системный лог)
          <br>  и попробовать при это включать и выключать устройство и смотреть что пишется в логии
          <br>  $dmesg
          <br>  wmvare  включить usb устройство Removadle disk port1
          <br>  Настройка шлюза по умолчанию
          <br>  $route add –net 0.0.0.0 gw  10.16.16.16
          <br>  проверить настройки командой
          <br>  $netstat –rn
          <br>
          <br>
          <br>
          <br>  <h1>!Настройка сервера Х терминала.</h1>
          <br>
          <br>  Надо установить xdm если неустановлен.
          <br>  В директории  /etc/X11/xdm
          <br>  В файле Xaccess прописываем хосты  которым будет разрешен доступ к Х серверу
          <br>  172.16.18.23 NOBROADCAST
          <br>  172.16.18.17 NOBROADCAST
          <br>  В файле Xservers прописываем
          <br>  172.16.18.23:1 foreign
          <br>  172.16.18.17:1 foreign
          <br>  В файле xdm-config надо закомментировать строку DisplayManager.requestPort: 0
          <br>  !DisplayManager.requestPort: 0
          <br>  Потом надо запустить сам сервер командой xdm
          <br>  ВСЕ
          <br>  Для доступа через  ssh  putty в конфиге /etc/ssh/sshd-config
          <br>  X11Forwarding yes
          <br>  У меня эта хрень не заработала
          <br>  Подключение к X srevery через suse
          <br>  Отключаем Х (Чтобы небыло ошибки дисплей 0 занят)
          <br>  #init3
          <br>  #X –query 172.16.18.10 (ip сервера)
          <br>  Или
          <br>  #X –query 172.16.18.10 :1 (указан 1 дисплей на tty 8) без выхода на уровень init3
          <br>  ЕЩЕ открыть несколько X-сеансов одновременно
          <br>  #startx  --  :1
          <br>  ВСЕ
          <br>  Через ssh
          <br>  #ssh –X user@172.16.18.10
          <br>  Подключение к X srevery из Windows
          <br>  Установить клиента xming
          <br>
          <br>
          <br>  <h1>!Установка и развертывание Virtual box 4 в Ubuntu</h1>
          <br>
          <br>  1. С официального сайта скачиваем последнюю версию VirtualBox.
          <br>  http://www.virtualbox.org/wiki/Downloads
          <br>
          <br>  и VirtualBox Extension Pack.И все устанвливаем.
          <br>  2.Скачиваемым модуль phpvirtualbox
          <br>  http://code.google.com/p/phpvirtualbox/downloads/list VirtualBox 4.0.x
          <br>  И разархивировав ложим в нвш каталог с сайтом /var/www
          <br>  переименовать фай config.php-example в config.php
          <br>  3. Запускаем под рутом наш виртуальный сервер
          <br>  #vboxwebsrv (можно с опцией -H 172.16.16.2 наш хост)
          <br>  4. Заходим на сайт http://localhost/phpvirtualbox
          <br>  Логин  по умолчанию  vboxusers:
          <br>  Ошибка Could not load the Host USB Proxy Service (VERR_FILE_NOT_FOUND) надо добавить себя в vboxusers группу
<br>При попытке запустить сетевой интерфейс $sudo ifup eth0 получаем сообщение
<br>eth0: ERROR while getting interface flags: No such device
<br>В логаг смотрим $dmesg |grep eth0 получ eth0 to eth2. Соответственно переименуем везде eth0 на eth2 $sudo vi /etc/network/interfacas
<br>
<br>
<br>
          <br>  При ошибке An error occurred communicating with your vboxwebsrv Выполнить команду. # vboxmanage setproperty websrvauthlibrary null права на папку phpvirtualbox дал все 777 (надо разобраться) отключить пароль при входе в conf.php опция разкоментировать var $noAuth = true; Востановить пароль надо переименовать /var/www/phpvirtulbox/recovery.php.disable на recovery.php и зайти на сайт http://localhost/phpvirtualbox/recovery.php
          <br>  востонавливаем
          <br>  5. Установка пакета расширения для virtualbox. cd /tmp wget http://download.virtualbox.org/virtualbox/4.0.0/Oracle_VM_VirtualBox_Extension_Pack-4.0.0-69151.vbox-extpack VBoxManage extpack install Oracle_VM_VirtualBox_Extension_Pack-4.0.0-69151.vbox-extpack При появлениие 2-х мышок надо поставить пакет дополнения http://download.virtualbox.org/virtualbox/4.0.4/VBoxGuestAdditions_4.0.4.iso все Настройка доступа через ssl к virtualbox.
          <br>  HTTPS Configuration
          <br>  The mod_ssl module adds an important feature to the Apache2 server
          <br>  the ability to encrypt communications. Thus, when your browser is communicating
          <br>  using SSL, the https:// prefix is used at the beginning of the Uniform Resource Locator (URL)
          <br>  in the browser navigation bar.
          <br>  The mod_ssl module is available in apache2-common package. Execute the
          <br>  following command from a terminal prompt to enable the mod_ssl module:
          <br>  sudo a2enmod ssl
          <br>  There is a default HTTPS configuration file in /etc/apache2/sites-available/default-ssl.
          <br>  In order for Apache2 to provide HTTPS, a certificate and key file are also needed. The default HTTPS configuration will use a certificate and key generated by the ssl-cert package.
          <br>  They are good for testing, but the auto-generated certificate and key should be replaced
          <br>  by a certificate specific to the site or server. For information on generating a key and obtaining
          <br>  a certificate see the section called “Certificates”
          <br>  To configure Apache2 for HTTPS, enter the following:
          <br>  sudo a2ensite default-ssl
          <br>  [Note]
          <br>  The directories /etc/ssl/certs and /etc/ssl/private are the default locations.
          <br>  If you install the certificate and key in another directory make sure to change
          <br>  SSLCertificateFile and SSLCertificateKeyFile appropriately.
          <br>  With Apache2 now configured for HTTPS, restart the service to enable the new settings:
          <br>  sudo /etc/init.d/apache2 restart
          <br>  [Note]
          <br>  Depending on how you obtained your certificate you may need to enter a passphrase when Apache2 starts.
          <br>  You can access the secure server pages by typing https://your_hostname/url/ in your browser address bar.
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!TightVns Подключение из Windows к Linux</h1>
          <br>
          <br>  Настроить подключение на компьютере под управлением Ubuntu 10.04-10. Для начала нужно установить tightvncserver.
          <br>  1. Запустите Центр приложений Ubuntu (Ubuntu Software Center).
          <br>  2. Введите в строке поиска «tightvncserver» (без кавычек).
          <br>  3. Выделите tightvncserver и нажмите кнопку «Установить» (Install).
          <br>  4. Введите пароль к учетной записи root.
          <br>  После установки нужно настроить сервер. Для этого:
          <br>  1. Откройте терминал.
          <br>  2. Выполните команду tightvncserver.
          <br>  Или командой
          <br>  $vncserver -geometry 1024x768 -depth 16
          <br>  3. Введите пароль.
          <br>  4. При необходимости задайте пароль для просмотра.
          <br>  Останавливается сервер следующей командой:
          <br>  $ vncserver -kill :1
          <br>  :1 номер от 1 до
          <br>  Теперь к этому компьютеру можно подключиться с помощью приложения TightVNC Viewer из Windows. Вызовите его из меню «Пуск | Все программы | TightVNC | TightVNC Viewer» и введите в появившемся окне IP-адрес компьютера под управлением Linux с указанием порта 5901 в формате «192.168.100.21:5901». Если номер порта не указать, TightVNC Viewer попытается подключиться к порту 5900, и соединение установить не удастся.
          <br>  При подключении потребуется указать пароль, который вы задали при запуске сервера на компьютере под управлением Linux. После успешной авторизации будет установлено соединение
          <br>  -Не работает русский шрифт
          <br>
          <br>
          <br>
          <br>  <h1>!Установка Ubuntu по сети</h1>
          <br>
          <br>  ?Содержание
          <br>  •	Установка Ubuntu по сети
          <br>  o	Настройка сервера для установки
          <br>  o	Установка по при помощи DHCP
          <br>  ?	Настройка DHCP демона
          <br>  o	Установка по при помощи minimal CD
          <br>  o	Ссылки
          <br>  Установка Ubuntu по сети
          <br>  Ubuntu, как и многие другие дистрибутивы Linux, можно легко установить по сети. Для этого вам всего лишь потребуется сетевое соединение с компьютером, который будет служить сервером для установки. BIOS вашего компьютера должен для этого поддерживать загрузку по сети.
          <br>  Настройка сервера для установки
          <br>  Прежде всего вам потребуется компьютер с Ubuntu, с которого вы будете устанавливать систему, и ISO образ диска с необходимой версией Ubuntu.
          <br>  Установка по при помощи DHCP
          <br>  И так для установки нам понадобится установить в систему FTP, HTTP и DHCP серверы, чтобы позволить второму компьютеру подключиться к машине с установленной Ubuntu. Открываем терминал и выполняем следующее:
          <br>  sudo apt-get install tftpd-hpa apache2 dhcp3-server openbsd-inetd
          <br>  Ждем пока все пакеты будут загружены и установлены.
          <br>  Следующий наш шаг заключается в том чтобы монтировать образ диска с Ubuntu. Если образ находится на вашем жестком диске, то вводим в терминал следующие команды:
          <br>  cd /путь_к_образу
          <br>  sudo mkdir /var/lib/tftpboot/ubuntu
          <br>  sudo mount -o loop имя_образа.iso /var/lib/tftpboot/ubuntu
          <br>  Создайте симлинк к смонтированному образу из корневого каталога Apache:
          <br>  cd /var/www
          <br>  sudo ln -s /var/lib/tftpboot/ubuntu/
          <br>  Если у Вас нет ISO образа диска, но есть сам диск вставьте его в CD/DVD привод. Диск автоматически монтируется в /media/cdrom. Затем необходимо создать симлинк для FTP и HTTP серверов, вводим в терминал следующие команды:
          <br>  sudo ln -s /media/cdrom /var/lib/tftpboot/ubuntu/
          <br>  sudo ln -s /media/cdrom /var/www/ubuntu
          <br>  Настройка DHCP демона
          <br>  Для начала сделаем резервную копию файла настроек dhcpd.conf, используя следующую команду:
          <br>  sudo mv dhcpd.conf dhcpd.conf.old
          <br>  Затем приступим к редактированию файла настроек, для этого вводим в терминал:
          <br>  sudo gedit /etc/dhcp3/dhcpd.conf
          <br>  После открытия файла настроек, необходимо добавить туда следующее:
          <br>  ping-check = 1;
          <br>  filename = "ubuntu/install/netboot/pxelinux.0";
          <br>  subnet 192.168.1.0
          <br>  netmask 255.255.255.0 {
          <br>  range 192.168.1.10 192.168.1.254;
          <br>  }
          <br>  •	subnet - Ваша подсеть;
          <br>  •	netmask - маска Вашей подсети;
          <br>  •	range - интервал IP-адресов в соответствии с настройками вашей сети. Случайный IP адрес из этого интервала будет присвоен второму компьютеру.
          <br>  После изменения настроек сохраняем файл Ctrl+S и перезапускаем dhcp-сервер:
          <br>  На сервере нужно задать статический ip что бы не была ошибка dhcpd: Not configured to listen on any interfaces!
          <br>  sudo /etc/init.d/dhcp3-server restart
          <br>  После завершения настройки, необходимо перевести второй компьютер в режим загрузки по сети. После этого Вы должны увидеть экран установки Ubuntu.
          <br>  В окне зеркало архивов в самый верх и вручную прописать наш адрес сервера где лежит наш образ. ОК
          <br>
          <br>
          <br>
          <br>  <h1>!Локализация консоли</h1>
          <br>
          <br>  Настроить сервер на работу через pytty
          <br>  1 Настройки pytty
          <br>
          <br>  2 На сервере убунту в файле /etc/ssh/sshd _config  раскоментировать  UsePAM yes
          <br>  Перегрузить сервер ВСЕ
          <br>
          <br>  При установке сервера допустил ошибку поставив локализацию украинскую
          <br>  После этого bacula не хотела понимать русский шрифт помогло это решение.
          <br>
          <br>  Ubuntu Server администрирование консоль руководство
          <br>
          <br>  На большинстве удалённых серверов (например, если арендуете VPS или dedicated сервер) у вас нету возможности воспользоваться инсталлятором Ubuntu Server, вы получаете готовую систему с настройками по умолчанию и минимально возможной конфигурацией. Дальше дело за вами: систему нужно будет настроить под себя и свои нужды.
          <br>
          <br>  Консоль по умолчанию в большинстве темплейтов (готовых образов для переноса на сервер) — POSIX. Это значит, например, что если вам прямо на сервере потребуется (если не потребуется, а может быть и такое, то оставляйте имеющуюся конфигшурацию) поправить какой-нибудь текстовый файл на русском языке или же сохранить на сервере файл с кириллическим именем, то вы столкнетесь с рядом проблем.
          <br>
          <br>  Чтобы их избежать необходимо локализовать вашу систему. Сделать это сравнительно просто.
          <br>
          <br>  Во-первых, список поддерживаемых локалей нужно добавить нужную:
          <br>  echo ru_RU UTF-8 &gt;&gt; /var/lib/locales/supported.d/local
          <br>
          <br>  Далее необходимо, чтобы система сгенерировала локаль:
          <br>  sudo dpkg-reconfigure locales
          <br>
          <br>  Проверим, добавилась ли нужная локаль командой locale -a — на экране увидите список локалей доступных для использования, в списке должна появится ваша новая ru_RU. Если соответствующая локаль теперь имеется, то достаточно указать системе, что эту локаль теперь необходимо использовать:
          <br>
          <br>  echo LANG="ru_RU" &gt;&gt; /etc/environment
          <br>  echo LANGUAGE="ru_RU:ru" &gt;&gt; /etc/environment
          <br>
          <br>  Всё готово. После перезагрузки система будет наделена новой кириллической локалью.
          <br>  » 164 просмотра
          <br>  Re: Локализация консоли
          <br>  Комментарий от автора fjey поступил к нам в 18.01.2009 (Вс) 23:50:
          <br>
          <br>  $ apt-get install console-cyrillic
          <br>  Enter Enter Enter
          <br>  $ cyr
          <br>  У меня не заработала
          <br>  не стану утверждать что этот метод лучше, но пока обхожусь именно им.
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>! Установка архиватора peazip</h1>
          <br>
          <br>  http://www.peazip.org/peazip-linux.html
          <br>  peazip_3.7.LINUX.Qt-2_all.deb
          <br>  доустановить библеотку
          <br>
          <br>  https://launchpad.net/~ximion/+archive/ppa/+files/libqt4pas5_2.1Qt4.5.3-1_i386.deb
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>            <br>
          <br>
          <br>  <h1>!Libreoffice 3.3.2, русификация</h1>
          <br>
          <br>  $sudo apt-get install libreoffice-l10n-ru libreoffice-help-ru
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>! OpenOffice </h1>
          <br>  Добавление русского словаря, скачиваем словарь http://wiki.services.openoffice.org/wiki/RU/kb/70000000 устанавливаем tools-extentsion meneder. OK
          <br>
          <br>
          <br>
          <br>  <h1>!LibreOffice настройка </h1>
          <br>  я установил версию 3.4.3 по иструкции с официального сайта.
          <br>
          <br>  решение с долгой загруккой
          <br>  проблема с DNC определил
          <br>  # tcpdump -ni eth0 port 53
          <br>
          <br>  Правильно прописать
          <br>  /etc/hosts
          <br>  127.0.0.1       localhost
          <br>
          <br>  172.16.18.1    name.dom  it
          <br>  проверяем
          <br>  hostname  --long
          <br>  hostname
          <br>  hostname -f
          <br>
          <br>  Скорость увеличилась загрузки
          <br>
          <br>
          <br>
          <br>  <h1>!Определить версию UBUNTU</h1>
          <br>  Можно в файле /etc/issue или в файле /etc/motd
          <br>
          <br>
          <br>
          <br>  <h1>!Этапы загрузки ОС Linux (в схеме)</h1>
          <br>  http://www.k-max.name/linux/nachalo-etapy-zagruzki-os-linux-v-sxeme/#first
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Установка Webmin в Ubuntu</h1>
          <br>
          <br>  Webmin - это программный комплекс, который позволяет администрировать unix-подобную операционную систему, не работая с командной строке и не запоминая ни одной команды. Все управление сервером происходит через веб-интерфейс. Используя любой браузер, администратор сервера может заводить новые аккаунты, почтовые ящики, изменять настройки веб-сервера Apache, исправлять и дополнять записи [[DNS], настраивать сайты, почтовые ящики и т.д. Webmin состоит из простого веб-сервера и небольшого количества скриптов, которые собственно и осуществляют связь между командами администратора через веб-интерфейс и их исполнением на уровне операционной системы и прикладных программ. Webmin написан полностью на языке Perl и не использует никаких дополнительных нестандартных модулей. Простота, легкость и быстрота выполнения команд - одно из самых больших преимуществ данной панели управления. Данная панель управления бесплатно распространяется для коммерческого и некоммерческого использования. Авторы этой программы позволяют всем желающим не только бесплатно использовать программу, но и изменять ее по своему усмотрению. Работать с Webmin достаточно просто - нужно запустить браузер, набирать http://имя_домена.com:10000/ и попасть на страницу администрирования.1
          <br>  Подготовка системы
          <br>
          <br>  Следует установить необходимые пакеты:
          <br>  sudo apt-get install perl libnet-ssleay-perl openssl libauthen-pam-perl libpam-runtime libio-pty-perl libmd5-perl
          <br>  Установка Webmin
          <br>

          <br>  Для установки желательно скачать последнюю версию Webmin с сайта разработчика. По ссылке Download Section смотрим какой номер этой самой последней версии.
          <br>
          <br>  На момент написания статьи - 1.390.
          <br>
          <br>  Далее скачиваем на компьютер пакет командой:
          <br>
          <br>  wget http://prdownloads.sourceforge.net/webadmin/webmin_1.420_all.deb
          <br>
          <br>  Если версия другая, просто нужно исправить на свежую. Далее установливаем пакет в систему
          <br>  sudo dpkg -i webmin_1.420_all.deb
          <br>  Не забываем поправить версию. По окончании установки система сообщит адрес, через который можно зайти браузером для администрирования.
          <br>  Последний штрих, пароль рута можно поменять командой:
          <br>  sudo /usr/share/webmin/changepass.pl /etc/webmin root
          <br>  Donet
          <br>  при подготовке статьи были использованы материалы Википедии и Only Ubuntu Linux
          <br>
          <br>
          <br>  Popularity: 36% [?]
          <br>  http://ru.wikipedia.org/wiki[возврат
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Логи </h1>
          <br>
          <br>  rsyslog: централизованный сбор логов
          <br>  Для передачи логов с одной машины на другую нам понадобится две активных инсталляции rsyslog: server и client. Поставим их по мануалу: Замена rsyslog (sysklogd) на syslog в CentOS 5
          <br>  Client
          <br>  Тут в принципе ничего сложного - нам необходимо настроить отправку важных логов по tcp на удаленную машину, пусть это будет log.domain.ru (ага, я не боюсь постоянного резолвера).
          <br>  Открываем конфиг:
          <br>  vi /etc/rsyslog.conf
          <br>  Стандартный конфиг выглядит так:
          <br>  cat /etc/rsyslog.conf
          <br>  # Log all kernel messages to the console.
          <br>  # Logging much else clutters up the screen.
          <br>  #kern.* /dev/console
          <br>  # Log anything (except mail) of level info or higher.
          <br>  # Don't log private authentication messages!
          <br>  *.info;mail.none;authpriv.none;cron.none /var/log/messages
          <br>  # The authpriv file has restricted access.
          <br>  authpriv.* /var/log/secure
          <br>  # Log all the mail messages in one place.
          <br>  mail.* -/var/log/maillog
          <br>  # Log cron stuff
          <br>  cron.* /var/log/cron
          <br>  # Everybody gets emergency messages
          <br>  *.emerg *
          <br>  # Save news errors of level crit and higher in a special file.
          <br>  uucp,news.crit /var/log/spooler
          <br>  # Save boot messages also to boot.log
          <br>  local7.* /var/log/boot.log
          <br>  Вариант с отсылкой всех логов без сохранения локально будет выглядеть так (простое копирование):
          <br>  *.info;mail.none;authpriv.none;cron.none @@xx.xx.xx.xx:514
          <br>  А для сохранения локально и отсылки на удаленный сервер он будет выглядеть так:
          <br>  *.info;mail.none;authpriv.none;cron.none /var/log/messages
          <br>  *.info;mail.none;authpriv.none;cron.none @@xx.xx.xx.xx:514
          <br>  Перезапускаем rsyslog:
          <br>  /etc/init.d/rsyslog restart
          <br>  А на сервере можно заменить слушающий rsyslog командой nc:
          <br>  nc -l 514
          <br>  Теперь для теста попробуем отправить сообщение, которое обычно должно упасть в /var/log/messages:
          <br>  logger -p ftp.info 'test message suxx'
          <br>  Server
          <br>  Открываем конфиг (эта и последующие операции выполняются на сервере):
          <br>  vi /etc/rsyslog.conf
          <br>  Разрешаем rsyslog у слушать удаленные машины:
          <br>  vi /etc/sysconfig/rsyslog
          <br>  И строку:
          <br>  SYSLOGD_OPTIONS="-m 0"
          <br>  Заменяем на:
          <br>  SYSLOGD_OPTIONS="-m 0 -t514"
          <br>  Добавляем в самый верх следующее:
          <br>  $AllowedSender TCP, 127.0.0.1, cli.ent.ip.add
          <br>  Перезапускаем rsyslog:
          <br>  /etc/init.d/rsyslog restart
          <br>  Теперь открываем просмотр лога для контроля, что tcp слушается (tcpReception="Yes") и ожидания логов с клиент машины:
          <br>  tail -f /var/log/messages
          <br>  x-pid="32126" x-info="http://www.rsyslog.com"][x-configInfo udpReception="No" udpPort="514" tcpReception="Yes" tcpPort="514"] restart
          <br>  А тем временем на клиент машине вызываем давнюю команду:
          <br>  logger -p ftp.info 'test remote message suxx'
          <br>  И в ответ на сервере должны увидеть следующее:
          <br>  Dec 22 06:08:09 clienthostname root: test remote message suxx
          <br>  Ну и все, осталось узнать, как это все себя будет вести под нагрузкой =)
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>! Посмотреть сколько расходуется памяти командой </h1>
          <br>  $free –o
          <br>  Очистить кеш файловой системы
          <br>  $echo 1 &gt; /proc/sys/vm/drop_caches
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  Инструкция по настройке serial-port Ubuntu
          <br>  apt-get install minicom
          <br>  &nbsp;Настройка minicom
          <br>   dmesg | grep ttyS
          <br>  [ 12.282348] serial8250: ttyS0 at I/O 0x3f8 (irq = 4) is a 16550A
          <br>  [ 12.282928] 00:0c: ttyS0 at I/O 0x3f8 (irq = 4) is a 16550A
          <br>  Теперь запустим minicom от имени пользователя root:
          <br>  $ sudo minicom
          <br>  Нажмите Ctrl-A O чтобы попасть в настройки последовательного порта и нажмите Enter, введите
          <br>   A и что устройство указывает на /dev/ttyS0, затем нажмите Enter, чтобы подтвердить.
          <br>  Нажмите E и удостоверьтесь, что здесь стоит значение 9600 потом Е Q мы  выбрали 8 бит
          <br>   чент нет стоповый бит 1, нажмите Enter, чтобы подтвердить. Снова нажмите Enter, чтобы
          <br>  вернуться к предыдущему экрану и, наконец, перейдите к пункту настройки "Save setup as dfl",
          <br>  нажмиет Enter чтобы подтвердить, Esc чтобы вернуться назад к первому экрану и нажмите Ctrl-A Q
          <br>  чтобы выйти.
          <br>  $ sudo minicom -s
          <br>  Попадаем сразу в настройки serial porta
          <br>
          <br>
          <br>
          <br>  <h1>! Замена символов с помощью команды tr </h1>
          <br>  echo "HELLO WORLD" |tr 'A-Z' 'a-z'
          <br>   в результате получим
          <br>  hello world
          <br>
          <br>
          <br>  <h1>Удаление не нужных символов.</h1>
          <br>  $ echo "Hello 123 world 456" | tr -d '0-9'
          <br>   получим
          <br>  Hello world
          <br>
          <br>
          <br>  <h1>!Разбить файл на куски равных размеров.</h1>
          <br>  $split -b 10k data.file
          <br>   	Разобьет файл data.file на файлы размером 10k.
          <br>
          <br>  $ split -b 10k data.file -d
          <br>   -a 4 split_file
          <br>  	Разобьет файл data.file на файлы размером 10k добавит в название split_file  для новых файлов и проставит нумерацию  от 1 до 9999
          <br>
          <br>
          <br>
          <br>   <h1>! Создание загрузочной флешки </h1>
          <br> с помощью http://unetbootin.sourceforge.net/ кросплатформенная
          <br>
          <br>  Перед запуском устанавливаем 7zip
          <br>
          <br>  $ sudo apt-get install p7zip-full
          <br>
          <br>  Флешка на которой будем делать образ должна быть пустой. Лучше отформатировать.
          <br>
          <br>  Все
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Переименовать все файлы и сделать название файлов большими буквами в текущей директории.</h1>
          <br>
          <br>  $ rename 'y/A-Z/a-z/' *
          <br>
          <br>  и наоборот
          <br>  $ rename 'y/a-z/A-Z/' *
          <br>
          <br>
          <br>  <h1>!Сравнить и найти различие отличие 2 файла</h1>
          <br>  $ comm A.txt B.txt
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Создание мягкой ссылки командой</h1>
          <br>  $ ln -s test links	Где test существующая папка или файл, а links имя мягкой ссылки
          <br>  Для удаления мягкой ссылки можно использовать команды.
          <br>  $rm links
          <br>  $unlink links
          <br>  Обратить внимание, что при раздаче прав на ссылку назначаются права какие и назначены в директории. То есть если на ссылку назначены права для двух групп а в каталог должна иметь доступ только одна группа необходимо удалит права для второй группы на сылку.
          <br>
          <br>
          <br>
          <br>  <h1>!Изменение времени создания файла</h1>
          <br>  $touch -d '' 2000-02-30 12:56:34'' testfile.txt
          <br>
          <br>
          <br>
          <br>  <h1>!Переименовать имя сервера</h1>
          <br>
          <br>  /etc/hostname
          <br>
          <br>  /etc/host
          <br>
          <br>  Проверяем командой
          <br>
          <br>  hostname
          <br>
          <br>  перезагружаем
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Вход на удаленный сервер чере ssh без пароля</h1>
          <br>  $ ssh-keygen
          <br>  Далие ок-ок-ок
          <br>  Передаем сгенерированный ключ на удаленный сервер
          <br>  $ ssh-copy-id user@fs
          <br>  Теперь можно заходить без ввода пароля через ssh
          <br>  $ssh user@fs
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Отображение русского в консоли Ubuntu 11.04 Natty</h1>
          <br>  Как заметил один мой знакомый: русификация консоли слетает в&nbsp;Ubuntu&nbsp;через версию. Видимо 10.04 она тоже слетала, а теперь пришла очередь 11.04. Пока возился с настройками после обновления, ненадолго застрял в консоли и обнаружил, что вместо русских букв там теперь квадратики. Выяснение причин вскрыло абсолютно раздолбайское отношение разработчиков к консоли. Я конечно понимаю, что она нужна абсолютному меньшинству пользователей. И все же это место, где мы обычно оказываемся, когда все остальное уже не работает.
          <br>  В общем, если вас коснулась эта проблема и вам, надо срочно привести консоль в рабочее состояние предлагаю делать следующее:
          <br>  Установить или удостовериться в наличии необходимых пакетов:
          <br>  env LANG=C sudo aptitude install console-setup keyboard-configuration
          <br>  Выполнить настройку консоли (или перенастройку):
          <br>  env LANG=C sudo dpkg-reconfigure console-setup
          <br>  sudo dpkg-reconfigure keyboard-configuration
          <br>  Включить настройку консоли при загрузке. Для этого в файл&nbsp;/etc/initramfs-tools/initramfs.confнеобходимо добавить параметр&nbsp;FRAMEBUFFER=Y
          <br>  Обновить initramfs, чтобы в него добавились нужные скрипты:
          <br>  sudo update-initramfs -u
          <br>
          <br>
          <br>  <h1>! Первоночальная настройка сервера</h1>
          <br>  После установки сервера в /etc/apt/sours.list
          <br>  Все закомментировать оставим только.
          <br>  deb cdrom:[Ubuntu-Server 10.04.3 LTS _Lucid Lynx_ - Release i386 (20110719.2)]/ lucid main restricted
          <br>  Сохраняем.
          <br>  Монтируем диск #mount /dev/cdrom 	/cdrom
          <br>  Обновляем пакеты #apt-get update
          <br>  Устанавливаем #apt-get install ssh
          <br>  Прописать имя hosta
          <br>  /etc/hosts
          <br>  127.0.0.1       localhost
          <br>
          <br>  172.16.16.16    name.domen it
          <br>  проверяем
          <br>  hostname  --long
          <br>  hostname
          <br>  hostname -f
          <br>  hostname -d
          <br>
          <br>
          <br>
          <br>  <h1>!Присоеденить жесткий диск </h1>
          <br>  Прописываем в /etc/fstab
          <br>  /dev/sdb1       /media/virt     			ntfs
          <br>
          <br>  наш диск	каталог монтирования	файловая система
          <br>  Выполняем монтирование
          <br>  #mount -a
          <br>  #mount
          <br>
          <br>
          <br>
          <br>  <h1>!Если не видно всю справку по команде выполняем</h1>
          <br>  # команда --help 2&gt;&amp;1 |less
          <br>
          <br>
          <br>  <h1>!Вывести дату дата</h1>
          <br>   #date +%d-%m-%y
          <br>
          <br>  <h1>!Разархивировать zip файл</h1>
          <br>  unzip /home/user/Загрузки/clonezilla-live-1.2.10-14-i686-pae.zip -d /media/Флешка
          <br>
          <br>
          <br>  <h1>!Для интерактивного вывода на кансоль wath</h1>
          <br>  #watch du -h /srv
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Задать дату на сервере</h1>
          <br>  date MMDDhhmmCCYY.ss
          <br>  MM — месяц, DD — день месяца, hh — часы, mm — минуты, CCYY — 4 цифры года, ss — секунды
          <br>  Например:
          <br>  date 100615352006.30
          <br>  Эта команда установит текущие дату и время на 06 октября 2006 года, 15:35:30.
          <br>  Обратите внимание: дату и время может изменять только root-пользователь.
          <br>
          <br>
          <br>
          <br>  <h1>!Подщитать число строк в файле</h1>
          <br>  $ wc -l test.txt
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>! pgrep</h1>,
          <br>  pkill  -  look  up  or signal processes based on name and other
          <br>
          <br>         attributes
          <br>
          <br>
          <br>  #pgrep notes
          <br>  #pkill notes
          <br>
          <br>
          <br>  <h1>!Сылка на сетевой диск</h1>
          <br>  $ ln -s    <br>
          <br>
          <br>
          <br>  ^ Description Example
          <br>
          <br>  The start of the line marker. ^tux matches a string that
          <br>
          <br>                               starts the line with tux.
          <br>
          <br>  $ The end of the line marker. tux$ matches strings of a
          <br>
          <br>                               line that ends with tux.
          <br>
          <br>  . Matches any one character. Hack. matches Hack1,
          <br>
          <br>                              Hacki but not Hack12,
          <br>
          <br>                             Hackil, only one additional
          <br>
          <br>                            character matches.
          <br>
          <br>  [] Matches any one of the characters enclosed in coo[kl] matches cook or
          <br>
          <br>     [chars]. cool.
          <br>
          <br>  [^] Matches any one of the characters EXCEPT those 9[^01] matches 92, 93
          <br>
          <br>      that are enclosed in [^chars]. but not 91 or 90.
          <br>
          <br>  [-] Matches any character within the range specified [1-5] matches any digits
          <br>
          <br>      in []. from 1 to 5.
          <br>
          <br>  ? The preceding item must match one or zero times. colou?r matches
          <br>
          <br>   color or colour but not
          <br>
          <br>  colouur.
          <br>
          <br>  + The preceding item must match one or more Rollno-9+ matches
          <br>
          <br>    times. Rollno-99, Rollno-9
          <br>
          <br>          but not Rollno-.
          <br>
          <br>  * The preceding item must match zero or more co*l matches cl, col,
          <br>
          <br>    times. coool.
          <br>
          <br>  () Creates a substring from the regex match. ma(tri)?x matches max
          <br>
          <br>                                              or matrix.
          <br>
          <br>  {n} The preceding item must match n times. [0-9]{3} matches any
          <br>
          <br>                                            three-digit number. [0-9]
          <br>
          <br>                                           {3} can be expanded as:
          <br>
          <br>  [0-9][0-9][0-9].
          <br>
          <br>  {n,} Minimum number of times that the preceding item [0-9]{2,} matches any
          <br>
          <br>      should match.
          <br>
          <br>     number, that is, two digits or
          <br>
          <br>    more.
          <br>
          <br>  {n, m} Specifies the minimum and maximum number of
          <br>
          <br>        times the preceding item should match.
          <br>
          <br>  [0-9]{2,5} matches any
          <br>
          <br>  number that is having two
          <br>
          <br>  digits to five digits.
          <br>
          <br>  | Alternation—one of the items on either of sides of
          <br>
          <br>     | should match.
          <br>
          <br>  Oct (1st | 2nd)
          <br>
          <br>  matches Oct 1st or Oct
          <br>
          <br>  2nd.
          <br>
          <br>  \ The escape character for escaping any of the
          <br>
          <br>   special characters mentioned above.
          <br>
          <br>  a\.b matches a.b but
          <br>
          <br>  not ajb. It ignores special
          <br>
          <br>  meaning of .by prefexing \.
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Поиск а логах</h1>
          <br>  # zgrep "|post|" /var/log/syslog* | grep chmod
          <br>
          <br>
          <br>
          <br>  <h1>!Определение переменных</h1>
          <br>  $ var=wreuiweuiewruuiri
          <br>  <h1>!Вывести переменную</h1>
          <br>  $echo $var
          <br>  <h1>!Вывести часть переменной</h1>
          <br>  $echo ${var:4:8}
          <br>  Выводит перемеренную с 4-го символа 8 символов
          <br>
          <br>
          <br>
          <br>  <h1>!Удалить зависшее окно в Х в консоле</h1>
          <br>  # xkill

          <br>  и мышкой кликаем по зависшему окну.
          <br>
          <br>  <h1>!Проврить линию клиент</h1>
          <br>  #iperf -c 172.16.29.5 -f K
          <br>
          <br>  Сервер
          <br>  #iperf -s
          <br>
          <br>  <h1>!Архивируем с gunzip gzip</h1>
          <br>  $gzip filename #Создаст архив с именем filename.gz
          <br>  $gunzip filename.gz #Разархивирует архив
          <br>
          <br>  <h1>!Gzip + tarball</h1>
          <br>
          <br>  $ tar -czvvf archive.tar.gz [FILES]
          <br>    #Создаст архив tar cжатый gzip
          <br>  $ tar -cavvf archive.tar.gz [FILES]
          <br>    # Опция
          <br>
          <br>  <h1>!Сброс пароля root</h1>
          <br>  Ноябрь 15th, 2010&nbsp;Рубрики:&nbsp;Linux,&nbsp;Основы
          <br>  Сегодня запустил, когда-то давно созданную в VirtualBox машину с Debian'ом внутри. Ну и как "положено", забыл пассворд пользователей, да и в обще забыл, как там звали пользователя. Полез как положено в гугл, в котором куча решений по восстановлению паролей. Но не все мне не помогли. Ибо решение везде дано общее... Сегодня в&nbsp;своем блогеприведу шаги, которые мне помогли мне с решением восстановления паролей пользователей:
          <br>  Загрузка в single-mode (single-user):
          <br>  в начале загрузки, нажмите Esc для входа в загрузочное меню GRUB (соответственно, ели таймаут загрузки маленький, то и нажимать нужно достаточно активно)
          <br>  Стрелками выбираем образ загрузки, которым пользуемся по умолчанию и нажимаем e (от edit) для редактирования.
          <br>  Появиться несколько строк, одна из которых будет примерно следующего содержания:
          <br>   kernel /образ_ядра root=/dev/корневой_раздел_жесткого_диска ro quiet splash
          <br>  становимся стрелкой на данный раздел, опять нажимаем e
          <br>  редактируем появившуюся строку и делаем ее следующего вида:
          <br>   kernel /образ_ядра root=/dev/корневой_раздел_жесткого_диска ro single
          <br>  Нажимаем&nbsp;enter&nbsp;и&nbsp;b&nbsp;(от boot)
          <br>  в результате получаем консоль с правами root&nbsp;и сообщением:
          <br>   Give root password for maintenance (or type Control-D to continue):
          <br>  Данный способ нам поможет, если помним пароль root, сменить пароль у другого пользователя, использующего sudo, но если мы пароль не знаем, то идем по другому пути:
          <br>  Восстановление пароля root:
          <br>  в начале загрузки, нажмите Esc для входа в загрузочное меню GRUB (соответственно, ели таймаут загрузки маленький, то и нажимать нужно достаточно активно)
          <br>  Стрелками выбираем образ загрузки, которым пользуемся по умолчанию и нажимаем e (от edit) для редактирования.
          <br>  Появиться несколько строк, одна из которых будет примерно следующего содержания:
          <br>   kernel /образ_ядра root=/dev/корневой_раздел_жесткого_диска ro quiet splash
          <br>  становимся стрелкой на данный раздел, опять нажимаем e
          <br>  редактируем появившуюся строку и делаем ее следующего вида:
          <br>   kernel /образ_ядра root=/dev/корневой_раздел_жесткого_диска rw init=/bin/bash
          <br>  или
          <br>   kernel /образ_ядра root=/dev/корневой_раздел_жесткого_диска rw init=/bin/sh
          <br>  Нажимаем&nbsp;enter&nbsp;и&nbsp;b&nbsp;(от boot)
          <br>  в результате получаем консоль с правами root&nbsp;без запроса пароля
          <br>  для смены пароля root вводим:
          <br>  passwd
          <br>  2 раза новый пароль
          <br>  для смены другого пользователя:
          <br>  passwd другой_пользователь
          <br>  2 раза новый пароль
          <br>  далее перезагрузка
          <br>  Но это стандартная схема. Я же столкнулся со следующей проблемой:
          <br>  После проделанных шагов, у меня при вводе passwd вывалилась гадость:
          <br>  bash: passwd : command not found
          <br>  А все потому что, как потом догадался - каталог usr оказался на отдельном разделе и при загрузке в указанном режиме он автоматом не монтируется.
          <br>  После выполнения
          <br>  mount /dev/устройство_с_каталогом_usr
          <br>  passwd отлично выполнилось.
          <br>  С Уважением, Mc.Sim!
          <br>  (Всего просмотров 1,408, из них за сегодня 23 просмотров)
          <br>  Поделиться…
          <br>
          <br>  Теги:&nbsp;Debian,&nbsp;init,&nbsp;Linux,&nbsp;root,&nbsp;UNIX,&nbsp;загрузка,&nbsp;основы
          <br>  Оставить комментарий&nbsp;|&nbsp;Trackback
          <br>  Есть 2 коммент. к “Сброс пароля root”
          <br>
          <br>  Я обычно это несколько иначе делал.Например запускал установочный диск/флешку Линукса, потом переходил в консоль, в которой мы уже root. После монтировал раздел где стоит Linux, например так:
          <br>  mkdir /mnt/linux
          <br>  mount -t auto /dev/sda1 /mnt/linux
          <br>  После чего указывал, что /mnt/linux будет родительской директорий и все изменения и запуск программ будут касаться именно его.
          <br>  chroot /mnt/linux
          <br>  Ну, а затем уже можно менять пароли, после смены
          <br>  exit&amp;reboot
          <br>
          <br>
          <br>
          <br>  <h1>!При ошибке</h1>
          <br>  W: GPG error: http://ppa.launchpad.net lucid Release: Следующие подписи не могут быть проверены, так как недоступен открытый ключ: NO_PUBKEY 5A9A06AEF9CB8DB0
          <br>  делаем так
          <br>
          <br>  apt-key adv --recv-keys --keyserver keyserver.ubuntu.com 5A9A06AEF9CB8DB0
          <br>
          <br>  где 5A9A06AEF9CB8DB0
          <br>   ключ
          <br>
          <br>
          <br>  BeauTimer — простой и красивый таймер&nbsp;
          <br>
          <br>
          <br>
          <br>
          <br>  <h1>!Сочетания Горячие клавиши в шелле</h1>
          <br>
          <br>  Сначала немного сочетаний клавиш с ctrl.
          <br>
          <br>  Ctrl + a — переход в начало строки (cisco, csh, zsh)
          <br>  Ctrl + b — переход на 1 символ назад (cisco, csh, zsh)
          <br>  Ctrl + c — посылает программе SIGINT. Обычно, прерывает текущее задание (csh, zsh)
          <br>  Ctrl + d — удаляет символ под курсором (аналог delete) (cisco, csh, zsh)
          <br>  Ctrl + e — переход к концу строки (cisco, csh, zsh)
          <br>  Ctrl + f — переход на 1 символ вперёд (cisco, csh, zsh)
          <br>  Ctrl + k — удаляет всё, до конца строки (EOL, а не на экране!) (cisco, csh, zsh)
          <br>  Ctrl + l — очищает экран. Аналог команды clear. (csh, zsh)
          <br>  Ctrl + r — поиск по истории. Повторение поиска (листание результатов поиска). То есть инкрементальный поиск. (zsh)
          <br>  Ctrl + j — прекращает поиск и позволяет отредактировать найденную команду. Если поиск не производился, то аналогично нажатию return. (в zsh выполняет команду)
          <br>  Ctrl + t — меняет символ под курсором на предыдущий. Или, если хотите, тянет предыдущий символ к концу строки. (cisco, csh, zsh)
          <br>  Ctrl + u — удаляет все символы слева от курсора до начала строки. (cisco, в csh, zsh удаляет всю строку)
          <br>  Ctrl + w — удаляет символы слева от курсора до начала слова. (cisco, csh, zsh)
          <br>  Ctrl + xx — переходит от текущей позиции курса в начало строки и обратно. На циске работает аналогично ctrl + u. (csh)
          <br>  Ctrl + x @ — показывает возможные дополнения имени хоста (имена берутся из /etc/hosts)
          <br>  Ctrl + z — suspend'ит текущую задачу (csh, zsh)
          <br>  Ctrl + x; Ctrl + e — открывает $EDITOR для изменения введённой строки. После сохранения изменений, команда отправляется на исполнение. Если переменная не задана, то открывается системный текстовый редактор (для линукса это, зачастую, nano)
          <br>
          <br>  Теперь немного о сочетаниях с альтом.
          <br>
          <br>  Alt +
          &lt; — переход к первой команде в истории команд (zsh)<br>  Alt + &gt; — переход к последней команде в истории
            <br>  Alt +? — показывает список возможных дополнений команды(аналогично tab-tab) (в csh, zsh аналог which string)
            <br>  Alt + * — вставляет все возможные дополнений команды в строку команд
            <br>  Alt + / — пытается дополнить имя файла (аналогично табуляции)
            <br>  Alt +. — вставляет последний аргумент предыдущей команды (аналог !$, только не надо делать :p, чтобы проверить )
            <br>  Alt + b — сдвигает курсор влево на 1 слово (cisco, csh, zsh)
            <br>  Alt + c — делает букву под курсором большой, а остальные, до конца слова, маленькими. (cisco, csh, zsh)
            <br>  Alt + d — удаляет символы с текущей позиции курсора и до конца слова. (cisco, csh, zsh)
            <br>  Alt + f — передвигает курсор на одно слово вперёд (cisco, csh, zsh)
            <br>  Alt + l — делает все буквы с текущей позиции курсора и до конца слова маленькими (cisco, csh, zsh)
            <br>  Alt + t — меняет местами слова под курсором и предыдущее (zsh)
            <br>  Alt + u — переводит буквы с текущей позиции курсора и до конца слова в верхний регистр (cisco, csh, zsh)
            <br>  Alt + back-space — удаляет символы с текущей позиции курсора до начала слова (cisco, csh, zsh)
            <br>
            <br>  В следующем абзаце я, для краткости, буду писать «2Т» чтобы обозначить двойное нажатие табуляции.
            <br>
            <br>  2T — дополнение команды. Если нажать при пустой строке — выведет список всех доступных команд
            <br>  (string)2T — выведет список возможных дополнений
            <br>  (dir)2T — покажет подпапки папки dir
            <br>  *2T — покажет подпапки исключая скрытые (имена которых начинаются с точки)
            <br>  ~2T — выведет всех пользователей из /etc/passwd. Дополнив имя пользователя можно перейти в его домашний каталог. Например ~oxpa/ — домашний каталог пользователя oxpa
            <br>  $2T — выводит список дополнений для системных переменных
            <br>  @2T — дополняет имена хостов содержащимися в /etc/hosts
            <br>  =2T — листинг текущей директории, аналогичный ls.
            <br>
            <br>
            <br>
            <br>
            <br>
            <br>  <h1>!Системная информация</h1>
            <br>
            <br>  arch	отобразить архитектуру компьютера
            <br>
            <br>  uname -m
            <br>
            <br>  uname -r	отобразить используемую версию ядра
            <br>
            <br>  dmidecode -q	показать аппаратные системные компоненты — (SMBIOS / DMI)
            <br>
            <br>  hdparm -i /dev/hda	вывести характеристики жесткого диска
            <br>
            <br>  hdparm -tT /dev/sda	протестировать производительность чтения данных с жесткого диска
            <br>
            <br>  cat /proc/cpuinfo	отобразить информацию о процессоре
            <br>
            <br>  cat /proc/interrupts	показать прерывания
            <br>
            <br>  cat /proc/meminfo	проверить использование памяти
            <br>
            <br>  cat /proc/swaps	показать файл(ы) подкачки
            <br>
            <br>  cat /proc/version	вывести версию ядра
            <br>
            <br>  cat /proc/net/dev	показать сетевые интерфейсы и статистику по ним
            <br>
            <br>  cat /proc/mounts	отобразить смонтированные файловые системы
            <br>
            <br>  lspci -tv	показать в виде дерева PCI устройства
            <br>
            <br>  lsusb -tv	показать в виде дерева USB устройства
            <br>
            <br>  date	вывести системную дату
            <br>
            <br>  cal 2010	вывести таблицу-календарь 2010-го года
            <br>
            <br>  date 040817002010.00	установить системные дату и время ММДДЧЧммГГГГ.СС (МесяцДеньЧасМинутыГод.Секунды)
            <br>
            <br>  clock -w	сохранить системное время в BIOS
            <br>
            <br>
            <br>  <h1>!Остановка системы</h1>
            <br>
            <br>  shutdown -h now	Остановить систему
            <br>
            <br>  init 0
            <br>
            <br>  telinit 0
            <br>
            <br>  shutdown -h hours:minutes &amp;	запланировать остановку системы на указанное время
            <br>
            <br>  shutdown -c	отменить запланированную по расписанию остановку системы
            <br>
            <br>  shutdown -r now	перегрузить систему
            <br>
            <br>  shutdown -k now  Не выключает но посылает сообщение всем пользователям.
            <br>
            <br>  reboot
            <br>
            <br>  logout	выйти из системы
            <br>
            <br>
            <br>
            <br>  <h1>!Файлы и директории</h1>
            <br>
            <br>  cd /home	перейти в директорию '/home'
            <br>
            <br>  cd ..	перейти в директорию уровнем выше
            <br>
            <br>  cd ../..	перейти в директорию двумя уровнями выше
            <br>
            <br>  cd	перейти в домашнюю директорию
            <br>
            <br>  cd ~user	перейти в домашнюю директорию пользователя user
            <br>
            <br>  cd -	перейти в директорию, в которой находились до перехода в текущую директорию
            <br>
            <br>  pwd	показать текущюю директорию
            <br>
            <br>  ls	отобразить содержимое текущей директории
            <br>
            <br>  ls -F	отобразить содержимое текущей директории с добавлением к именам символов, храктеризующих тип
            <br>
            <br>  ls -l	показать детализированое представление файлов и директорий в текущей директории
            <br>
            <br>  ls -a	показать скрытые файлы и директории в текущей директории
            <br>
            <br>  ls *[0-9]*	показать файлы и директории содержащие в имени цифры
            <br>
            <br>  tree	показать дерево файлов и директорий, начиная от корня (/)
            <br>
            <br>  lstree
            <br>
            <br>  mkdir dir1	создать директорию с именем 'dir1'
            <br>
            <br>  mkdir dir1 dir2	создать две директории одновременно
            <br>
            <br>  mkdir -p /tmp/dir1/dir2	создать дерево директорий
            <br>
            <br>  rm -f file1	удалить файл с именем 'file1'
            <br>
            <br>  rmdir dir1	удалить директорию с именем 'dir1'
            <br>
            <br>  rm -rf dir1	удалить директорию с именем 'dir1' и рекурсивно всё её содержимое
            <br>
            <br>  rm -rf dir1 dir2	удалить две директории и рекурсивно их содержимое
            <br>
            <br>  mv dir1 new_dir	переименовать или переместить файл или директорию
            <br>
            <br>  cp file1 file2	сопировать файл file1 в файл file2
            <br>
            <br>  cp dir/* .	копировать все файлы директории dir в текущую директорию
            <br>
            <br>  cp -a /tmp/dir1 .	копировать директорию dir1 со всем содержимым в текущую директорию
            <br>
            <br>  cp -a dir1 dir2	копировать директорию dir1 в директорию dir2
            <br>
            <br>  ln -s file1 lnk1	создать символическую ссылку на файл или директорию
            <br>
            <br>  ln file1 lnk1	создать "жёсткую" (физическую) ссылку на файл или директорию
            <br>
            <br>  touch -t 0712250000 fileditest	модифицировать дату и время создания файла, при его отсутствии, создать файл с указанными датой и временем (YYMMDDhhmm)
            <br>
            <br>
            <br>
            <br>  <h1>!Поиск файлов</h1>
            <br>
            <br>  find / -name file1	найти файлы и директории с именем file1. Поиск начать с корня (/)
            <br>
            <br>  find / -user user1	найти файл и директорию принадлежащие пользователю user1. Поиск начать с корня (/)
            <br>
            <br>  find /home/user1 -name "*.bin"	Найти все файлы и директории, имена которых оканчиваются на '. bin'. Поиск начать с '/ home/user1'
            <br>
            <br>  find /usr/bin -type f -atime +100	найти все файлы в '/usr/bin', время последнего обращения к которым более 100 дней
            <br>
            <br>  find /usr/bin -type f -mtime -10	найти все файлы в '/usr/bin', созданные или изменённые в течении последних 10 дней
            <br>
            <br>  find / -name *.rpm -exec chmod 755 '{}' \;	найти все фалы и директории, имена которых оканчиваются на '.rpm', и изменить права доступа к ним
            <br>
            <br>  find / -xdev -name "*.rpm"	найти все фалы и директории, имена которых оканчиваются на '.rpm', игнорируя съёмные носители, такие как cdrom, floppy и т.п.
            <br>
            <br>  locate "*.ps"	найти все файлы, сожержащие в имени '.ps'. Предварительно рекомендуется выполнить команду 'updatedb'
            <br>
            <br>  whereis halt	показывает размещение бинарных файлов, исходных кодов и руководств, относящихся к файлу 'halt'
            <br>
            <br>  which halt	отображает полный путь к файлу 'halt'
            <br>
            <br>
            <br>
            <br>  <h1>!Монтирование файловых систем</h1>
            <br>
            <br>  mount /dev/hda2 /mnt/hda2	монтирует раздел 'hda2' в точку монтирования '/mnt/hda2'. Убедитесь в наличии директории-точки монтирования '/mnt/hda2'
            <br>
            <br>  umount /dev/hda2	размонтирует раздел 'hda2'. Перед выполнением, покиньте '/mnt/hda2'
            <br>
            <br>  fuser -km /mnt/hda2	принудительное размонтирование раздела. Применяется в случае, когда раздел занят каким-либо пользователем
            <br>
            <br>  umount -n /mnt/hda2	выполнить размонитрование без занесения информации в /etc/mtab. Полезно когда файл имеет атрибуты "только чтение" или недостаточно места на диске
            <br>
            <br>  mount /dev/fd0 /mnt/floppy	монтировать флоппи-диск
            <br>
            <br>  mount /dev/cdrom /mnt/cdrom	монтировать CD или DVD
            <br>
            <br>  mount /dev/hdc /mnt/cdrecorder	монтировать CD-R/CD-RW или DVD-R/DVD-RW(+-)
            <br>
            <br>  mount -o loop file.iso /mnt/cdrom	смонтировать ISO-образ
            <br>
            <br>  mount -t vfat /dev/hda5 /mnt/hda5	монтировать файловую систему Windows FAT32
            <br>
            <br>  mount -t smbfs -o username=user,password=pass //winclient/share /mnt/share	монтировать сетевую файловую систему Windows (SMB/CIFS)
            <br>
            <br>  mount -o bind /home/user/prg /var/ftp/user	"монтирует" директорию в директорию (binding). Доступна с версии ядра 2.4.0. Полезна, например, для предоставления содержимого пользовательской директории через ftp при работе ftp-сервера в "песочнице" (chroot), когда симлинки сделать невозможно.
            <br>
            <br>
            <br>
            <br>  <h1>Дисковое пространство</h1>
            <br>
            <br>  df -h	отображает информацию о смонтированных разделах с отображением общего, доступного и используемого пространства (Прим.переводчика. ключ -h работает не во всех *nix системах)
            <br>
            <br>  ls -lSr |more	выдаёт список файлов и директорий рекурсивно с сортировкой по возрастанию размера и позволяет осуществлять постраничный просмотр
            <br>
            <br>  du -sh dir1	подсчитывает и выводит размер, занимаемый директорией 'dir1' (ключ -h работает не во всех *nix системах)
            <br>
            <br>  du -sk * | sort -rn	отображает размер и имена файлов и директорий, с соритровкой по размеру
            <br>
            <br>  rpm -q -a --qf '%10{SIZE}t%{NAME}n' | sort -k1,1n	показывает размер используемого дискового пространства, занимаемое файлами rpm-пакета, с сортировкой по размеру (fedora, redhat и т.п.)
            <br>
            <br>  dpkg-query -W -f='${Installed-Size;10}t${Package}n' | sort -k1,1n	показывает размер используемого дискового пространства, занимаемое файлами deb-пакета, с сортировкой по размеру (ubuntu, debian т.п.)
            <br>
            <br>
            <br>  <h1>!Пользователи и группы</h1>
            <br>
            <br>  groupadd group_name	создать новую группу с именем group_name
            <br>
            <br>  groupdel group_name	удалить группу group_name
            <br>
            <br>  groupmod -n new_group_name old_group_name	переименовать группу old_group_name в new_group_name
            <br>
            <br>  useradd -c "Nome Cognome" -g admin -d /home/user1 -s /bin/bash user1	создать пользователя user1, назначить ему в качестве домашнего каталога /home/user1, в качестве shell'а /bin/bash, включить его в группу admin и добавить комментарий Nome Cognome
            <br>
            <br>  useradd user1	создать пользователя user1
            <br>
            <br>  userdel -r user1	удалить пользователя user1 и его домашний каталог
            <br>
            <br>  usermod -c "User FTP" -g system -d /ftp/user1 -s /bin/nologin user1	изменить атрибуты пользователя
            <br>
            <br>  passwd	сменить пароль
            <br>
            <br>  passwd user1	сменить пароль пользователя user1 (только root)
            <br>
            <br>  chage -E 2005-12-31 user1	установить дату окончания действия учётной записи пользователя user1
            <br>
            <br>  pwck	проверить корректность системных файлов учётных записей. Проверяются файлы /etc/passwd и /etc/shadow
            <br>
            <br>  grpck	проверяет корректность системных файлов учётных записей. Проверяется файл/etc/group
            <br>
            <br>  newgrp [-] group_name	изменяет первичную группу текущего пользователя. Если указать "-", ситуация будет идентичной той, в которой пользователь вышил из системы и снова вошёл. Если не указывать группу, первичная группа будет назначена из /etc/passwd
            <br>
            <br>
            <br>
            <br>  <h1>!Выставление/изменение полномочий на файлы</h1>
            <br>
            <br>  ls -lh	просмотр полномочий на файлы и директории в текущей директории
            <br>
            <br>  ls /tmp | pr -T5 -W$COLUMNS	вывести содержимое директории /tmp и разделить вывод на пять колонок
            <br>
            <br>  chmod ugo+rwx directory1	добавить полномочия на директорию directory1 ugo(User Group Other)+rwx(Read Write eXecute) — всем полные права. Аналогичное можно сделать таким образом "chmod 777 directory1"
            <br>
            <br>  chmod go-rwx directory1	отобрать у группы и всех остальных все полномочия на директорию directory1.
            <br>
            <br>  chown user1 file1	назначить владельцем файла file1 пользователя user1
            <br>
            <br>  chown -R user1 directory1	назначить рекурсивно владельцем директории directory1 пользователя user1
            <br>
            <br>  chgrp group1 file1	сменить группу-владельца файла file1 на group1
            <br>
            <br>  chown user1:group1 file1	сменить владельца и группу владельца файла file1
            <br>
            <br>  find / -perm -u+s	найти, начиная от корня, все файлы с выставленным SUID
            <br>
            <br>  chmod u+s /bin/binary_file	назначить SUID-бит файлу /bin/binary_file. Это даёт возможность любому пользователю запускать на выполнение файл с полномочиями владельца файла.
            <br>
            <br>  chmod u-s /bin/binary_file	снять SUID-бит с файла /bin/binary_file.
            <br>
            <br>  chmod g+s /home/public	назначить SGID-бит директории /home/public.
            <br>
            <br>  chmod g-s /home/public	снять SGID-бит с директории /home/public.
            <br>
            <br>  chmod o+t /home/public	назначить STIKY-бит директории /home/public. Позволяет удалять файлы только владельцам
            <br>
            <br>  chmod o-t /home/public	снять STIKY-бит с директории /home/public
            <br>
            <br>  Специальные атрибуты файлов
            <br>
            <br>  chattr +a file1	позволить открывать файл на запись только в режиме добавления
            <br>
            <br>  chattr +c file1	позволяет ядру автоматически сжимать/разжимать содержимое файла.
            <br>
            <br>  chattr +d file1	указавет утилите dump игнорировать данный файл во время выполнения backup'а
            <br>
            <br>  chattr +i file1	делает файл недоступным для любых изменений: редактирование, удаление, перемещение, создание линков на него.
            <br>
            <br>  chattr +s file1	позволяет сделать удаление файла безопасным, т.е. выставленный атрибут s говорит о том, что при удалении файла, место, занимаемое файлом на диске заполняется нулями, что предотвращяет возможность восстановления данных.
            <br>
            <br>  chattr +S file1	указывает, что, при сохранении изменений, будет произведена синхронизация, как при выполнении команды sync
            <br>
            <br>  chattr +u file1	данный атрибут указывает, что при удалении файла содержимое его будет сохранено и при необходимости пользователь сможет его восстановить
            <br>
            <br>  lsattr	показать атрибуты файлов
            <br>
            <br>
            <br>
            <br>  <h1>!Архивирование и сжатие файлов</h1>
            <br>
            <br>  bunzip2 file1.bz2	разжимает файл 'file1.gz'
            <br>
            <br>  gunzip file1.gz
            <br>
            <br>  gzip file1	сжимает файл 'file1'
            <br>
            <br>  bzip2 file1
            <br>
            <br>  gzip -9 file1	сжать файл file1 с максимальным сжатием
            <br>
            <br>  rar a file1.rar test_file	создать rar-архив 'file1.rar' и включить в него файл test_file
            <br>
            <br>  rar a file1.rar file1 file2 dir1	создать rar-архив 'file1.rar' и включить в него file1, file2 и dir1
            <br>
            <br>  unrar x file1.rar	распаковать rar-архив
            <br>
            <br>  tar -cvf archive.tar file1	создать tar-архив archive.tar, содержащий файл file1
            <br>
            <br>  tar -cvf archive.tar file1 file2 dir1	создать tar-архив archive.tar, содержащий файл file1, file2 и dir1
            <br>
            <br>  tar -tf archive.tar	показать содержимое архива
            <br>
            <br>  tar -xvf archive.tar	распаковать архив
            <br>
            <br>  tar -xvf archive.tar -C /tmp	распаковать архив в /tmp
            <br>
            <br>  tar -cvfj archive.tar.bz2 dir1	создать архив и сжать его с помощью bzip2(Прим.переводчика. ключ -j работает не во всех *nix системах)
            <br>
            <br>  tar -xvfj archive.tar.bz2	разжать архив и распаковать его(Прим.переводчика. ключ -j работает не во всех *nix системах)
            <br>
            <br>  tar -cvfz archive.tar.gz dir1	создать архив и сжать его с помощью gzip
            <br>
            <br>  tar -xvfz archive.tar.gz	разжать архив и распаковать его
            <br>
            <br>  zip file1.zip file1	создать сжатый zip-архив
            <br>
            <br>  zip -r file1.zip file1 file2 dir1	создать сжатый zip-архив и со включением в него нескольких файлов и/или директорий
            <br>
            <br>  unzip file1.zip	разжать и распаковать zip-архив
            <br>
            <br>
            <br>
            <br>  <h1>!RPM пакеты (Fedora, Red Hat и тому подобное)</h1>
            <br>
            <br>  rpm -ivh package.rpm	установить пакет с выводом сообщений и прогресс-бара
            <br>
            <br>  rpm -ivh --nodeps package.rpm	установить пакет с выводом сообщений и прогресс-бара без контроля зависимостей
            <br>
            <br>  rpm -U package.rpm	обновить пакет без изменений конфигурационных файлов, в случае отсутствия пакета, он будет установлен
            <br>
            <br>  rpm -F package.rpm	обновить пакет только если он установлен
            <br>
            <br>  rpm -e package_name.rpm	удалить пакет
            <br>
            <br>  rpm -qa	отобразить список всех пакетов, установленных в системе
            <br>
            <br>  rpm -qa | grep httpd	среди всех пакетов, установленных в системе, найти пакет содержащий в своём имени "httpd"
            <br>
            <br>  rpm -qi package_name	вывести информацию о конкрентном пакете
            <br>
            <br>  rpm -qg "System Environment/Daemons"	отобразить пакеты входящие в группу пакетов
            <br>
            <br>  rpm -ql package_name	вывести список файлов, входящих в пакет
            <br>
            <br>  rpm -qc package_name	вывести список конфигурационных файлов, входящих в пакет
            <br>
            <br>  rpm -q package_name --whatrequires	вывести список пакетов, необходимых для установки конкретного пакета по зависимостям
            <br>
            <br>  rpm -q package_name --whatprovides	show capability provided by a rpm package
            <br>
            <br>  rpm -q package_name --scripts	отобразит скрипты, запускаемые при установке/удалении пакета
            <br>
            <br>  rpm -q package_name --changelog	вывести историю ревизий пакета
            <br>
            <br>  rpm -qf /etc/httpd/conf/httpd.conf	проверить какому пакету принадлежит указанный файл. Указывать следует полный путь и имя файла.
            <br>
            <br>  rpm -qp package.rpm -l	отображает список файлов, входящих в пакет, но ещё не установленных в систему
            <br>
            <br>  rpm --import /media/cdrom/RPM-GPG-KEY	ипортировать публичный ключ цифровой подписи
            <br>
            <br>  rpm --checksig package.rpm	проверит подпись пакета
            <br>
            <br>  rpm -qa gpg-pubkey	проверить целостность установленного содержимого пакета
            <br>
            <br>  rpm -V package_name	проверить размер, полномочия, тип, владельца, группу, MD5-сумму и дату последнего изменеия пакета
            <br>
            <br>  rpm -Va	проверить содержимое всех пакеты установленные в систему. Выполняйте с осторожностью!
            <br>
            <br>  rpm -Vp package.rpm	проверить пакет, который ещё не установлен в систему
            <br>
            <br>  rpm2cpio package.rpm | cpio --extract --make-directories *bin*	извлечь из пакета файлы содержащие в своём имени bin
            <br>
            <br>  rpm -ivh /usr/src/redhat/RPMS/`arch`/package.rpm	установить пакет, собранный из исходных кодов
            <br>
            <br>  rpmbuild --rebuild package_name.src.rpm	собрать пакет из исходных кодов
            <br>
            <br>  YUM — средство обновления пакетов(Fedora, RedHat и тому подобное)
            <br>
            <br>  yum install package_name	закачать и установать пакет
            <br>
            <br>  yum update	обновить все пакеты, установленные в систему
            <br>
            <br>  yum update package_name	обновить пакет
            <br>
            <br>  yum remove package_name	удалить пакет
            <br>
            <br>  yum list	вывести список всех пакетов, установленных в систему
            <br>
            <br>  yum search package_name	найти пакет в репозитории
            <br>
            <br>  yum clean packages	очисть rpm-кэш, удалив закачанные пакеты
            <br>
            <br>  yum clean headers	удалить все заголовки файлов, которые система использует для разрешения зависимостей
            <br>
            <br>  yum clean all	очисть rpm-кэш, удалив закачанные пакеты и заголовки
            <br>
            <br>
            <br>
            <br>  <h1>!DEB пакеты (Debian, Ubuntu и тому подобное)</h1>
            <br>
            <br>  dpkg -i package.deb	установить / обновить пакет
            <br>
            <br>  dpkg -r package_name	удалить пакет из системы
            <br>
            <br>  dpkg -l	показать все пакеты, установленные в систему
            <br>
            <br>  dpkg -l | grep httpd	среди всех пакетов, установленных в системе, найти пакет содержащий в своём имени "httpd"
            <br>
            <br>  dpkg -s package_name	отобразить инфрмацию о конкретном пакете
            <br>
            <br>  dpkg -L package_name	вывести список файлов, входящих в пакет, установленный в систему
            <br>
            <br>  dpkg --contents package.deb	отобразить список файлов, входящих в пакет, который ешё не установлен в систему
            <br>
            <br>  dpkg -S /bin/ping	найти пакет, в который входит указанный файл.
            <br>
            <br>  APT — средство управление пакетами (Debian, Ubuntu и тому подобное)
            <br>
            <br>  apt-get install package_name	установить / обновить пакет
            <br>
            <br>  apt-cdrom install package_name	установить / обновить пакет с cdrom'а
            <br>
            <br>  apt-get update	получить обновлённые списки пакетов
            <br>
            <br>  apt-get upgrade	обновить пакеты, установленные в систему
            <br>
            <br>  apt-get remove package_name	удалить пакет, установленный в систему с сохранением файлов конфигурации
            <br>
            <br>  apt-get purge package_name	удалить пакет, установленный в систему с удалением файлов конфигурации
            <br>
            <br>  apt-get check	проверить целостность зависимостей
            <br>
            <br>  apt-get clean	удалить загруженные архивные файлы пакетов
            <br>
            <br>  apt-get autoclean	удалить старые загруженные архивные файлы пакетов
            <br>










            <br>
            <br>
            <br>  <h1>!Просмотр содержимого файлов</h1>
            <br>
            <br>  cat file1	вывести содержимое файла file1 на стандартное устройсво вывода
            <br>
            <br>  tac file1	вывести содержимое файла file1 на стандартное устройсво вывода в обратном порядке (последняя строка становиться первой и т.д.)
            <br>
            <br>  more file1	постраничный вывод содержимого файла file1 на стандартное устройство вывода
            <br>
            <br>  less file1	постраничный вывод содержимого файла file1 на стандартное устройство вывода, но с возможностью пролистывания в обе стороны (вверх-вниз), поиска по содержимому и т.п.
            <br>
            <br>  head -2 file1	вывести первые две строки файла file1 на стандартное устройство вывода. По-умолчанию выводится десять строк
            <br>
            <br>  tail -2 file1	вывести последние две строки файла file1 на стандартное устройство вывода. По-умолчанию выводится десять строк
            <br>
            <br>  tail -f /var/log/messages	выводить содержимое файла /var/log/messages на стандартное устройство вывода по мере появления в нём текста.
            <br>
            <br>
            <br>
            <br>  <h1>!Манипуляции с текстом</h1>
            <br>
            <br>  cat file | grep -i "Criteria" &gt; result.txt	общий синтаксис выполнения действий по обработке содержимого файла и вывода результата в новый
            <br>
            <br>  cat file | grep -i "Criteria" » result.txt	общий синтаксис выполнения действий по обработке содержимого файла и вывода результата в существующий файл. Если файл не существует, он будет создан
            <br>
            <br>  grep Aug /var/log/messages	из файла '/var/log/messages' отобрать и вывести на стандартное устройство вывода строки, содержащие "Aug"
            <br>
            <br>  grep ^Aug /var/log/messages	из файла '/var/log/messages' отобрать и вывести на стандартное устройство вывода строки, начинающиеся на "Aug"
            <br>
            <br>  grep [0-9] /var/log/messages	из файла '/var/log/messages' отобрать и вывести на стандартное устройство вывода строки, содержащие цифры
            <br>
            <br>  grep Aug -R /var/log/*	отобрать и вывести на стандартное устройство вывода строки, содержащие "Aug", во всех файлах, находящихся в директории /var/log и ниже
            <br>
            <br>
            <br>  !Команда  SED копирует файлы (по умолчанию со стандартного входа) на стандартный выход, редактирует их в соответствии со своими(!) командами,
            <br>
            <br>  sed 's/stringa1/stringa2/g' example.txt	в файле example.txt заменить "string1" на "string2", результат вывести на стандартное устройство вывода.
            <br>
            <br>  sed '/^$/d' example.txt	удалить пустые строки из файла example.txt
            <br>
            <br>  sed '/ *#/d; /^$/d' example.txt	удалить пустые строки и все строки где есть символ  «#» из файла example.txt
            <br>
            <br>  echo 'test' | tr '[:lower:]' '[:upper:]'	преобразовать символы из нижнего регистра в верхний
            <br>
            <br>  sed -e '1d' result.txt	удалить первую строку из файла example.txt
            <br>       The -e option specifies that the next argument (cmd) is a sed command (or a series of
            <br>   commands). When specifying only one string of commands, the -e is optional
            <br>
            <br>
            <br>  sed -n '/string1/p'	отобразить только строки содержашие "string1"
            <br>
            <br>  sed -e 's/ *$//' example.txt	удалить пустые символы в в конце каждой строки
            <br>
            <br>  sed -e 's/string1//g' example.txt	удалить строку "string1" из текста не изменяя всего остального
            <br>
            <br>  sed -n '1,8p;5q' example.txt	взять из файла с первой по восьмую строки и из них вывести первые пять
            <br>
            <br>  sed -n '5p;5q' example.txt	вывести пятую строку
            <br>
            <br>  sed -e 's/0*/0/g' example.txt	заменить последовательность из любого количества нулей одним нулём
            <br>  # удалить пробелы и табуляции как в начале так и в конце строки
<br>sed 's/^[ \t]*//;s/[ \t]*$//'
<br>
<br># вставить 5 пробелов в начале каждой строки (смещение страницы)
<br>sed 's/^/     /'
<br>
<br># выравнивание всего текста по правому краю на ширину колонки 79
<br>sed -e :a -e 's/^.\{1,78\}$/ &amp;/;ta'  # задаем 78 плюс 1 пробел
<br>
<br># выровнять весь текст по центру, два метода
<br><br>sed  -e :a -e 's/^.\{1,77\}$/ &amp; /;ta'                     # method 1
<br>sed  -e :a -e 's/^.\{1,77\}$/ &amp;/;ta' -e 's/\( *\)\1/\1/'  # method 2
<br>
<br># замена в каждой строке "foo" на "bar"
<br>sed 's/foo/bar/'   # заменяет только первое
<br>                       # найденное значение в строке
<br>sed 's/foo/bar/4'  # заменяет только 4 первых значений в строке
<br>sed 's/foo/bar/g'  # заменяет все значения в строке
<br>sed 's/\(.*\)foo\(.*foo\)/\1bar\2/' # заменяет следующий
 <br>                                             # за встреченным
<br>sed 's/\(.*\)foo/\1bar/'  # заменяет только последнее "foo"
 <br>
<br># заменить "foo" на "bar" ТОЛЬКО для строк, в которых есть "baz"
<br>sed '/baz/s/foo/bar/g'
<br>
<br># заменить "foo" на "bar" КРОМЕ тех строк, в которых есть "baz"
<br>sed '/baz/!s/foo/bar/g'
<br>
<br># заменить "scarlet" или "ruby" или "puce" на "red"
<br>sed 's/scarlet/red/g;s/ruby/red/g;s/puce/red/g'   # все seds
<br>gsed 's/scarlet\|ruby\|puce/red/g'                # GNU sed
<br>
<br># расстановка строк в обратном порядке (эмуляция "tac")
<br># bug/feature в HHsed v1.5 удаляет еще и все пустые строки
<br>sed '1!G;h;$!d'      # метод 1
<br>sed -n '1!G;h;$p'   # метод 2
<br>
<br># reverse each character on the line (emulates "rev")
<br>sed '/\n/!G;s/\(.\)\(.*\n\)/&amp;\2\1/;//D;s/.//'
<br>
<br># соединяет пары строк друг с другом (как "paste")
<br>sed '$!N;s/\n/ /'
<br>
<br># если строка заканчивается на backslash (\), присоединить следующую
<br># строку к ней<br>
<br>sed -e :a -e '/\\$/N; s/\\\n//; ta'
<br>
#<br> если строка начинается со знака равенства, добавить ее
<br># к предыдущей строке и заменить "=" на один пробел
<br>sed -e :a -e '$!N;s/\n=/ /;ta' -e 'P;D'
<br>
<br># разделять числа запятыми, заменяет "1234567" на "1,234,567"
<br>gsed ':a;s/\B[0-9]\{3\}\&gt;/,&amp;/;ta'                     # GNU sed
<br>sed -e :a -e 's/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/;ta'  # все seds
<br>
<br># добавить запятые для чисел с десятичной точкой и знаком минуса
<br>gsed -r ':a;s/(^|[^0-9.])([0-9]+)([0-9]{3})/\1\2,\3/g;ta'<br>
 <br>
<br># добавить строку кадые 5 строк (после строк 5, 10, 15, 20, и тд.)
<br>gsed '0~5G'                  # GNU sed
<br>sed 'n;n;n;n;G;'             # все seds
<br>            <br>  cat -n file1	пронумеровать строки при выводе содержимого файла
            <br>
            <br>  cat example.txt | awk 'NR%2==1'	при выводе содержимого файла, не выводить чётные строки файла
            <br>
            <br>  echo a b c | awk '{print $1}'	вывести первую колонку. Разделение, по-умолчанию, по проблелу/пробелам или символу/символам табуляции
            <br>
            <br>  echo a b c | awk '{print $1,$3}'	вывести первую и треью колонки. Разделение, по-умолчанию, по проблелу/пробелам или символу/символам табуляции
            <br>
            <br>  paste file1 file2	объединить содержимое file1 и file2 в виде таблицы: строка 1 из file1 = строка 1 колонка 1-n, строка 1 из file2 = строка 1 колонка n+1-m
            <br>
            <br>  paste -d '+' file1 file2	объединить содержимое file1 и file2 в виде таблицы с разделителем "+"
            <br>
            <br>  sort file1 file2	отсортировать содержимое двух файлов
            <br>
            <br>  sort file1 file2 | uniq	отсортировать содержимое двух файлов, не отображая повторов
            <br>
            <br>  sort file1 file2 | uniq -u	отсортировать содержимое двух файлов, отображая только уникальные строки (строки, встречающиеся в обоих файлах, не выводятся на стандартное устройство вывода)
            <br>
            <br>  sort file1 file2 | uniq -d	отсортировать содержимое двух файлов, отображая только повторяющиеся строки
            <br>
            <br>  comm -1 file1 file2	сравнить содержимое двух файлов, не отображая строки принадлежащие файлу 'file1'
            <br>
            <br>  comm -2 file1 file2	сравнить содержимое двух файлов, не отображая строки принадлежащие файлу 'file2'
            <br>
            <br>  comm -3 file1 file2	сравнить содержимое двух файлов, удаляя строки встречающиеся в обоих файлах
            <br>
            <br>
            <br>
            <br>  <h1>!Преобразование наборов символов и файловых форматов</h1>
            <br>
            <br>  dos2unix filedos.txt fileunix.txt	конвертировать файл текстового формата из MSDOS в UNIX (разница в символах возврата коретки)
            <br>
            <br>  unix2dos fileunix.txt filedos.txt	конвертировать файл текстового формата из UNIX в MSDOS (разница в символах возврата коретки)
            <br>
            <br>  recode ..HTML
            &lt; page.txt &gt; page.html	конвертировать содержимое тестового файла page.txt в html-файл page.html
              <br>
              <br>  recode -l | more	вывести список доступных форматов
              <br>
              <br>
              <br>
              <br>  <h1>!Анализ файловых систем, проверить на ошибки диск</h1>
              <br>  <a name="fsck"></a>!fsck
              <br>  <a href="#top">Назад</a>
              <br>  badblocks -v /dev/hda1	проверить раздел hda1 на наличие bad-блоков
              <br>
              <br>  fsck /dev/hda1	проверить/восстановить целостность linux-файловой системы раздела hda1
              <br>
              <br>  fsck.ext2 /dev/hda1	проверить/восстановить целостность файловой системы ext2 раздела hda1
              <br>
              <br>  e2fsck /dev/hda1
              <br>
              <br>  e2fsck -j /dev/hda1	проверить/восстановить целостность файловой системы ext3 раздела hda1 с указанием, что журнал расположен там же
              <br>
              <br>  fsck.ext3 /dev/hda1	проверить/восстановить целостность файловой системы ext3 раздела hda1
              <br>
              <br>  fsck.vfat /dev/hda1	проверить/восстановить целостность файловой системы fat раздела hda1
              <br>
              <br>  fsck.msdos /dev/hda1
              <br>
              <br>  dosfsck /dev/hda1
              <br>  При попытке проверить диск ntfs ошибка:  Не удалось найти пакет fsck.ntfs
              <br>  Причина fsck.ntfs is usually only a link to ntfsfix which is an utility from the package ntfsprogs that is already available with a standard installation of Ubuntu.
					<br>
					<br>You can make a simbolic link between fsck.ntfs and ntfsfix to solve this permanently:
					<br>
					<br>sudo ln -s /usr/bin/ntfsfix /sbin/fsck.ntfs
					<br>sudo ln -s /usr/bin/ntfsfix /sbin/fsck.ntfs-3g
              <br>
              <br>
              <br>  <h1>!Форматирование файловых систем</h1>
              <br>
              <br>  mkfs /dev/hda1	создать linux-файловую систему на разделе hda1
              <br>
              <br>  mke2fs /dev/hda1	создать файловую систему ext2 на разделе hda1
              <br>
              <br>  mke2fs -j /dev/hda1	создать журналирующую файловую систему ext3 на разделе hda1
              <br>
              <br>  mkfs -t vfat 32 -F /dev/hda1	создать файловую систему FAT32 на разделе hda1
              <br>
              <br>  fdformat -n /dev/fd0	форматирование флоппи-диска без проверки
              <br>

              <br>  mkswap /dev/hda3	создание swap-пространства на разделе hda3
              <br>
              <br>  swap-пространство
              <br>
              <br>  mkswap /dev/hda3	создание swap-пространства на разделе hda3
              <br>
              <br>  swapon /dev/hda3	активировать swap-пространство, расположенное на разделе hda3
              <br>
              <br>  swapon /dev/hda2 /dev/hdb3	активировать swap-пространства, расположенные на разделах hda2 и hdb3
              <br>
              <br>
              <br>
              <br>  <h1>!Создание резервных копий (backup)</h1>
              <br>
              <br>  dump -0aj -f /tmp/home0.bak /home	создать полную резервную копию директории /home в файл /tmp/home0.bak
              <br>
              <br>  dump -1aj -f /tmp/home0.bak /home	создать инкрементальную резервную копию директории /home в файл /tmp/home0.bak
              <br>
              <br>  restore -if /tmp/home0.bak	восстановить из резервной копии /tmp/home0.bak
              <br>
              <br>  rsync -rogpav --delete /home /tmp	синхронизировать /tmp с /home
              <br>
              <br>  rsync -rogpav -e ssh --delete /home ip_address:/tmp	синхронизировать через SSH-туннель
              <br>
              <br>  rsync -az -e ssh --delete ip_addr:/home/public /home/local	синхронизировать локальную директорию с удалённой директорией через ssh-туннель со сжатием
              <br>
              <br>  rsync -az -e ssh --delete /home/local ip_addr:/home/public	синхронизировать удалённую директорию с локальной директорией через ssh-туннель со сжатием
              <br>
              <br>  dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr 'dd of=hda.gz'	сделать "слепок" локального диска в файл на удалённом компьютере через ssh-туннель
              <br>
              <br>  tar -Puf backup.tar /home/user	создать инкрементальную резервную копию директории '/home/user' в файл backup.tar с сохранением полномочий
              <br>
              <br>  ( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr 'cd /home/share/ &amp;&amp; tar x -p'	копирование содержимого /tmp/local на удалённый компьютер через ssh-туннель в /home/share/
              <br>
              <br>  ( tar c /home ) | ssh -C user@ip_addr 'cd /home/backup-home &amp;&amp; tar x -p'	копирование содержимого /home на удалённый компьютер через ssh-туннель в /home/backup-home
              <br>
              <br>  tar cf - . | (cd /tmp/backup ; tar xf - )	копирование одной директории в другую с сохранением полномочий и линков
              <br>
              <br>  find /home/user1 -name '*.txt' | \
              <br>
              <br>
              <br>
              <br>  xargs cp -av --target-directory=/home/backup/ --parents	поиск в /home/user1 всех файлов, имена которых оканчиваются на '.txt', и копирование их в другую директорию
              <br>
              <br>  find /var/log -name '*.log' | tar cv --files-from=- | bzip2 &gt; log.tar.bz2	поиск в /var/log всех файлов, имена которых оканчиваются на '.log', и создание bzip-архива из них
              <br>
              <br>  dd if=/dev/hda of=/dev/fd0 bs=512 count=1	создать копию MBR (Master Boot Record) с /dev/hda на флоппи-диск
              <br>
              <br>  dd if=/dev/fd0 of=/dev/hda bs=512 count=1	восстановить MBR с флоппи-диска на /dev/hda
              <br>
              <br>
              <br>
              <br>  <h1>!CDROM</h1>
              <br>
              <br>  cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force	очистить перезаписываемый диск
              <br>
              <br>  mkisofs /dev/cdrom &gt; cd.iso	создать ISO-образ с CD на жесткий диск
              <br>
              <br>  mkisofs /dev/cdrom | gzip &gt; cd_iso.gz	создать сжатый ISO-образ с CD на жесткий диск
              <br>
              <br>  mkisofs -J -allow-leading-dots -R -V "Label CD" -iso-level 4 -o ./cd.iso data_cd	создать ISO-образ директории
              <br>
              <br>  cdrecord -v dev=/dev/cdrom cd.iso	записать ISO-образ
              <br>
              <br>  gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom -	записать сжатый ISO-образ
              <br>
              <br>  mount -o loop cd.iso /mnt/iso	монтировать ISO-образ
              <br>
              <br>  cd-paranoia -B	рип аудиотреков с CD в wav-файлы
              <br>
              <br>  cd-paranoia -- "-3"	рип первых трех аудиотреков с CD в wav-файлы
              <br>
              <br>  cdrecord --scanbus	scan bus to identify the channel scsi
              <br>
              <br>
              <br>
              <br>  <h1>!Сеть (LAN и WiFi)</h1>
              <br>
              <br>  ifconfig eth0	показать конфигурацию сетевого интерфейса eth0
              <br>
              <br>  ifup eth0	активировать (поднять) интерфейс eth0
              <br>
              <br>  ifdown eth0	деактивировать (опустить) интерфейс eth0
              <br>
              <br>  ifconfig eth0 192.168.0.1 netmask 255.255.255.0	выставить интерфейсу eth0 ip-адрес и маску подсети
              <br>
              <br>  ifconfig eth0 promisc	перевести интерфейс eth0 в promiscuous-режим для "отлова" пакетов (sniffing)
              <br>
              <br>  ifconfig eth0 -promisc	отключить promiscuous-режим на интерфейсе eth0
              <br>
              <br>  dhclient eth0	активировать интерфейс eth0 в dhcp-режиме.
              <br>
              <br>  route -n	вывести локальную таблицу маршрутизации
              <br>
              <br>  netstat -rn
              <br>
              <br>  route add -net 0/0 gw IP_Gateway	задать ip-адрес шлюза по умолчанию (default gateway)

              <br>
              <br>  route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.0.1	добавить статический маршрут в сеть 192.168.0.0/16 через шлюз с ip-адресом 192.168.0.1


              <br>
              <br>  route del 0/0 gw IP_gateway	удалить ip-адрес шлюза по умолчанию (default gateway)
              <br>
              <br>  echo "1" &gt; /proc/sys/net/ipv4/ip_forward	разрешить пересылку пакетов (forwarding)
              <br>
              <br>  hostname	отобразить имя компьютера
              <br>
              <br>  host www.yandex.ru	разрешить имя www.yandex.ru хоста в ip-адрес и наоборот
              <br>
              <br>  host 93.158.134.3
              <br>
              <br>  ip link show	отобразить состояние всех интерфейсов
              <br>
              <br>  mii-tool eth0	отобразить статус и тип соединения для интерфейса eth0
              <br>
              <br>  ethtool eth0	отображает статистику интерфеса eth0 с выводом такой информации, как поддерживаемые и текущие режимы соединения
              <br>
              <br>  netstat -tupn	отображает все установленные сетевые соединения по протоколам TCP и UDP без разрешения имён в ip-адреса и PID'ы и имена процессов, обеспечивающих эти соединения
              <br>
              <br>  netstat -tupln	отображает все сетевые соединения по протоколам TCP и UDP без разрешения имён в ip-адреса и PID'ы и имена процессов, слушающих порты
              <br>
              <br>  tcpdump tcp port 80	отобразить весь трафик на TCP-порт 80 (обычно — HTTP)
              <br>  tcpdump -i wlan0 src host 192.168.0.1 Отобразить на сетевом интерфесе проходящий трафик с носта 192.168.0.1

              <br>  iwlist scan	просканировать эфир на предмет, доступности беспроводных точек доступа
              <br>
              <br>  iwconfig eth1	показать конфигурацию беспроводного сетевого интерфейса eth1
              <br>
              <br>  <h1>Графическая утелита для работы с wi-fi.</h1>
              <br>Показывает уровень сигнала, и полосу канала.
              <br>inSSSDer.
              <br>
              <br>
              <br>  <h1>!Microsoft Windows networks(SAMBA)</h1>
              <br>
              <br>  nbtscan ip_addr	разрешить netbios-имя nbtscan не во всех системах ставится по-умолчанию, возможно, придётся доустанавливать вручную. nmblookup включен в пакет samba.
              <br>
              <br>  nmblookup -A ip_addr
              <br>
              <br>   # smbclient -L 172.16.15.33/to -U user отобразить ресурсы, предоставленные в общий доступ на windows-машине для пользователя user             <br>
              <br>smbget -Rr smb://ip_addr/share	подобно wget может получить файлы с windows-машин через smb-протокол
              <br>
              <br>  mount -t smbfs -o username=user,password=pass //winclient/share /mnt/share	смонтировать smb-ресурс, предоставленный на windows-машине, в локальную файловую систему
              <br>
              <br>
              <br>
              <br>  <h1>!IPTABLES (firewall)</h1>
              <br>
              <br>  iptables -t filter -nL	отобразить все цепочки правил
              <br>
              <br>  iptables -nL
              <br>
              <br>  iptables -t nat -L	отобразить все цепочки правил в NAT-таблице
              <br>
              <br>  iptables -t filter -F	очистить все цепочки правил в filter-таблице
              <br>
              <br>  iptables -F
              <br>
              <br>  iptables -t nat -F	очистить все цепочки правил в NAT-таблице
              <br>
              <br>  iptables -t filter -X	удалить все пользовательские цепочки правил в filter-таблице
              <br>
              <br>  iptables -t filter -A INPUT -p tcp --dport telnet -j ACCEPT	позволить входящее подключение telnet'ом
              <br>
              <br>  iptables -t filter -A OUTPUT -p tcp --dport http -j DROP	блокировать исходящие HTTP-соединения
              <br>
              <br>  iptables -t filter -A FORWARD -p tcp --dport pop3 -j ACCEPT	позволить "прокидывать" (forward) POP3-соединения
              <br>
              <br>  iptables -t filter -A INPUT -j LOG --log-prefix "DROP INPUT"	включить журналирование ядром пакетов, проходящих через цепочку INPUT, и добавлением к сообщению префикса "DROP INPUT"
              <br>
              <br>  iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE	включить NAT (Network Address Translate) исходящих пакетов на интерфейс eth0. Допустимо при использовании с динамически выделяемыми ip-адресами.
              <br>
              <br>  iptables -t nat -A PREROUTING -d 192.168.0.1 -p tcp -m tcp --dport 22 \



              <br>
              <br>
              <br>
              <br>  -j DNAT --to-destination 10.0.0.2:22	перенаправление пакетов, адресованных одному хосту, на другой хост
              <br>
              <br>
              <br>
              <br>
              <br>
              <br>  <h1>!Другие полезные команды</h1>
              <br>
              <br>  apropos …keyword	выводит список комманд, которые так или иначе относятся к ключевым словам. Полезно, когда вы знаете что делает программа, но не помните команду
              <br>
              <br>  man ping	вызов руководства по работе с программой, в данном случае, - ping
              <br>
              <br>  whatis …keyword	отображает описание действий указанной программы
              <br>
              <br>  mkbootdisk --device /dev/fd0 `uname -r`	создаёт загрузочный флоппи-диск
              <br>
              <br>  gpg -c file1	шифрует файл file1 с помощью GNU Privacy Guard
              <br>
              <br>  gpg file1.gpg	дешифрует файл file1 с помощью GNU Privacy Guard
              <br>
              <br>  wget -r www.example.com	загружает рекурсивно содержимое сайта www.example.com
              <br>
              <br>  wget -c www.example.com/file.iso	загрузить файл www.example.com/file.iso с возможностью останова и продолжения в последствии
              <br>
              <br>  echo 'wget -c www.example.com/files.iso' | at 09:00	начать закачку в указанное время
              <br>
              <br>  ldd /usr/bin/ssh	вывести список библиотек, необходимых для работы ssh
              <br>
              <br>  alias hh='history'	назначить алиас hh команде history
              <br>
              <br>
              <br>
              <br>
              <br>  <h1>!Как подключится к удаленной машине по протоколу rdp, если она за фаерволом, да и к тому же на котором открыт только ssh? Этим вопросом задаются многие. Решение очень простое, надо пробросить порты с помощью ssh или как еще называют создать ssh тунель.</h1>
              <br>  Рассмотри две ситуации.
              <br>  Первая. У нас есть корпоративная сеть. На нашем компьютере установлена операционная система Windows, имеет IP 192.168.0.125. В сети есть компьютер с OC&nbsp;Linux&nbsp;и IP 192.168.0.254. Нам нужно подключится в удаленный офис на компьютер с IP 10.10.10.125, на котором тоже установлена ОС Windows. В удаленном офисе имеется firewall на GNU&nbsp;Linux&nbsp;и открыт ssh, его IP 193.193.193.125.
              <br>  Наши действия:
              <br>  Подключаемся по ssh или просто подходим к компьютеру и логинемся, открываем терминал и вводим команду:
              <br>  ssh -L 192.168.0.254:3389:10.10.10.125:3389 login@193.193.193.125
              <br>  В ответ получаем запрос на ввод пароля. Вводим пароль.
              <br>  На своем компьютере запускаем оснастку «Подключение к удаленному рабочему столу», вводим IP 192.168.0.254 и в результате мы подключаемся в удаленный офис на нужный компьютер.
              <br>  Вторая ситуация: у вас компьютер с установленной&nbsp;Linux, все остальное тоже самое, что и в предыдущей ситуации.
              <br>  Запускаем консоль и вводим команду:
              <br>  ssh -L 3389:10.10.10.125:3389 login@193.193.193.125
              <br>  После чего подключаемся сами к себе на порт 3389:
              <br>  rdesktop -g 1024x768 127.0.0.1
              <br>
              <br>
              <br>
              <br>  Итак, задача поставлена
              <br>
              <br>  1. Подключить к&nbsp;Ubuntu&nbsp;МФУ, сделать принтер общим, настроить сканер.
              <br>  2. Написать скрипт, который будет ожидать нажатия клавиши на клавиатуре
              <br>  Esc – отмена незавершенного сканирования
              <br>  1 – режим сканирования в цвете
              <br>  2 – режим сканирования в оттенках серого
              <br>  0 – сохранить отсканированный файл (jpg, если была отсканирована одна страница или pdf, если несколько)
              <br>  Enter – отсканировать страницу.
              <br>  Решение
              <br>
              <br>  Пункт 1 отпал сам собой. Подключение принтера произошло неожиданно просто и не вызвало ни одного вопроса. Достаточно было просто подключить кабель USB к компьютеру, и через несколько секунд&nbsp;Ubuntu&nbsp;сообщила, что принтер должен печатать. Отправил пробную страницу – действительно печатает!
              <br>  Теперь самое интересное.
              <br>  Посмотрим, какие сканеры у нас есть в системе:
              <br>  scanimage -L
              <br>  Если система не может найти эту команду – значит, нужно установить пакет sane-utils:
              <br>  sudo apt-get install sane-utils
              <br>
              <br>  Программа нашла устройство с именем `xerox_mfp:libusb:001:002`
              <br>  Если сканер единственный в системе, то параметр «имя устройства» можно опустить; scanimage будет сканировать единственно возможным сканером.
              <br>
              <br>  Попробуем отсканировать страницу:
              <br>  scanimage -d “xerox_mfp:libusb:001:002” --resolution 150 --mode Color --format=tiff &gt; test.tif
              <br>  Разрешение 150 dpi выбрано из-за желания уменьшить время сканирования и размер выходного файла, но при этом оставить пользователю возможность напечатать документ с читабельным текстом. Если когда-нибудь потребуется распознавание текста или сканирование фотографий – тогда появятся дополнительные опции.
              <br>  Итак, у нас есть tiff. Либо один, либо несколько (отсканировали многостраничный документ). Понятно, что пользователи в 90% случаев сканируют документы для отправки по электронной почте, а tiff – формат не компактный. Значит, нужно сконвертировать результат в .jpg или .pdf.
              <br>
              <br>  Ставим пакет для редактирования/конвертирования растровых изображений:
              <br>  sudo apt-get install imagemagick
              <br>
              <br>  Сжимаем единственное изображение:
              <br>  convert -quality 60% test.tif test.jpg
              <br>
              <br>  Или все сразу:
              <br>  convert -compress jpeg -quality 60% *.tif all.pdf
              <br>
              <br>  Остался только один момент. Я не собираюсь оставлять подключенным к этому компьютеру монитор – значит, пользователь остается без обратной связи. Ну что ж, сделаем компьютер говорящим.
              <br>  Составим список звуков, которые должны воспроизводиться в ответ на нажатие той или иной клавиши на клавиатуре, берем в руки микрофон и записываем наши мини-фразы. Они максимально короткие по времени, ведь цель всего действа – не прослушивание mp3, а сканирование.
              <br>  1. Жду команду (waitcommand.mp3)
              <br>  2. Цветное сканирование (color.mp3)
              <br>  3. Черно-белое сканирование (bw.mp3)
              <br>  4. Сканирую страницу (scanpage.mp3)
              <br>  5. Сохраняю результат (saveresult.mp3)
              <br>
              <br>  Ах да, ведь у нас «чистая» система, которая не умеет воспроизводить mp3 из консоли…
              <br>  Исправляем ситуацию:
              <br>  sudo apt-get install mpg321
              <br>  Наслаждаемся:
              <br>  mpg123 -q waitcommand.mp3
              <br>  Теперь, кажется, все готово
              <br>
              <br>  Пишем скрипт /mnt/2tb/scan.sh
              <br>
              <br>  #!/bin/bash
              <br>
              <br>  # ==================================================
              <br>  # Настройки
              <br>
              <br>  scannerdevice="xerox_mfp:libusb:001:002" #scanimage -L
              <br>  workdir="/tmp/scanworkdir"
              <br>  destdir="/mnt/2tb/Share/1Scanner"
              <br>  dpi="150"
              <br>  jpegquality="60%"
              <br>
              <br>  # ==================================================
              <br>  # Собственно скрипт
              <br>
              <br>  sleep 10s
              <br>
              <br>  mkdir -p $workdir
              <br>  rm $workdir/*.* 2&gt;/dev/null
              <br>  numpages=0
              <br>  color="Gray"
              <br>  mpg123 -q waitcommand.mp3
              <br>
              <br>  while true
              <br>  do
              <br>  #Нажмите клавишу
              <br>  read -sn 1 Keypress
              <br>
              <br>  case "$Keypress" in
              <br>  $'\e')
              <br>  #Жду команду
              <br>  rm $workdir/*.* 2&gt;/dev/null
              <br>  numpages=0
              <br>  color="Gray"
              <br>  mpg123 -q waitcommand.mp3
              <br>  ;;
              <br>
              <br>  $'1')
              <br>  #Цвет
              <br>  color="Color"
              <br>  mpg123 -q color.mp3
              <br>  ;;
              <br>
              <br>  $'2')
              <br>  #Ч/б
              <br>  color="Gray"
              <br>  mpg123 -q bw.mp3
              <br>  ;;
              <br>
              <br>  $'0')
              <br>  #Сканирование завершено
              <br>  mpg123 -q saveresult.mp3
              <br>  filename=`date +%Y%m%d-%H%M%S`
              <br>  if [ $numpages = 1 ]; then
              <br>  convert -quality $jpegquality $workdir/1.tif $destdir/$filename.jpg
              <br>  fi
              <br>  if [ $numpages \&gt; 1 ]; then
              <br>  convert -compress jpeg -quality $jpegquality $workdir/*.tif $destdir/$filename.pdf
              <br>  fi
              <br>  rm $workdir/*.* 2&gt;/dev/null
              <br>  numpages=0
              <br>  color="Gray"
              <br>  mpg123 -q waitcommand.mp3
              <br>  ;;
              <br>
              <br>  $'')
              <br>  #Новая страница
              <br>  mpg123 -q scanpage.mp3
              <br>  let "numpages=numpages+1"
              <br>  scanimage -d $scannerdevice --resolution $dpi --mode $color --format=tiff &gt;$workdir/$numpages.tif
              <br>  mpg123 -q waitcommand.mp3
              <br>  ;;
              <br>  esac
              <br>
              <br>  done
              <br>
              <br>  Говорим
              <br>  chmod +x /mnt/2tb/scan.sh
              <br>  Запускаем
              <br>
              <br>  Да, все работает как ожидалось. Теперь идем в меню&nbsp;Ubuntu&nbsp;Система -&gt; Параметры -&gt; Запускаемые приложения, Добавить, Обзор, выбираем файл со скриптом. Перезагружаем компьютер, и… сканер начинает непрерывно что-то сканировать, звуки не воспроизводятся.
              <br>  Ладно, нажимаю Ctrl+C, читаю еще раз то что написал…
              <br>  Со звуками все тривиально – их нет в той папке, откуда вызывается скрипт. Непрерывное сканирование происходит, видимо, из-за $'') внутри case’а.
              <br>
              <br>  Я не стал с этим детально разбираться, а просто изменил команду автозапуска на
              <br>  /usr/bin/gnome-terminal -e /mnt/2tb/scan.sh --working-directory /mnt/2tb
              <br>  Еще раз перезагружаю компьютер – все работает, пользователи довольны.
              <br>
              <br>
              <br>
              <br>
              <br>  <h1>!Запись дисков CD DVD RW  ISO </h1>
              <br>  стереть диск
              <br>  #wodim -v blank=fast dev=/dev/sr0
              <br>  Записать диск
              <br>  # wodim dev=/dev/sr0 -speed=16 /home/user/Downloads/ctkarchlive-0.7-i686.iso
              <br>
              <br>  -dummy&nbsp;— симуляция прожига с выключенным лазером. Полезно, чтобы определить, сколько времени может занять запись.
              <br>  -multi&nbsp;— многосессионный диск.
              <br>  -fix&nbsp;— фиксация диска (без записи).
              <br>  speed=значение&nbsp;— задает скорость записи.
              <br>  blank=режим&nbsp;— очистка содержимого CD-RW. Доступные режимы:&nbsp;all&nbsp;(полная очистка, долго),&nbsp;fast&nbsp;(быстро),&nbsp;session&nbsp;(очистить последнюю сессию).
              <br>  -format&nbsp;— форматировать болванку CD/DVD-RW.
              <br>  -overburn&nbsp;— включить возможность записи больше, чем стандартный объем диска. В этом случае, как правило, необходимо также использовать режим записи SAO (-sao).
              <br>
              <br>
              <br>
              <br>
              <br>
              <br>  <h1>!Устраняем проблему numlockx и индикатором Num Lock в Debian Squeeze в графической системе X</h1>
              <br>  19 Декабрь 2011Сергей Ткаченко
              <br>  Сегодня мне понадобилась утилита, управляющая статусом клавиши Num Lock из скриптов. Традиционно для этих целей используется программа numlockx. Доставив её из репозиториев, я с удивлением обнаружил, что в моем дистрибутиве (Я использую Debian 6 на двух машинах, i386 и x64, и рабочую среду LXDE) она игнорирует индикатор-лампочку Num Lock. Т.е. режим Num Lock включен, а индикации об этом никакой. Первый раз в жизни я засел за исходники, и скомпилировал свою первую программу для Linux.
              <br>  Первым&nbsp; делом я выкачал исходники оригинальной numlockx
              <br>  КОД:&nbsp;ВЫДЕЛИТЬ ВСЁ
              <br>  apt-get&nbsp;source&nbsp;numlockx
              <br>  Открыв их, я не увидел знакомых бук, если не считать операторов C++. Код кишил незнакомыми мне API и функциями, среди которых, впрочем, благодаря логичным названиям функций, просматривалась рабочая лошадка.
              <br>  Меня заинтересовали функции numlock_set_on(), numlock_set_off() и numlock_toggle(). Суть их сводилась к вызову функции XkbLockModifiers, в которую передавался код статуса Num_Lock.
              <br>  &nbsp;
              <br>  Покопавшись, я обнаружил, что для поиска модификатора клавиши Num Lock в программе используется авторская функция, в которой я до конца не разобрался. Однако, я нагуглил, что для решения этой задачи может использоваться функция XkbKeysymToModifiers. Заменив оригинальный текст на вызов этой функции, я получил работоспособную версию numlockx.
              <br>  КОД:&nbsp;ВЫДЕЛИТЬ ВСЁ
              <br>  /*unsigned&nbsp;int&nbsp;xkb_mask_modifier(&nbsp;XkbDescPtr&nbsp;xkb,&nbsp;const&nbsp;char&nbsp;*name&nbsp;)
              <br>  {
              <br>  int&nbsp;i;
              <br>  if(&nbsp;!xkb&nbsp;||&nbsp;!xkb-&gt;names&nbsp;)
              <br>  return&nbsp;0;
              <br>  for(&nbsp;i&nbsp;=&nbsp;0;
              <br>  i&nbsp;
              &lt;&nbsp;XkbNumVirtualMods;<br>  i++&nbsp;)
              <br>  {
              <br>  char*&nbsp;modStr&nbsp;=&nbsp;XGetAtomName(&nbsp;xkb-&gt;dpy,&nbsp;xkb-&gt;names-&gt;vmods[i]&nbsp;);
              <br>  if(&nbsp;modStr&nbsp;!=&nbsp;NULL&nbsp;&amp;&amp;&nbsp;strcmp(name,&nbsp;modStr)&nbsp;==&nbsp;0&nbsp;)
              <br>  {
              <br>  unsigned&nbsp;int&nbsp;mask;
              <br>  XkbVirtualModsToReal(&nbsp;xkb,&nbsp;1&nbsp;
              &lt;&lt;&nbsp;i,&nbsp;&amp;mask&nbsp;);<br>  return&nbsp;mask;
              <br>  }
              <br>  }
              <br>  return&nbsp;0;
              <br>  }
              <br>  unsigned&nbsp;int&nbsp;xkb_numlock_mask()
              <br>  {
              <br>  XkbDescPtr&nbsp;xkb;
              <br>  if((&nbsp;xkb&nbsp;=&nbsp;XkbGetKeyboard(&nbsp;dpy,&nbsp;XkbAllComponentsMask,&nbsp;XkbUseCoreKbd&nbsp;))&nbsp;!=&nbsp;NULL&nbsp;)
              <br>  {
              <br>  unsigned&nbsp;int&nbsp;mask&nbsp;=&nbsp;xkb_mask_modifier(&nbsp;xkb,&nbsp;"NumLock"&nbsp;);
              <br>  XkbFreeKeyboard(&nbsp;xkb,&nbsp;0,&nbsp;True&nbsp;);
              <br>  return&nbsp;mask;
              <br>  }
              <br>  return&nbsp;0;
              <br>  }
              <br>  */
              <br>  unsigned&nbsp;int&nbsp;xkb_numlock_mask()
              <br>  {
              <br>  return&nbsp;XkbKeysymToModifiers&nbsp;(dpy,&nbsp;XK_Num_Lock);
              <br>  }
              <br>
              <br>  Вы можете выкачать исходники и изменить файл main.c, затем пересобрать пакет командами
              <br>  КОД:&nbsp;ВЫДЕЛИТЬ ВСЁ
              <br>  ./configure
              <br>  make
              <br>  checkinstall
              <br>  &nbsp;
              <br>  Также я выкладываю готовый deb-пакет для numlockx.
              <br>  Надеюсь, кому-то он сэкономит время и пригодится.
              <br>
              <br>  <h1>!НЕ РАБОТАЕТ ЦИФРОВАЯ КЛАВИАТУРА (NUMPAD) В UBUNTU</h1>
              <br>
              <br>  Зайти в
              <br>  Система -&gt; Параметры -&gt; Клавиатура -&gt; Кнопки мыши &nbsp;&nbsp;
              <br>  И снять отметку с параметра: "Разрешать управлять указателем с клавиатуры".
              <br>  Включается нажатием комбинации Shift + Num Lock, или появляется после установки некоторых обновлений
              <br>
              <br>
              <br>  <h1>! Управление модулями.</h1>
              <br>  Для начало полезно узнать о всех pci устройствах в системе.
              <br>  С подробным выводом информации.
              <br>  $lspci -vv
              <br>  Часть касающийся wifi адаптера
              <br>
              <br>  02:01.0 Ethernet controller: Atheros Communications Inc. Atheros AR5001X+ Wireless Network Adapter (rev 01)
              <br>
              <br>  	Subsystem: D-Link System Inc D-Link AirPremier DWL-G550 Wireless PCI Adapter
              <br>
              <br>  	Control: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- DisINTx-
              <br>
              <br>  	Status: Cap+ 66MHz- UDF- FastB2B+ ParErr- DEVSEL=medium TAbort- TAbort MAbort- SERR- PERR- INTx-
              <br>
              <br>  	Latency: 168 (2500ns min, 7000ns max), Cache Line Size: 32 bytes
              <br>
              <br>  	Interrupt: pin A routed to IRQ 11
              <br>
              <br>  	Region 0: Memory at e6000000 (32-bit, non-prefetchable) [size=64K]
              <br>
              <br>  	Capabilities: access denied
              <br>
              <br>  	Kernel driver in use: ath5k
              <br>
              <br>
              <br>  Видим, что загруженный модуль ath5k.
              <br>  Определим подробную информацию о модуле.
              <br>  # modinfo ath5k
              <br>
              <br>  Получим информацию.
              <br>  filename:       /lib/modules/2.6.32-5-686/kernel/drivers/net/wireless/ath/ath5k/ath5k.ko
              <br>
              <br>  version:        0.6.0 (EXPERIMENTAL)
              <br>
              <br>  license:        Dual BSD/GPL
              <br>
              <br>  description:    Support for 5xxx series of Atheros 802.11 wireless LAN cards.
              <br>
              <br>  author:         Nick Kossifidis
              <br>
              <br>  author:         Jiri Slaby
              <br>
              <br>  srcversion:     E4844FBE7F1B69B18941233
              <br>
              <br>  depends:        mac80211,led-class,cfg80211,ath
              <br>
              <br>  vermagic:       2.6.32-5-686 SMP mod_unload modversions 686
              <br>
              <br>  parm:           nohwcrypt:Disable hardware encryption. (bool)
              <br>
              <br>  parm:           all_channels:Expose all channels the device can use. (bool)
              <br>
              <br>
              <br>  Список всех загруженных модулей ядром.
              <br>  $lsmod
              <br>
              <br>  <h1>!Добавление (подключение) модулей к ядру.</h1>
              <br>  Для примера подключим модуль msdos.
              <br>  # insmod /lib/modules/2.6.32-5-686/kernel/fs/fat/msdos.ko
              <br>
              <br>  insmod: error inserting '/lib/modules/2.6.32-5-686/kernel/fs/fat/msdos.ko': -1 Unknown symbol in module
              <br>
              <br>  Получили ошибку.
              <br>  # echo $?
              <br>  Вывод 1 что говорит о ошибке.
              <br>   Смотрим
              <br>  # modinfo /lib/modules/2.6.32-5-686/kernel/fs/fat/msdos.ko
              <br>  filename:       /lib/modules/2.6.32-5-686/kernel/fs/fat/msdos.ko
              <br>
              <br>  description:    MS-DOS filesystem support
              <br>
              <br>  author:         Werner Almesberger
              <br>
              <br>  license:        GPL
              <br>
              <br>  depends:        fat
              <br>
              <br>  vermagic:       2.6.32-5-686 SMP mod_unload modversions 686
              <br>
              <br>  Видим зависимость от fat.
              <br>  Аналогичную информации можно получить из файла modules.dep
              <br>  # cat /lib/modules/2.6.32-5-686/modules.dep |grep msdos
              <br>
              <br>  Загружаем fat.
              <br>  # insmod /lib/modules/2.6.32-5-686/kernel/fs/fat/fat.ko
              <br>
              <br>  # modinfo /lib/modules/2.6.32-5-686/kernel/fs/fat/msdos.ko
              <br>
              <br>  # echo $?
              <br>  0

              <br>  Все получилось.
              <br>
              <br>  Добавление модуля в автоматическую загрузку необходимо прописать модуль
              <br>  /etc/modules
              <br>
              <br>  <h1>!Удаление загруженных модулей.</h1>
              <br>  # rmmod msdos
              <br>
              <br>  Удалили из ядра модуль  msdos
              <br>
              <br>
              <br>  <h1>! modprobe надстройка для подключения модулей ядра.</h1>
              <br>  Загрузить  модуль в ядро
              <br>  # modprobe msdos
              <br>  Просмотреть список модулей.
              <br>  #modprobe -l
              <br>  Удалить модуль из ядра
              <br>  #modprobe -r msdos
              <br>  Просмотр списка модулей в директории 3Com сетевых интерфейсов.
              <br>
              <br>  # modprobe -lt net | grep 3c
              <br>
              <br>
              <br>
              <br>  <h1>!Скопировать таблицу партиции диска.</h1>
              <br>  # sfdisk -d /dev/sda &gt; testpart.txt
              <br>  восстановить партицию диска
              <br>  #sfdisk /dev/hda
              &lt; partition_backup.txt<br>
                <br>  <h1>!Определить сетевые группы в сети nbtscan netbios</h1>
                <br>  nbtscan -v -s : 172.16.16.1/20 |grep 1eG |grep -v NAME               <br>  гле 1eG индификатор группы
                <br>  -v исключить из поиска.
                <br>  nbtscan -v -s : 172.16.16.1/20 |grep 1eG |grep -v NAME|cut -d: -f1 &gt; nbtscan.txt
                <br>
                <br>  -d&nbsp;это указание на разделение по символу :
                <br>  далее&nbsp;-f1&nbsp;инструкция какое именно поле нужно вывести на экран – мы указываем первое.
                <br>
                <br>
                <br>  <h1> Настройка скрипта для автоматического мониторинга сети</h1>
                <br>#!/bin/sh
                <br>nbtscan -v -s : 172.16.16.1/20 |grep 1eG |grep -v NAME | sed -e 's/:/ /g' | while read ip wg oth; do
                <br>
                <br>   MAC=$(nbtscan -v -s, $ip | grep "$ip,MAC" | cut -d, -f3 )
                <br>   NAME=$(nbtscan -v -s, $ip |grep ,00U|cut -d, -f2)
                <br>
                <br>   echo "#" "IP="$ip "GROUP="$wg "MAC=""$MAC" "NAME=""$NAME"
                <br>   hp-search-mac $MAC | grep ^Switch | head -1 | sed -e 's/^/   /'
                <br>   nmap -O $ip | egrep "^OS detail| open " | sed -e 's/^/     /'
                <br>done
                <br>
                <br>
                <br>
                <br>
                <br>
                <br><h1>Такие инструменты как&nbsp;grep,&nbsp;awk,&nbsp;sed,&nbsp;cut,&nbsp;cat&nbsp;могут существенно облегчить вам жизнь,</h1>
                <br> если уметь ими пользоваться. Они помогут вам сократить ваши ежедневные усилия по администрированию системы и очень понадобятся при написании ваших скриптов для автоматизации процессов. В этой статье не будут рассмотрены все возможности этих мощных утилит. Мы просто рассмотрим возможности этих программ и слегка коснемся их использования.
                <br>  Самой&nbsp;простой и наиболее часто&nbsp;используемой командой можно назвать cat.
                <br>  ifreebsd#/var/log&gt;cat /etc/hosts
                <br>  Это команда выводит на экран данные из файла, с ее помощью легко просматривать файлы. Но если мы к примеру возьмемся просматривать файл отчетов системы&nbsp;/var/log/messages.
                <br>  ifreebsd#/var/log&gt;cat /var/log/messages
                <br>  Мы&nbsp;обнаружим большое количество строк не очень удобно рассматривать все и сразу, и тут нам&nbsp;на помощь приходит другой инструмент практически любой&nbsp;UNIX-like системы, это –&nbsp;grep. Вот таким способом можно указать за какое время данные нас интересуют указываем&nbsp;&nbsp;27 Oct с 13 – 14 часов
                <br>  ifreebsd#/var/log&gt;cat ./messages | grep “Oct 27 13″
                <br>  На экране будут&nbsp;выведены только данные за этот период.&nbsp;cat&nbsp;и&nbsp;grep&nbsp;я использую каждый день, надеюсь и вам они будут полезны.
                <br>  Перейдем к&nbsp;cut, рассмотрим реальный пример, нам необходимо из файла/etc/passwd&nbsp;получить только имена пользователей, тогда нам подойдет следующая конструкция.


                <br>  ifreebsd:~/IF&gt;cut -d : -f1 /etc/passwd
                <br>  Результат будет следующим
                <br>  root
                <br>  daemon
                <br>  bin
                <br>  sys
                <br>  sync
                <br>  games
                <br>  man
                <br>  lp
                <br>  mail
                <br>  news
                <br>  uucp
                <br>  proxy
                <br>  Разберем эту конструкцию по подробней&nbsp;cut -d : -f1 /etc/passwd
                <br>  -d&nbsp;это указание на разделение по символу :
                <br>  далее&nbsp;-f1&nbsp;инструкция какое именно поле нужно вывести на экран – мы указываем первое. Также можно использовать флажок&nbsp;-с&nbsp;и указать количество символов которое вам необходимо вывести на экран. Вот еще один пример использованияcut, тут мы разделителем указываем пробел между словами.
                <br>  ifreesbsd:~/IF&gt;uname -a | cut –delimiter=’ ‘ -f 1,7,8
                <br>  Попробуйте выполнить эту команду, разобраться в ней не сложно.
                <br>  А мы идем дальше, рассмотрим&nbsp;sed.&nbsp;SED&nbsp;– это так называемый потоковый редактор. Он редактирует сроки получая данные или с стандартного ввода или из файла, отлично подходит для работы в&nbsp;конвейере.&nbsp;Для того чтобы осознать все мощь редактора&nbsp;sed&nbsp;необходимо изучать регулярные выражения которые в нем используются, мы же лишь слегка рассмотрим примеры его использования. К примеру эта конструкция прочитает указанный файл и заменит все адреса192.168.1.222&nbsp;которые встретит на адрес&nbsp;192.168.1.101&nbsp;и выведет эту информация на экран (не переписывая искомый файл).
                <br>  ifreebsd:~/IF&gt;sed -e “s/192.168.1.222/192.168.1.101/g” /etc/network/interfaces
                <br>  Эта команда посчитает все строки в искомом файле и выведет на экран&nbsp;количество строк.
                <br>  ifreebsd:~/IF&gt;sed -n ‘$=’ /etc/passwd
                <br>  Вот эта конструкция&nbsp;пронумерует все строки и выведет на экран.
                <br>  ifreebsd:~/IF&gt;sed ‘/./=’ /etc/passwd | sed ‘/./N; s/n/ /’
                <br>
                <br>  А &nbsp;мы продолжаем наш обзор и переходим к&nbsp;awk. Про &nbsp;Awk&nbsp;вполне можно писать книгу и не одну. На самом деле это не просто команда, это скриптовой язык программирования. Рассмотрим примеры использования&nbsp;awk.
                <br>  Эта инструкция выводит только те строки в которых обнаружено искомое словоroot.
                <br>  ifreebsd:~/IF&gt;awk ‘/root/ {print}’ /etc/passwd
                <br>  По умолчанию&nbsp;awk&nbsp;делит всю входящую в него информацию на поля разделенные пробелами, и к этой информации можно обращаться вот так к примеру -
                <br>  ifreebsd:~/IF&gt;awk ‘{a = $1; print a}’ /etc/hosts
                <br>  Следовательно на экран будет выведено только первое поле, выводить можно по несколько полей, самый простой способ сохранить эту информацию в новый файл, это воспользоваться такой конструкцией:
                <br>  ifreebsd:~/IF&gt;awk ‘{a = $1; print a}’ /etc/hosts &gt; host.info
                <br>  Перенаправление&nbsp;&gt;&nbsp;создает файл&nbsp;host.info&nbsp;и сохраняет в него данные которые поступили из&nbsp;awk. &nbsp;AWK&nbsp;также как и&nbsp;sed&nbsp;работает с регулярными выражением, и он более универсален чем&nbsp;sed.
                <br>  Надеюсь данная информация даст вам возможность сделать первые шаги в изучении этих полезных инструментов, и вы продолжите их изучение понимая что они не такие сложные как может показаться.
                <br>  http://ifreebsd.org/
                <br>
                <br>
                <br>
                <br>
                <br>  Посмотреть софт
                <br>  http://yumzhakov.wordpress.com/2011/11/13/%D0%BC%D0%BE%D0%B9-%D1%81%D0%BE%D1%84%D1%82-%D0%BD%D0%B0-ubuntu-10/
                <br>
                <br>
                <br>
                <br>  <h1>! LVM Управление разделами</h1>
                <br>  Установка
                <br>  apt-get install lvm2
                <br>  Создаем в начале диска дескриптор группы томов.
                <br>  pvcreate /dev/sdc
		<br>  Для создания группы томов test используется команда
		<br>  vgcreate test /dev/sdc
                <br>
  		<br>
                <br>
		<br>
                <br>
                <br>
                <br>
		<br>
                <br>

                <br>  dumpconfig
                <br>  Сбрасывает дамп активной конфигурации
                <br>  formats
                <br>  Показывает список доступных форматов метаданных
                <br>  help
                <br>  Выводит справочную информацию о командах
                <br>  lvchange
                <br>  Изменяет атрибуты логического тома (томов)
                <br>  lvcreate
                <br>  Создаёт логический том
                <br>  lvdisplay
                <br>  Выводит информацию о логическом томе
                <br>  lvextend
                <br>  Добавляет пространство в логический том
                <br>  lvmchange
                <br>  По причине использования сопоставителя устройств, эта команда является устаревшей
                <br>  lvmdiskscan
                <br>  Выводит список устройств, которые можно использовать как логические тома
                <br>  lvmsadc
                <br>  Собирает данные об активности
                <br>  lvmsar
                <br>  Создаёт отчёт об активности
                <br>  lvreduce
                <br>  Уменьшает размер логического тома
                <br>  lvremove
                <br>  Удаляет логический том(а) из системы
                <br>  lvrename
                <br>  Переименовывает логический том
                <br>  lvresize
                <br>  Изменяет размер логического тома
                <br>  lvs
                <br>  Выводит информацию о логических томах
                <br>  lvscan
                <br>  Выводит список всех логических томов во всех группах томов
                <br>  pvchange
                <br>  Изменяет атрибуты физического тома (томов)
                <br>  pvcreate
                <br>  Подготавливает физический том (тома) к использованию в LVM
                <br>  pvdata
                <br>  Выводите записанные на диск метаданные о физических томах (томе)
                <br>  pvdisplay
                <br>  Выводит различные атрибуты физического тома (томов)
                <br>  pvmove
                <br>  Перемещает блоки с одного физического тома на другой
                <br>  pvremove
                <br>  Удаляет LVM-метку (метки) с физического тома (томов)
                <br>  pvresize
                <br>  Изменяет размер физического тома, используемого группой томов
                <br>  pvs
                <br>  Выводит информацию о физических томах
                <br>  pvscan
                <br>  Выводит список всех физических томов
                <br>  segtypes
                <br>  Выводит список доступных типов сегментов
                <br>  vgcfgbackup
                <br>  Делает резервную копию конфигурации группы томов
                <br>  vgcfgrestore
                <br>  Восстанавливает резервную копию конфигурации группы томов
                <br>  vgchange
                <br>  Изменяет атрибуты группы томов
                <br>  vgck
                <br>  Проверяет целостность группы томов
                <br>  vgconvert
                <br>  Преобразует формат метаданных группы томов
                <br>  vgcreate
                <br>  Создаёт группу томов
                <br>  vgdisplay
                <br>  Выводит информацию о группе томов
                <br>  vgexport
                <br>  Удаляет регистрацию группы томов из системы
                <br>  vgextend
                <br>  Добавляет физические тома в группу томов
                <br>  vgimport
                <br>  Регистрирует экспортированную группу томов в системе
                <br>  vgmerge
                <br>  Объединяет группы томов
                <br>  vgmknodes
                <br>  Создаёт специальные файлы для устройств групп томов в /dev/
                <br>  vgreduce
                <br>  Удаляет физический том из группы томов
                <br>  vgremove
                <br>  Удаляет группу томов
                <br>  vgrename
                <br>  Переименовывает группу томов
                <br>  vgs
                <br>  Выводит информацию о группах томов
                <br>  vgscan
                <br>  Ищет все группы томов
                <br>  vgsplit
                <br>  Перемещает физические тома в новую группу томов
                <br>  version
                <br>  Выводит информацию о версии программы и драйвера
                <br>
                <br>
                <br>  Расширение и перераспределение
                <br>  Надо увеличить размер директории /home
                <br>  Определяем сколько свободного места
                <br>  root@debian:~# pvscan
                <br>
                <br>    PV /dev/sda1   VG vg1   lvm2 [27,94 GiB / 1,04 GiB free]
                <br>
                <br>    Total: 1 [27,94 GiB] / in use: 1 [27,94 GiB] / in no VG: 0 [0   ]
                <br>
                <br>  Видим, что у нас 1 Г свободно в томе vg1
                <br>  Выполним расширение логического тома на 1.6 Г командой.
                <br>
                <br>  root@debian:~# lvextend -L +1600 /dev/vg1/home /dev/sda1
                <br>
                <br>  Теперь надо увеличить раздел файловой системы.
                <br>  root@debian:~# resize2fs /dev/mapper/vg1-home
                <br>
                <br>  http://www.opennet.ru/base/sys/linux_lvm2.txt.html
                <br>
                <br>  <h1> Уменьшить размер LVM раздела </h1>
		<br>Загружаемся с LifeCD linux и выполням комманду.
                <br>#lvreduce -r -L -150G /dev/pv1/root
                <br>Опцмия -r означает уменьшить также файловую систему
                <br>  -150G уменьшаем раздел root на 150G
		<br> Все.
                <br>
                <br> <h1>Переименовать раздел LVM</h1>
                <br>  Загружаемся с lifeCD выполнляем комманду
                <br>  vgrename old_name new_name
                <br>  Производим редактирование файлов
                <br>  /etc/fstab
		<br> /boot/grub/grub.cfg
                <br>  Заменив old_name new_name
                <br>
                <br>

                <br>  <h1>!LogWatch&nbsp;- анализ и отчёт о состоянии сервера</h1>
                <br>  $ sudo apt-get install logwatch
                <br>  $ sudo mkdir /var/cache/logwatch
                <br>  $ sudo cp /usr/share/logwatch/default.conf/logwatch.conf /etc/logwatch/conf/
                <br>  Запустить
                <br>  $sudo logwatch
                <br>
                <br>  <h1>!Strace – мощный инструмент диагностики.</h1>
                <br>
                <br>
                <br>
                <br>  !Get the entire details about the system as follows:
                <br>
                <br>  $ lshw
                <br>
                <br>  $Проверка сети аналог tracert
                <br>  mtp
                <br>
                <br>
                <br>
                <br>  <h1>!Работа с изображением </h1>
                <br>  Изменить разрешения для картинки.
                <br>  $ convert image.png -resize 1024x768 image.png
                <br>
                <br>
                <br>  <h1>!Изменить разрешение консоли в Debian 6</h1>
                <br>  В зависимости от версии grub открываете файл /boot/grub/menu.lst или /boot/grub/grub.cfg,
                <br>  изменяем права на файл по умолчанию только на чтение.
                <br>  Находите секцию menuentry и в конец строки linux /boot/vmlinuz-2.6.32-5-amd64 root=... добавляете (или если есть, то изменяете значение) параметр vga=0x305&nbsp; (Разрешение консоли 1024х768)
                <br>  пример:
                <br>  &nbsp;kernel&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /boot/vmlinuz-2.6.27-12-generic root=UUID=daf58b14-2334-4cc4-b71e-abd28216b6d7 ro quiet vga=0x305
                <br>  Mode 0x0300: 640x400 (+640), 8 bits
                <br>  &nbsp; Mode 0x0301: 640x480 (+640), 8 bits
                <br>  &nbsp; Mode 0x0303: 800x600 (+800), 8 bits
                <br>  &nbsp; Mode 0x0305: 1024x768 (+1024), 8 bits
                <br>  &nbsp; Mode 0x0307: 1280x1024 (+1280), 8 bits
                <br>  &nbsp; Mode 0x030e: 320x200 (+640), 16 bits
                <br>  &nbsp; Mode 0x030f: 320x200 (+1280), 24 bits
                <br>  &nbsp; Mode 0x0311: 640x480 (+1280), 16 bits
                <br>  &nbsp; Mode 0x0312: 640x480 (+2560), 24 bits
                <br>  &nbsp; Mode 0x0314: 800x600 (+1600), 16 bits
                <br>  &nbsp; Mode 0x0315: 800x600 (+3200), 24 bits
                <br>  &nbsp; Mode 0x0317: 1024x768 (+2048), 16 bits
                <br>  &nbsp; Mode 0x0318: 1024x768 (+4096), 24 bits
                <br>  &nbsp; Mode 0x031a: 1280x1024 (+2560), 16 bits
                <br>  &nbsp; Mode 0x031b: 1280x1024 (+5120), 24 bits
                <br>  &nbsp; Mode 0x0330: 320x200 (+320), 8 bits
                <br>  &nbsp; Mode 0x0331: 320x400 (+320), 8 bits
                <br>  &nbsp; Mode 0x0332: 320x400 (+640), 16 bits
                <br>  &nbsp; Mode 0x0333: 320x400 (+1280), 24 bits
                <br>  &nbsp; Mode 0x0334: 320x240 (+320), 8 bits
                <br>  &nbsp; Mode 0x0335: 320x240 (+640), 16 bits
                <br>  &nbsp; Mode 0x0336: 320x240 (+1280), 24 bits
                <br>  &nbsp; Mode 0x033d: 640x400 (+1280), 16 bits
                <br>  &nbsp; Mode 0x033e: 640x400 (+2560), 24 bits
                <br>  &nbsp; Mode 0x0345: 1600x1200 (+1600), 8 bits
                <br>  &nbsp; Mode 0x0346: 1600x1200 (+3200), 16 bits
                <br>  &nbsp; Mode 0x034a: 1600x1200 (+6400), 24 bits
                <br>  &nbsp; Mode 0x034b: 1600x900 (+1600), 8 bits
                <br>  &nbsp; Mode 0x034c: 1600x900 (+3200), 16 bits
                <br>  &nbsp; Mode 0x034d: 1600x900 (+6400), 24 bits
                <br>  &nbsp; Mode 0x0360: 1280x800 (+1280), 8 bits
                <br>  &nbsp; Mode 0x0361: 1280x800 (+5120), 24 bits
                <br>
                <br>
                <br>  <h1>

                  <a name="MC"></a>MC редактор</h1>
                <a href="#top">Назад</a>
                <br>
                <br>  f3 insert
                <br>  f3 copy
                <br>  f5 paste
                <br>  alt+enter insert name file in terminal
                <br>
                <br>  <h1>!Звук на ноутбуке</h1>
                <br>  apt-get insatall alsa
                <br>  apt-get install alsa-utils
                <br>   затем sudo alsamixer,используя стрелоски поставьте громкость на максимум и нажимая на клавишу "M"
                <br>  снимите "mute", что бы внизу под шкалами "master" "pcm" и "front" не было "MM", а стояло значение
                <br>  "00", затем нажмите "Escape" и проверьте звук, проиграв звуковой файл
                <br>  <h1>!nano</h1>
                <p>В

                  <code>nano
                  </code> существуют два вида управляющих последовательностей - собственно управляющие, <strong>Control</strong>+литера, и мета-последовательности, <strong>Meta</strong>+литера. Посредством первых осуществляется редактирование текста и операции с файлами. Управляющие последовательности частично дублируются функциональными клавишами <strong>F1</strong>-<strong>F16</strong> (вызов <strong>F13</strong>-<strong>F16</strong> - посредством сочетания <strong>Shift</strong>+<strong>F1</strong>-<strong>F4</strong>).&nbsp; Meta-последовательности предназначены для изменения настроек редактора&nbsp; (тот же результат достигается и опциями командной строки).
                </p>
                <p>Напомню, что на клавиатуре PC роль Meta-клавиши выполняет обычно нажатие клавиши <strong>Alt</strong>&nbsp; (в некоторых раскладках - конкретно <strong>Alt</strong>'а правого, или, напротив, левого), или нажатие и отпуск клавиши <strong>Escape</strong>.
                </p>
                <p>&nbsp;Все основные Control-последовательности перечислены внизу окна терминала.   <br>
                </p>
                <p>Control-последовательности - следующие (в скобках - дублирующие функциональные клавиши и, иногда, Meta-последовательности):
                </p>
                <ul>
                  <li><strong>Control</strong>+<strong>G</strong> (<strong>F1</strong>) - вызов меню полной подсказки;
                  </li>
                  <li><strong>Control</strong>+<strong>X</strong> (<strong>F2</strong>) - выход из программы;
                  </li>
                  <li><strong>Control</strong>+<strong>O</strong> (<strong>F3</strong>) - запись текущего файла;
                  </li>
                  <li><strong>Control</strong>+<strong>R</strong> (<strong>F5</strong>) - вставка файла в текущий;
                  </li>
                  <li><strong>Control</strong>+<strong>W</strong> (<strong>F6</strong>) - поиск текста в текущем файле;
                  </li>
                  <li><strong>Control</strong>+<strong>\</strong>(<strong>F14</strong> или <strong>Meta</strong>+<strong>R</strong>) - замена текста в текущем файле; сначала вводится замещающий текст, потом, после нажатия <strong>Enter</strong> - заменяемый;
                  </li>
                  <li><strong>Control</strong>+<strong>Y</strong> (<strong>F7</strong> или <strong>PgUp</strong>) - перемещение на предыдущий экран;
                  </li>
                  <li><strong>Control</strong>+<strong>V</strong> (<strong>F8</strong> или <strong>PgDwn</strong>) - перемещение на следующий экран;
                  </li>
                  <li><strong>Control</strong>+<strong>K</strong> (<strong>F9</strong>) = удаление (Cut, вырезать) строку в позиции курсора с сохранением ее в буфере (cutbuffer);
                  </li>
                  <li><strong>Control</strong>+<strong>U </strong> - (<strong>F10</strong>) - вставка содержимого cutbuffer'а в строку в позиции курсора; если последняя не менялась - выполняет роль Undo (отмены), штатно не предусмотренной; может также использоваться для неограниченного клонирования строк в произвольной части текста - достаточно после удаления переместить курсор в нужное место;
                  </li>
                  <li><strong>Control</strong>+<strong>C</strong> (<strong>F11</strong>) - вывод информации о положении курсора в форме вр
                  </li>
                  <li><strong>Control</strong>+<strong>T</strong> (<strong>F12</strong>) - проверка орфографии (посредством внешней программы спеллинга, если она установлена и включена соответствующая опция в конфиге, см. ниже);
                  </li>
                  <li><strong>Control</strong>+<strong>P</strong> - перемещение курсора на одну строку вверх;
                  </li>
                  <li><strong>Control</strong>+<strong>N</strong> - перемещение курсора на одну строку вниз;
                  </li>
                  <li><strong>Control</strong>+<strong>F</strong> - перемещение курсора на один символ вперед;
                  </li>
                  <li><strong>Control</strong>+<strong>B</strong> - перемещение курсора на один символ назад;
                  </li>
                  <li><strong>Control</strong>+<strong>A </strong> - перемещение курсора в начало текущей строки;
                  </li>
                  <li><strong>Control</strong>+<strong>E</strong> - перемещение курсора в конец текущей строки;
                  </li>
                  <li><strong>Control</strong>+<strong>L</strong> - перерисовка текущего экрана;
                  </li>
                  <li><strong>Control</strong>+<strong>^</strong> (<strong>Meta</strong>+<strong>A</strong>) - выделение (и помещение в буфер) текста, начиная с текущей позиции курсора;
                  </li>
                  <li><strong>Control</strong>+<strong>D</strong> - удаление символа в позиции курсора;
                  </li>
                  <li><strong>Control</strong>+<strong>H</strong> - удаление символа слева от курсора;
                  </li>
                  <li><strong>Control</strong>+<strong>I</strong> - вставка символа табуляции;
                  </li>
                  <li><strong>Control</strong>+<strong>J</strong> (<strong>F4</strong>) автозаполнение текущего абзаца;
                  </li>
                  <li><strong>Control</strong>+<strong>M</strong> вставка символа перевода строки (CR) в позиции курсора;
                  </li>
                  <li><strong>Control</strong>+<strong>_</strong> (<strong>F13</strong> или <strong>Meta</strong>+<strong>G</strong>) - переход на указанный номер строки.
                  </li>
                  <li>  <br>
                  </li>
                </ul>
                <p>Meta-последовательности работают обычно как переключатели. С их помощью выполняются следующие действия:
                </p>
                <ul>
                  <li><strong>Meta</strong>+<strong>C</strong> - включение/выключение постоянного положения курсора;
                  </li>
                  <li><strong>Meta</strong>+<strong>I</strong> - включение/выключение автоотступов;
                  </li>
                  <li><strong>Meta</strong>+<strong>Z</strong> - включение/выключение приостановки;
                  </li>
                  <li><strong>Meta</strong>+<strong>X</strong> - включение/выключение вывода зоны подсказки;
                  </li>
                  <li><strong>Meta</strong>+<strong>P</strong> - включение/выключение режима эмуляции редактора
                  <code>pico
                  </code>;
                  </li>
                  <li><strong>Meta</strong>+<strong>W</strong> - включение/выключение режима переноса слов;
                  </li>
                  <li><strong>Meta</strong>+<strong>M</strong> - включение/выключение поддержки мыши (только при сборке с поддержкой
                  <code>gpm
                  </code>;
                  </li>
                    <li><strong>Meta</strong>+<strong>K</strong> - разрешить/запретить вырезание до конца;
                    </li>
                  <li><strong>Meta</strong>+<strong>E</strong> - включение/выключение использования регулярных выражений (regexp).
                  </li>
                </ul>Кроме того, в
                <code>nano
                </code> предусмотрено еще и внешнее средство конфигурирования - пользовательский конфиг
                <code>~/.nanorc
                </code>. Выполнив в нем некоторые манипуляции, можно несколько расширить функциональность редактора, в частности, обеспечить подсветку синтаксиса.

<br>
<br>
<br>
<br>
<br>
<h1>!Настройка микрофона в GNU/Linux:</h1><br>
<br>Настроить звук, например, как описано здесь (http://varlog.voan.ru/2009/11/configuring-sound-in-debian.html);<br>
<br>Запустить alsamixer:<br>
<br>$ alsamixer<br>
<br>
<br>
<br>
<br>
<br>Перейти на вкладку Capture (нажав tab);<br>
<br>Перейти к элементу Capture, нажать &lt;пробел&gt; (после этого под этим ползунком<br> появится надпись CAPTUR);<br>
<br>Перейти к элементу Input Source, выбрать Mic или Front Mic, в зависимости от<br> того куда подключён микрофон;
<br>Проверить работу микрофона можно программой audacity. <br>
<br>
<br><h1>!Утелита для регулирования громкости pavucontrol</h1>
<br>
<br>Ошибка при запуск pavucontrol
<br>pavucontrol pulseaudio Connection failed: Connection refused
<br>
<br>Решение удаляем
<br> apt-get remove pavucontrol
<br>Устанавливаем
<br>apt-get install pulseaudio,pulseaudio-utils,gstreamer0.10-pulseaudio,libsdl1.2debian-pulseaudio
<br> и
<br>
<br>apt-get install pavucontrol
<br>
<br>
<br>
<br>
<br><h1>Nload - просмотр загрузки канала в консольном режиме</h1>

<br>Продолжая тему обзора утилит обзора пропускной способности канала, рассмотрим утилиту Nload.
<br>Установку выполним из портов:
<br># cd /usr/ports/net/nload/ &amp;&amp; make install clean &amp;&amp; rehash
<br>Делаем попытку запуска утилиты. В результате получилось следующее:
<br>
<br>Экран разделен на две области. В верхней отображается загрузка интерфейса входящим трафиком, в нижней - исходящим. Есть возможность переключаться между интерфейсами в <br>режиме реального времени, "гоняя" их по кругу (в моем случае количество сетевых интерфейсов - 6 штук). Для переключения можно использовать клавиши "вправо" и "влево".
<br>Попробуем разобраться с доступными опциями (тоесть ознакомимся со страницей руководства - man nload):
<br>"-a" - задает промежуток времени в секундах, для подсчитывания среднего значения. По умолчанию 300 секунд;
<br>"-i" - задает планку 100%  (килобит за секунду) для графического отображения пропускной способности интерфейса для входящего трафика. Значение по умолчанию - 10240;
<br>"-m" - отображение нескольких интерфейсов. Не отображаются графики;
<br>"-o" - то же, что и опция "-i", только для исходящего трафика;
<br>"-t" - задает интервал обновления в милисекундах. Значение по умолчанию - 500. Не рекомендуется устанавливать меньше 100;
<br>"-u" - задает режим отображения: Bit/s, kBit/s, MBit/s... Значение по умолчанию - kBit/s;
<br>"-U" - задает режим отображения для подсчета количества проходящего траффика. Значение по умолчанию - MByte;
<br>"device" - конкретизируем интерфейс.
<br>Итак, задаем следующие параметры:
<br>конкретизируем интерфейс - nfe0
<br>"верхняя" планка отображения - 500 килобит в секунду, как для входящего, так и для исходящего траффика
<br>подсчет трафика - в гигабайтах
<br>интервал обновления - 400 милисекунд
<br>Команда будет выглядеть следующим образом:
<br># nload nfe0 -i 500 -o 500 -U G -t 400
<br>
<br>
<br>
<br>
<br>
<br><h1>!Выключение компьютера в задоаное времс cron + zenity </h1>
<br>В кроне прописывем.
<br><pre class="screen">
<br>    $sudo crontab -e
<br>
<br>00 23 * * 1-5 env DISPLAY=:0.0 /usr/bin/my_shutdown.sh #Выключить компьютер в буднии дни  в 23:00
<br></pre>
<br>В скрипте my_shutdown.sh пропишем
<br><pre class="screen">
<br>#!/bin/sh
<br>
<br>zenity --question --title="Выключение компьютера"\
<br>       --text="Компьютер выключится через 5 минут.\nОтменить выключение компьютера"\
<br>        --timeout=300
<br>if [ $? -eq "0" ]
<br> then
<br>   zenity --info --title="Отмена выключения"\
<br>        --text="Сам выключишь компьютер!"
<br> else
<br>/sbin/shutdown -h now
<br>   zenity --warning --title="Выключение"\
<br>        --text="Выключение"
<br>
<br>fi
<br></pre>
<br>Для нормальной работы zenity необходимо происать в файл /etc/profiles строчку xhost local:mike


<br>
<br><h1>Пустой каталог .gvfs</h1>
<br> Проблема связана с тем, что наш пользователь не входит в группу fuse
<br> При выполнение команды монтрования
<br> $ /usr/lib/gvfs/gvfs-fuse-daemon ~/.gvfs
<br> Permishin denide<br>
<br> Необходимо добавить нашего пользовате в группу fuse
<br> sudo usermod -a -G fuse guyp
<br> Перегружаем и проверяе
<br> $ groups
<br>
<br>
<br><a name="cuneiform"></a><h1>!Распознаем текст с помощью cuneiform</h1>
<a href="#top">Назад</a>
<br>Пример использования:
<br>cuneiform -l ruseng -o /our/dir/text.txt  /our/dir/book.tif
<br>Запускать можно со следующими аргрументами:
<br>
<br>-l
<br>Указывает язык документа. Из возможных: eng(по умолчанию) ger fra rus swe spa ita ruseng ukr srp hrv pol <br>dan por dut cze rum hun bul slo <br>lav lit est tur.
<br>
<br>-o
<br>Сохраняет в файл.
<br>
<br>-f
<br>Формат полученного текста. Из поддерживаемых: text(по умолчанию), html, rtf, smarttext(plain text with TeX paragraphs), hocr(hOCR HTML <br>format), native(Cuneiform 2000 format)
<br>
<br>--dotmatrix
<br>Оптимизация работы скрипта под изображение, распечатанное с помощью матричного принтера.
<br>
<br>--fax
<br>Оптимизация работы скрипта под изображение, распечатанное с помощью факса.
<br>
<br>--singlecolumn
<br>Отключает анализ страницы и подразумевает, что у нас изображение состоит из одной колонки текста.
<br>
<br><h1>Cuneiform и yagf можно установить из репозитория</h1>
<br>Во-первых, добавляем репозиторий:
<br># echo "deb http://notesalexp.org/debian/`lsb_release -cs`/ `lsb_release -cs` main contrib non-free" | sudo tee -a /etc/apt/sources.list
<br>Во-вторых, добавляем ключ безопасности:
<br># wget -O - http://notesalexp.org/debian/alexp_key.asc | sudo apt-key add -
<br>В-третьих, обновляем список доступных пакетов в репозиториях:
<br>#sudo apt-get update
<br>В-четвертых, устанавливаем OCR-систему Cuneiform и yagf в Ubuntu:
<br># sudo apt-get install cuneiform-linux yagf
<br>
<br>
<br><h1>PDF файлы распознать</h1>
<br>Готовая командная линия:
<br># pdftoppm -r 100 cv.pdf 1  &amp;&amp; for file in *.ppm; do cuneiform -l rus -f text -o ${file/.ppm/.txt} $file; rm $file; done &amp;&amp; cat *.txt &gt; result.txt
<br>
<br>Разбираемся:
<br>1. Конвертируем файл pdf в изображения ppm (сколько страниц, столько и выходных файлов):
<br># pdftoppm -r 100 cv.pdf 1
<br>Здесь ключ -r 100 обозначает что мы хотим на выходе изображения 100dpi
<br>2. Разом распознаем файлы ppm программой cuneiform, выходные файлы txt
<br># for file in *.ppm; do cuneiform -l rus -f text -o ${file/.ppm/.txt} $file; rm $file; done
<br>3. Собираем все txt файлы в один файл result.txt
<br># cat *.txt &gt; result.txt
<br>
<br><h1>Cкачать видео с youtube</h1>
<br>установить
<br>#sudo apt-get install youtube-dl
<br>обновить версию
<br> #sudo youtube-dl -U
<br>скачать
<br>#youtube-dl http://www.youtube.com/embed/PVQg7QuVUvk
<br>
<br><h1>Время создания файла</h1>
<br>
<br>$ls -l; mtime - modification time - время последней модификации (изменения) файла
<br>$ls -lu; atime - access time - время последнего доступа к файлу
<br>$ls -lc; ctime - change time - время последнего изменения атрибутов файла (данных которые хранятся в inode-области)
<br>
<br>
<br><h1>Создает личнные каталоги пользователей AD и делает их владельцам</h1>
<br>##########################################
<br>#!/bin/bash
<br>#
<br>wbinfo -u | while read line;
<br>do
<br> if [ ! -d  /srv/domen_pool/personal/$line ]; then
<br>  mkdir -m 700 /srv/domen_pool/personal/$line
<br> chown $line  /srv/domen_pool/personal/$line
<br> fi
<br>done
<br>###############################################
<br>
<br><h1>Узнать IP адрес пользователя подключенного к sambe шаре</h1>
<br>#smbstatus -v
<br>
<br>
<br>
<br><h1>Убрать  поддержку ipv6 на сервере</h1>
<br>#Vi /etc/sysctl.conf
<br>#Добавляем
<br>net.ipv6.conf.all.disable_ipv6 = 1
<br>
<br>
<br>
<br><h1>Монтирование дисков в AD</h1>
<br>в Debian 6 sqizy

<br>mount.cifs //172.16.24.51/C$ /mnt -o username=user,domain=DOMAIN,sec=ntlmv2

<br>Только для 2003 и Xp
<br>
<br>Для подключения дисков с 7 и 2008
<br>Обновляем дистрибутив до Wheezy
<br>mount.cifs //172.16.16.16/C$ /mnt -o username=user,domain=DOMAIN,sec=ntlmssp
<br>
<br>
<br><h1>Проверить производительность видео катрочки</h1>
<br>$ lspci |grep Display
00:02.1 Display controller: Intel Corporation Mobile 945GM/GMS/GME, 943/940GML Express Integrated Graphics Controller (rev 03)
<br>$glxgears
<br>
<br>
<br>
<br><h1>Вывести информацию о доменах</h1>
<br>net rap domain -S domen.com -U user -l
Enter usrer's password:

Enumerating domains:

	Domain name          Server name of Browse Master
	-------------        ----------------------------
	CZL                  MASTER
<br>
<br><h1>Увидить пользователей домена</h1>
<br># net rap user -S name.server -U user -l

<br>
<br>
<br><h1>Хотите, чтобы ваши скрипты выглядели более ярче и насыщеннее, или не любите серость?</h1>
<br>BOLD='\e[1m'
<br>UNDERLINE='\e[4m'
<br>BLINK='\e[5m'
<br>INVERSE='\e[7m'
<br>BREAK='\e[m'
<br>#Foreground colors:
<br>BLACK='\e[0;30m'
<br>RED='\e[0;31m'
<br>GREEN='\e[0;32m'
<br>BROWN='\e[0;33m'
<br>BLUE='\e[0;34m'
<br>MAGENTA='\e[0;35m'
<br>CYAN='\e[0;36m'
<br>GRAY='\e[0;37m'
<br>DEF='\e[0;39m'
<br>DGRAY='\e[1;30m'
<br>LRED='\e[1;31m'
<br>LGREEN='\e[1;32m'
<br>YELLOW='\e[1;33m'
<br>LBLUE='\e[1;34m'
<br>LMAGENTA='\e[1;35m'
<br>LCYAN='\e[1;36m'
<br>WHITE='\e[1;37m'
<br># backgrounds colors
<br>BLACK='\e[40m'
<br>RED='\e[41m'
<br>GREEN='\e[42m'
<br>BROWN='\e[43m'
<br>BLUE='\e[44m'
<br>MAGENTA='\e[45m'
<br>CYAN='\e[46m'
<br>GRAY='\e[47m'
<br>DEF='\e[49m'
<br>Например
<br><br>
<br>echo -e '\e[0;31m Скачиваем архив \E[0m'
<br>рисует строку красными буквами.
<br>
<br>Методом научного тыка было также выяснено, что если для Foreground color ставить первое значение 2, то получаем темный вариант цвета. Например:
<br>echo -e '\e[2;31m Скачиваем архив \E[0m'
<br>рисует строку темно-красным А значение:
<br>'\e[9m'
<br>делает текст зачеркнутым.


<br><h1>!2 монитора  Как выбрать "главный"</h1>
<br>Можно установить графическую утелиту arandr
<br>И После выбраного режима сохранить настройки.
<br>Скрипт я отредактировал и добавил опцыю --primary, что бы экран ноутбука был основным.
<br> xrandr --output LVDS1 --primary --mode 1400x1050 --pos 0x0 --output VGA1 --mode 1280x1024 --pos 1400x26
<br> строку я добавил в /home/user/.profile для автоматического применения при загрузке.
<br> Еще пришлось уменьшить панель запуспка LSDE до 52 %, что-бы она была только на экране ноутбука.
<br>
<br>
<br>
<br><a name="logrotate"></a><h1>!Ротация логов с помощью logrotate в Debian / Ubuntu</h1>

<br>17.06.2009 Тэги: awstats, debian, logrotate, ubuntu, utils, ротация Просмотров: 31303
<br>
<a href="#top">Назад</a>
<br>
<br>Logrotate - приложение, разработанное для облегчения управления лог-файлами. Особенно Logrotate полезен там, где <br>создается большое количество лог-файлов. Утилита позволяет в автоматическом режиме архивировать, удалять, очищать и <br>отправлять на e-mail лог-файлы. Этот процесс обычно называется ротацией лог файлов.<br>
<br>
<br>Logrotate может быть настроен на ежедневную, еженедельную или ежемесячную ротацию. Кроме того, можно задать размер <br>файла, по достижении которого файл будет ротирован. Обычно logrotate выполняется в качестве каждодневного задания (cron).
<br>
<br>
<br>Установка Logrotate
<br>Установка обычна для Debian / Ubuntu-based дистрибутивов:
<br>
<br>$ sudo aptitude install logrotate
<br>Краткое описание файла настроек Logrotate
<br>Описание того, каким образом Logrotate будет работать с тем или иным лог файлом находится в специальном <br>конфигурационном файле. Как правило, они располагаются в директории /etc/logrotate.d/. Например, файл конфигурации <br>для apache2 выглядит следующим образом:
<br>
<br>$ more /etc/logrotate.d/apache2
<br>/var/log/apache2/*.log {
<br>        weekly              # ротация раз в неделю
<br>        missingok           # отсутствие файла не является ошибкой
<br>       rotate 52           # сохраняется последние 52 ротированных файла
<br>        compress            # сжимать ротируемый файл
<br>        delaycompress       # сжимать предыдущий файл при следующей ротации
<br>                            # (т.е. файл *.log.1 будет не сжат, а *.log.2 и далее сжатыми)
<br>        notifempty          # не обрабатывать пустые файлы
<br>        create 640 root adm # сразу после ротации создать пустой файл с заданными правами и пользователем
<br>       sharedscripts       # крипты prerotate/postrotate будут выполнены только один раз
<br>                            # не зависимо от количества журналов, подходящих под заданный шаблон
<br>        postrotate          # скрипт будет выполнен сразу после ротации
<br>                if [ -f "`. /etc/apache2/envvars ; echo ${APACHE_PID_FILE:-/var/run/apache2.pid}`" ]; then
<br>                        /etc/init.d/apache2 reload &gt; /dev/null
<br>                fi
<br>        endscript
<br>}
<br>При этом, первая строка /var/log/apache2/*.log есть ничто иное, как шаблон обрабатываемых лог-файлов. Он означает, <br>что указанная конфигурация ротации будет использоваться для всех файлов, находящихся в директории /var/log/apache2/ и <br>имеющих расширение "log".
<br>
<br>Допустимых директив в конфигурационном файле очень много (более 40). Поддробнее о них можно узнать из man logrotate.
<br>
<br>Основные опции Logrotate
<br>Как правило, после настройки конфигурационного файла появляется необходимость проверить работу logrotate для новых <br>логов. Для этого есть возможность непосредственного запуска logrotate из командной строки. При этом допускаются <br>следующие опции:
<br>
<br>-d. Всключает режим отладки, а так же дублирует опциию -v. В режиме отладки никаких действий с логами не будет <br>выполнено.
<br>
<br>-f, --force. Заставляет logrotate выполнить ротацию логов. Бывает необходимо после добавления новых конфигурационных <br>файлов или если старый лог файл был удалён вручную; таким образом будут созданы новые лог-файлы и журналирование <br>будет корректно продолжено.
<br>
<br>-m, --mail command. Указывает, какую команду использовать для отправки журналов по почте. Команда должна принимать 2 <br>входных параметра:
<br>
<br>заголовок письма
<br>получателя письма
<br>После этого команда должна прочитать сообщение со стандартного входа (STDIN) и отправить его получателю. Командой по <br>умолчанию является /usr/bin/mail -s
<br>
<br>-s, --state statefile. Указывает на использование альтернативный файл состояния. Полезно в случаях, когда logrotate <br>работает от имени разных пользователей для различных наборов лог-файлов. Дефолтный файл состояния: /var/lib/logrotate/<br>status
<br>
<br>--usage. Выводит краткую инструкцию по использованию утилиты.
<br>
<br>-v, --verbose. Вывод диагностических сообщений во время ротации.
<br>
<br>Пример настройки Logrotate
<br>В качестве примера допустим, что в директории /home/site/debianworld.ru/logs/ располагаются лог-файлы таких веб <br>серверов, как nginx и apache. Работают они в связке: nginx - фронтенд, apache2-бэкенд.
<br>
<br>$ more /etc/logrotate.d/debianworld.ru
<br># Ротация логов nginx (front-end)
<br># Отдает статику, все остальное - проксирует на apache.
<br># Лог ведется более интенсивно.
<br>/home/dw/debianworld.ru/logs/nginx_*.log {
<br>    daily                   # ежедневная ротация
<br>    missingok               # отсутствие файла не является ошибкой
<br>   rotate 45               # хранится история за 45 дней
<br>    compress                # ротируемые файлы сжимаются
<br>    delaycompress           # ротируемый файл не сжимается, остальные - сжимаются
<br>    notifempty              # не обрабатывать пустые файлы
<br>    create 640 dw www-data  # права, пользователь нового файла
<br>    sharedscripts           # prerotate/postrotate выполняются только 1 раз
<br>    prerotate               # Cбор статистики посещений для AWstats
<br>            /usr/bin/perl /usr/lib/cgi-bin/awstats.pl -update -config=debianworld.ru -databasebreak=day
<br>    endscript
<br>    postrotate              # Перезапуск nginx
<br>            [ ! -f /var/run/nginx.pid ] || kill -USR1 `cat /var/run/nginx.pid`
<br>    endscript
<br>}
<br>
<br># Ротация логов apache2 (back-end)
<br># Лог ведется менее интенсивно.
<br>/home/dw/debianworld.ru/logs/apache*.log {
<br>    weekly                   # еженедельная ротация
<br>    missingok                # отсутствие файла не является ошибкой
<br>    rotate 4                 # хранится история за 4 недели
<br>    compress                 # ротируемые файлы сжимаются
<br>    nodelaycompress          # ротируемый файл так же сжимается
<br>    notifempty               # не обрабатывать пустые файлы
<br>    create 640 dw www-data   # права, пользователь нового файла
<br>    sharedscripts            # postrotate выполняется только 1 раз
<br>    postrotate               # Перезапуск apache2
<br>            if [ -f /var/run/apache.pid ]; then
<br>                /etc/init.d/apache2 restart &gt; /dev/null
<br>           fi
<br>    endscript
<br>}
<br>Комментарии по ходу текста не должны оставить вопросов. Но в общем, схема такова, что отдельно ротируются логи <br>nginx, отдельно логи apache2. При этом, так как nginx является front-end'ом и его лог наполняется интенсивнее, чем у <br>apache, то он (лог nginx) ротируется в 7 раз чаще, чем лог apache2.
<br>
<br>Кроме того, при каждой итерации ротирования логов nginx выполняется сбор статистики посещений AWstats (см. Установка <br>и настройка AWstats и Настройка AWstats для генерации статистики по дням).
<br>
<br>После того, как конфигурационный файл создан, необходимо убедиться, что все будет работать именно так, как и <br>задумано. Для этого необходимо выполнить (при этом, реальных изменений никаких не будет, так как запуск будет <br>выполнен в отладочном режиме):
<br>
<br>$ sudo logrotate -d /etc/logrotate.d/debianworld.ru
<br>После того, как по диагностическим сообщениям стало ясно, что все в порядке, необходимо непосредственно запустить <br>ротацию:
<br>
<br>$ sudo logrotate -v -f /etc/logrotate.d/debianworld.ru
<br>В дальнейшем ротация будет выполняться автоматически с заданным в конфигурационном файле интервалом.
<br>
<br>
<br><h1>!Как сделать жирный шрифт в консоли?</h1>
<br>/etc/default/console-setup
<br>
<br>FONTFACE=«TerminusBoldVGA»
<br>FONTSIZE=«16»
<br>
<br>
<br>
<br><h1>!sudo настройка</h1>
<br>Редактировать файл sudoers "вручную" — плохая практика. Для редактирования есть специальная команда <br>visudo. Она сама знает, где расположен файл sudoers, и отследит, чтобы вы редактировали копия, файл <br>всегда был целостным, а копия была удалена.
<br>visudo позволяет использовать любой редактор.
<br>Для смены редактора nano на vim
<br>отредактируем /etc/sudoers добавив:
<br>Defaults      editor=/usr/bin/vim
<br>Пример
<br>test ALL=(root) NOPASSWD: /sbin/ifconfig
<br>Пользователь test может выполнить команду sudo ifconfig не вводя пороль.
<br>Для возможности пользователю выключать и перегружать сервер
<br>Добавим команды через запятую
<br>test ALL=(root) /sbin/halt, /sbin/reboot
<br>
<br>
<br>По умолчанию логи пишуться в /var/log/auth.log
<br>Писать логи в нужный файл можно дописав  в /etc/sudoers
<br>Defaults logfile=/var/log/sudo.log # или любой другой файл.
<br>запустите 'sudo -l' для проверки, затем посмотрите в /var/log/sudo.log
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br><h1>!Цветная консоль bash</h1>
<br> В файл ~/.bashrc
<br> Добавим или разкоментируем
<br>force_color_prompt=yes
<br>
<br>
<br>
<br><h1>!Мышь мышка в консоли</h1>
<br>Устанавливаем
<br>sudo apt-get install gpm
<br>
<br>!Убрать пароль в Chrome
<br>Свойства ярлыка- Команда добавим
<br>Google Chrome: /opt/google/chrome/google-chrome --password-store=basic %U
<br>или Chromium:/usr/bin/chromium-browser --password-store=basic %U
<br>
<br>
<br>
<br><h1>!Антивирус clamav</h1>
<br>Установка $sudo apt-get install clamav
<br>Обновление баз $sudo freshclam
<br>Если обновляем через проксисервер добавит строки в файл
<br>$ vi /etc/clamav/freshclam.conf
<br>HTTPProxyServer 10.101.0.1
<br>HTTPProxyPort 1234
<br>Перезапускаем серевер
<br>$ sudo /etc/init.d/clamav-freshclam restart
<br>http://www.xakep.ru/magazine/xa/116/080/1.asp
<br>Тестовая строка с вирусом на http://ru.wikipedia.org/wiki/EICAR-Test-File строку скопировать в
<br>тексовый файл и натравить
<br>$sudo clamscan -i file.txt
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br><h1>!convert tiff files to pdf format on Linux</h1>
<br>$ sudo apt-get install ghostscript libtiff-tools
<br>Простой пример $ tiff2pdf -o output.pdf input.tiff конвертирует из tiff в pdf
<br>Пример комады для конвертирования файлов tiff в pdf
<br>$ls *.tif |while read arg ; do tiff2pdf -j -q 75 -f -o /home/user/test/pdf/$arg.pdf $arg; done
<br>
<br>Перевод pdf в текст из пакета poppler-utils
<br>$ pdftotext -layout input.pdf otput.txt
<br>
<br>
<br>
<br>
<br>
<br>Восстановление данных с поврежденных носителей с помощью утилиты testdisk
Содержание
Восстановление данных с поврежденных носителей с помощью утилиты testdisk
Восстановление данных с помощью extundelete
Ссылки
Нередко судьба подкидывает нам такое, что послезавтра сдавать диплом, а сегодня умер жесткий диск со всей информацией. В Linux стандартом де-факто в области восстановления данных является утилита testdisk. Однако нередко человек, впервые сталкиваясь с ней, находит ее для себя малопонятной и отказывается от нее, т.к. она не имеет графического интерфейса.
Многих новичков в Linux, привыкших к GUI программам в Windows, пугает использование консольных программ, требующих ввода нужных команд с малоизвестными им аргументами и ключами. Нередко мануалы к такому софту оказываются или на английском языке, или достаточно сложны, чтобы разобраться с первого взгляда, и человек отступается от своей цели. Нередко ему снова приходится обращаться к Windows, искать там «надежную и понятную» (GUI) программу, затрачивая на это уйму времени, вместо того, чтобы убрать у себя табу на использование консоли.
Специально для написания статьи я нашел старую ненужную флешку, записал на нее музыки и видео. После этого в GParted изменялись размеры и положение раздела (при этом флешка выдергивалась из компа в самый кульминационный момент), ну и напоследок все было добито созданием новой таблицы разделов.
Итог - при подключении флешка не обнаруживается компьютером, на ней важная информация, будем ее восстанавливать.
1. Для начала нужно установить testdisk. Для этого в консоли выполняем:
sudo apt-get install testdisk
2. Запускаем testdisk с администраторскими правами
sudo testdisk
Появляется окошко приветствия testdisk, нам предлагается вести лог работы. В данном случае не вижу в этом смысла, но вы можете поступать иначе. Выбираем нужный пункт меню и подтверждаем выбор: No Log → Enter.

3. Появляются доступные носители, выбираем нужный, подтверждаем нажатием Proceed.

4. Предлагается выбрать тип таблицы разделов, думаю, что в большинстве случаев будет тип Intel / PC Partition.

5. Появляется меню с выбором операции. Для начала делаем анализ, выбрав Analyse.

6. В разделе Analyse Выбираем Quick Search.

7. Последний вопрос перед началом анализа «Должен ли testdisk искать разделы созданные с использованием Windows Vista?». В моем случае — нет, поэтому я выбираю N.

Побежал анализ…

Анализ закончен. Предупреждение. Или некоторые разделы не были найдены, или таблица разделов не может быть записана, т. к. разделы перекрываются.

8. Вот теперь можно начинать восстановление информации. В данном случае нас интересует 2 варианта действий.
Получить список файлов, содержащихся в данном разделе нажатием Р с дальнейшим восстановлением интересующих файлов из списка
Попробовать загрузить резервную копию таблицы разделов нажатием L, это приведет носитель к первоначальному состоянию до поломки

Выводим список файлов нажатием Р.

Отсюда же можно попробовать скопировать особо важные файлы и папки, особенно если боитесь, что данные не восстановятся, а наоборот потеряете последнюю, пусть даже и битую информацию. Для примера я буду копировать музыкальный альбом. Выделяем нужное курсором, нажимаем С для копирования. Появляется файловый менеджер, где можно выбрать куда будем копировать. В домашнем каталоге для этих целей специально создана папка Restored.

Заходим в нее и подтверждаем копирование нажатием Y.

Открываем папку в Nautilus, видим, что все файлы на месте и их можно прослушать.

9. Итак, особо важную информацию на всякий случай сохранили, однако наша цель приведение носителя в нормальное рабочее состояние. Из каждого пункта меню testdisk можно вернуться в предыдущий с помощью клавиши Q. Таким образом возвращаемся к 8 пункту.

Попробуем вернуть все в первоначальное до поломки состояние, загрузив резервную копию таблицы разделов. Нажимаем L. В появившемся окошке выбираем Load…

…и подтверждаем наши намерения Y.

Все, процесс восстановления закончен, отключаем и снова подключаем поврежденный носитель. Теперь он обнаруживается, все файлы на месте, в целости и сохранности.

Желаю вам удачных восстановлений!
<br>
<br>
<br>
<br>
<br>
<br><br>Спящий режим # pm-hibernate
<br>
<br>
<br><h1>Создание загрузочной USB  флешки</h1>
<br>Установка
<br>$apt-get instll unetbootin
<br>Запуск клиена от рута
<br>#unetbootin
<br>Все настройки в GUI интрефейсе.
<br>
<br>
<br>
<br><h1>QEMU виртуализация</h1>
<br>Выполнить загрузку с флешки.
<br>$ qemu -usb -m 200 /dev/sdb mustdiexp.img -boot c localtime
<br>где /dev/sdb диск флешки.
<br>
<br>
<br>
<br>
<br><h1>Включить выключить флешку USB из через консоль</h1>
<br>Включить
<br># echo on &gt; /sys/bus/usb/devices/1-3/power/level
<br>Выключить
<br># echo suspend &gt; /sys/bus/usb/devices/1-3/power/level
<br>Каталог 1-3 выбрал для debian в первоисточнике был каталог 1-9
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br><h1>Открыть файл реестра виндовс для поиском grrep</h1>
<br>
<br>iconv -f utf16 -t utf8 Storage_Utilization_12-03-12.csv &gt; Storage_Utilization_12-03-12-1.csv
<br>
<br>
<br>
<br><h1>Определение UUID</h1>
<br>$blkid
<br>$blkid /dev/sda1
<br>Оперделить по UUID имя диска
<br>blkid -U 75426429-cc4b-4bfc-beb9-305e1f7f8bc9
<br>Каталог где храняться все UUID
<br>$ cat /dev/disk/by-uuid/
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br><h1>Git через proxy</h1>
<br>
<br>В домашней директории создаём файл  .gitconfig
<br>вписываем туда свой proxy
<br>[http]
 <br>  proxy = 77.xxx.xxx.xxx:8123
 <br>
<br>И теперь при скачивании указываем
<br>git clone http://github.com/scrooloose/vimfiles.git
<br>
<br>надо просто git:// заменить на http://, тогда все работает
<br>
<br>пока не получилось сделать как http://blogs.gnome.org/juanje/2009/07/17/git_behind_proxy/
<br>
<br>При работе с bitbucket.org через https возникла следующая ошибка
<br>error: Couldn't resolve proxy '%http_proxy%' while accessing https://xxxxx@bitbucket.org/xxxx/xxxx/info/refs
<br>fatal: HTTP request failed
<br> Помогло измерение в файле .gitconfig
<br>
<br>  [http]
<br>  proxy = https://xx.xx.xxx.xx:8080/
<br>Автор: Ser на 14:14
<br>Ярлыки: git
<br>
<br><h1>Программа для определения типа файла по содержимому на основе сигнатур.</h1>
<br> В базе утилиты содержится более 3000 записей, способных <br>определить файлы различных форматов. В программе предусмотрена <br>возможность добавлять свои сигнатуры, а также есть анализатор <br>однотипных файлов.
<br>
<br>Win32 TrID v2.02, 25KB http://mark0.net/download/trid_w32.zip
<br>Linux/x86 TrID v2.00, 28KB http://mark0.net/download/<br>trid_linux.zip
<br>База сигнатур TrIDDefs.TRD package, 378KB ( 3062 file types, <br>25/01/08 ) http://mark0.net/download/triddefs.zip

<br>Графическая оболочка для TrID. Удобно. Требует наличия MS .NET <br>Framework
TrIDNet v1.80, 33KB http://mark0.net/download/trid_net.zip
База TrID XML defs, 527KB ( RAR archive with 3062 definitions, 25/01/08 ) http://mark0.net/download/triddefs_xml.rar
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br><h1>пакет sysstat(измерение производительности системы)</h1>, <br>который состоит из ряда утилит, которые если интересно можеш <br>покрутить.
<br>Конфигурирование пакета Sysstat

Информация о Cron

Чтобы приступить к сбору периодической информации с помощью Sysstat, вы должны добавить строки в таблицу crontab или создать таблицу для привилегированного пользователя. Собираемые данные будут размещаться в директории /var/log/sa. Пользователь, запускающий утилиты Sysstat с помощью cron, должен иметь права на запись в этот директорий.

Ниже приведен пример настройки crontab. Выполняйте настройку в соответствие с вашими требованиями. Подробную информацию о настройке смотрите с помощью команд man sa1 и man sa2.

# отчеты об используемых ресурсах каждые 10 минут с 8 утра и до 7 вечера каждый рабочий день
0 8-18 * * 1-5 /usr/lib/sa/sa1 600 6 &

# отчеты об используемых ресурсах каждый час с 7 вечера и до 8 утра каждый рабочий день
0 19-7 * * 1-5 /usr/lib/sa/sa1 &

# отчеты об используемых ресурсах каждый час в субботу и воскресенье
0 * * * 0,6 /usr/lib/sa/sa1 &

# Ежедневный итоговый отчет подготавливать в 19:05
5 19 * * * /usr/lib/sa/sa2 -A &
Обеспечьте, чтобы исправленная таблица crontab была прочитана демоном cron.
iostat

выдает статистику использования процессора и потоков ввода/вывода устройств и разделов

isag

интерактивная программа, строящая график активности системы

mpstat

сообщает об отдельных параметрах и общей статистики, связанной с процессором

pidstat

используется для мониторинга отдельных задач, управление которыми выполняется ядром Linux

sar

собирает, сохраняет и выдает в виде отчетов информацию об активности системы

sa1

собирает и сохраняет двоичные данные в файле данных ежедневной активности системы. Это интерфейс sadc, созданный для запуска его из cron

sa2

записывает краткий ежедневный отчет об активности системы. Это интерфейс sar, созданный для запуска его из cron

sadc

является средством сбора данных об активности системы; используется как движок для sar

sadf

используется для отображения содержимого файлов с данными, созданными с помощью команды sar. Но, в отличие от sar, sadf может записывать свои данные в разнообразных форматах

<br>
<br>
<br><h1>При установке debain 8 на raid 10 из дисков 4Tb ошибка установки grub2
решение</h1>

<br>
<br>4 жестких диска по 4 Тб
<br>Задача повысить отказоустойчивость.
<br>1. Проблема с устоновкой grub2 на диски с gpt
<br>решение создаем на каждом диске раздел чуть больше 3 Mb
<br>и назначаем ему флаг bios_grub делал с помощью Live CD Knopix утелитой Gparted
<br>Сделал раздел 10 Мб с флагом bios_grub
<br>под систему 100 Gb в LVM добавил в raid10 /dev/md0
<br>все остальное в raid 10 /dev/md1
<br>при установке системы указываем установить grub на /dev/sda
<br>установка проходит успешно но grub установлен только на одном диске!
<br>
<br>2. Установить grub2 на все диски после запуска системы
<br>выполним команду dpkg-reconfigure grub-pc все настройки по умолчанию в конце выбираем диски на которые
<br>установим grub
<br>https://wiki.debian.org/DebianInstaller/SoftwareRaidRoot
<br>
<br>3. После удаление жестоко диска система не гузиться ошибка не видит LVM
<br>нашел решение на
<br>http://diff.org.ua/archives/2827
<br>
<br>В работающей системе создаем файлик:
<br>
<br>~# vim /etc/initramfs-tools/scripts/init-premount/assemble-md
<br>и добавляем туда вот что:
<br>
<br>mdadm -S /dev/md0
<br>mdadm -S /dev/md1
<br>mdadm -A --scan
<br>Даем права на выполнение:
<br>
<br>~# chmod +x /etc/initramfs-tools/scripts/init-premount/assemble-md
<br>Обновляем initrd:
<br>
<br>~# update-initramfs -u
<br>Вот и все … выключаем сервак, отрубаем винчестер и пробуем грузиться. У меня получилось!
<br>
<br>
<br>4.Проблема если вытащить любых 2 диска систем не грузиться
<br>
<br>
<br>полезные команды:
<br>посмотреть статус raid
<br>#cat /proc/mdstat
<br>и
<br>#mdadm --detail /dev/md0
<br>
<br>добавить новы диск например sda1 диск в raid md0
<br>#mdadm /dev/md0 -a /dev/sda1
<br>
<br>
<br><h1>Changing  Screen Resolution in a Hyper-V VM РАЗРЕШЕНИЕ КОНСОЛИ</h1>
<br>Open Terminal
<br>Type: sudo vi /etc/default/grub
<br>Find the line starting with GRUB_CMDLINE_LINUX_DEFAULT, and add video=hyperv_fb:[the resolution you want].  The resolution I want is 1280x720.  So my line ends up looking like this: GRUB_CMDLINE_LINUX_DEFAULT="quiet splash video=hyperv_fb:1280x720"
<br>Write the changes and quit vi.
<br>Run: sudo update-grub
<br>Reboot the virtual machine
<br>
<br>
<br><h1>После установки diebin 7 на Raid-6 получил ошибку.</h1>
<br>
<br>error: file '/boot/grub/i386-pc/normal.mod' not found
<br>Entering rescue mode...
<br>
<br>Грузимся с Knopix
<br>Установка модуля рейд
<br>modporobe raid6
<br>Запуск сканирования дисков
<br>mdadm -A -scan
<br>монтируем разлел
<br>mount  /dev/md126p1 /mnt
<br>Делаем chroot
<br>sudo mount /dev/sda1 /mnt
<br>sudo mount --bind /dev /mnt/dev
<br>sudo mount --bind /dev/pts  /mnt/dev/pts
<br>sudo mount --bind /proc /mnt/proc
<br>sudo mount --bind /sys  /mnt/sys
<br>sudo chroot /mnt
<br>Запускаем
<br>pkg-reconfigure grub-pc
<br>все настройки по умолчанию в конце выбираем все диски
<br>reboot
<br>
<br><h1>Docker</h1>
<br>Install
<br>http://linuxconfig.org/package-docker-io-has-no-installation-candidate-debian-jessie
<br>Package 'docker.io' has no installation candidate - Debian Jessie
Docker and its Docker.io debian pakcage is currently not available Debian Jessie thus:
 Package 'docker.io' has no installation candidate
The easiest way to install docker is to use get.docker.com script: First, install curl tool:
# apt-get install curl
Once ready download and run get.docker.com script:
# curl -sSL https://get.docker.com/ | sh
+ sh -c sleep 3; apt-get update
Get:1 http://debian.mirror.uber.com.au jessie InRelease [214 kB]
...
Processing triggers for libc-bin (2.19-13) ...
+ sh -c docker version
Client version: 1.6.0
Client API version: 1.18
Go version (client): go1.4.2
Git commit (client): 4749651
OS/Arch (client): linux/amd64
Server version: 1.6.0
Server API version: 1.18
Go version (server): go1.4.2
Git commit (server): 4749651
OS/Arch (server): linux/amd64

If you would like to use Docker as a non-root user, you should now consider
adding your user to the "docker" group with something like:

  sudo usermod -aG docker your-user

Remember that you will have to log out and back in for this to take effect!
Test your docker installation by creating a Ubuntu docker container:
# docker run -i -t ubuntu /bin/bash
Unable to find image 'ubuntu:latest' locally

latest: Pulling from ubuntu
511136ea3c5a: Pull complete
f3c84ac3a053: Pull complete
a1a958a24818: Pull complete
9fec74352904: Pull complete
d0955f21bf24: Already exists
Digest: sha256:7b27f7cc97d4c94fdebb2cf99ddaadd0e8fc8ec4aed2cf56a8ee8fe7dc2ec4a4
Status: Downloaded newer image for ubuntu:latest

root@f3e5b3b575bd:/# cat /etc/issue
Ubuntu 14.04.2 LTS \n \l
<br>
<br><h1>Долгое Подключение по SSH -- Убираем Задержку</h1>
<br># vi /etc/ssh/sshd_config
<br>добавляем
<br>UseDNS no
<br>GSSAPIAuthentication no
<br>перезапускаем службу
<br>sudo service ssh restart

<br>sudo apt-get install openssh-server
<br>Для начала, произведем начальную настройку ssh сервера для авторизации по ключу. Откроем на редактирование файл /etc/ssh/sshd_config
<br>
<br>sudo nano /etc/ssh/sshd_config
<br>Тут нас интересуют следующие строки, их всего три (Должны быть раскомментированы, и иметь указанные мной значения):
<br>
<br>...........
<br>RSAAuthentication yes
<br>PubkeyAuthentication yes
<br>...........
<br>AuthorizedKeysFile     %h/.ssh/authorized_keys
<br>Перезапустим сервер ssh:
<br>1
<br>sudo restart ssh




<> Разрешить вход root
меняем
FROM:
PermitRootLogin without-password
TO:
PermitRootLogin yes
<br>
<br>
<br>

<h1>Автоматическое подключение монтирование сетевых дисков для АД пользователей</h1>

<br>



устанавливаем




apt-get instal  libpam-mount cifs-utils

Создаем папку для монтирования сетевых ресурсов /net:




mkdir /net




приводим к такому виду

/etc/security/pam_mount.conf.xml




root@rdp:~# vi /etc/security/pam_mount.conf.xml

<!--<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE pam_mount SYSTEM "pam_mount.conf.xml.dtd">
-->
<!--

        See pam_mount.conf(5) for a description.

-->




<!--<pam_mount>
-->



                <!-- debug should come before everything else,

                since this file is still processed in a single pass

                from top-to-bottom -->



<!--
<debug enable="1" />
-->



                <!-- Volume definitions -->







                <!-- pam_mount parameters: General tunables -->




<!--

<luserconf name=".pam_mount.conf.xml" />

-->




<!-- Note that commenting out mntoptions will give you the defaults.

     You will need to explicitly initialize it with the empty string

     to reset the defaults to nothing. -->

<!--<mntoptions allow="nosuid,nodev,loop,encryption,fsck,nonempty,allow_root,allow_other" />
-->
<!--

<mntoptions deny="suid,dev" />

<mntoptions allow="*" />

<mntoptions deny="*" />

-->

<!--<mntoptions require="nosuid,nodev" />
-->


<!--
<logout wait="2000" hup="0" term="1" kill="1" />

-->





                <!-- pam_mount parameters: Volume-related -->



<!--
<mkmountpoint enable="1" remove="true" />

<volume user="*" fstype="cifs" server="172.16.16.1" path="test" mountpoint="/net/%(DOMAIN_USER)/Disk_V" />




</pam_mount>

~


-->







#############

http://forum.ubuntu.ru/index.php?topic=208235.0




Создаем файл скрипта и делаем его исполняемым (в дальнейшем можете использовать этот скрипт по своему усмотрению):




touch /etc/logon

chmod +x /etc/logon




vi  /etc/logon




#!/bin/bash

ln -f -s /net/$USER/Disk_V /home/$DOMAIN/$USER/V
<br>
<br><h1>Owncloud</h1>
<br>ownCould

http://habrahabr.ru/post/208566/




apt-get update && sudo apt-get upgrade




apt-get install apache2 php5 php5-common php5-gd php5-intl php5-mcrypt php5-cli php5-ldap php5-sqlite curl libcurl3 libcurl4-openssl-dev php5-curl php-apc php5-mysql ffmpeg




apt-get install mysql-client mysql-server




пароль mysql






Важно: пароль не должен совпадать с паролем суперпользователя.




mysql_secure_installation




Ввадим пароль рута mysql

На все вопросы кроме «Change the root password» (Если не хотите менять пароль MySQL) отвечаем положительно Y.




create database owncould;




create user 'owncould'@'localhost' IDENTIFIED BY '123456';




GRANT ALL ON owncould.* to 'owncould'@'localhost' ;




quit







nano /etc/apache2/sites-enabled/000-default




Находим строчку в разделе Directory /var/www/

AllowOverride None




на:

AllowOverride All




Перезапускаем apache:

 service apache2 restart




Редактируем php.ini:

 sudo gedit /etc/php5/apache2/php.ini




Находим строчки:

mysql.default_socket =

mysql.cache_size =

memory_limit =

post_max_size =

upload_max_filesize =




Меняем на:

mysql.default_socket=/var/run/mysqld/mysqld.sock

mysql.cache_size = 4000

upload_max_filesize = 1024M       //максимальный размер файла который мы можем загрузить на наш сайт

post_max_size = 1024M                //Должен быть больше или равен upload_max_filesize

memory_limit = 1024M                  //Должен быть больше или равен post_max_size




Сохраняем файл и выходим.




Перезапускам apache еще раз:

 service apache2 restart





  cd /var/www/



  wget https://download.owncloud.org/community/owncloud-8.1.1.tar.bz2






  tar -xvf owncloud-8.1.1.tar.bz2




  chown -R www-data:www-data /var/www/owncloud/




  service apache2 restart






  http://192.168.0.120/owncloud/
<br>
<br><>ownCloud https

1 apt-get install openssl

2 a2enmod ssl

3 a2enmod rewrite

4 mkdir -p /etc/apache2/ssl

5 openssl req -new -x509 -days 36500 -nodes -out /etc/apache2/ssl/owncloud.pem -keyout /etc/apache2/ssl/owncloud.key




6

root@deb-1:~# vi /etc/apache2/conf.d/owncloud.conf

<!--<VirtualHost *:80>

RewriteEngine on

ReWriteCond %{SERVER_PORT} !^443$

RewriteRule ^/(.*) https://%{HTTP_HOST}/$1 [NC,R,L]

</VirtualHost>




<VirtualHost *:443>

SSLEngine on

SSLCertificateFile /etc/apache2/ssl/owncloud.pem

SSLCertificateKeyFile /etc/apache2/ssl/owncloud.key

DocumentRoot /var/www/




<Directory> /var/www/owncloud>

AllowOverride All

order allow,deny

Allow from all

</Directory>

</VirtualHost>

-->
<br>
<h1>The End.</h1>
<br>
<br><h1>Создать файл размером 100Ьи</h1>
<br>fallocate -l 100M file.out
<br>
<br>
<br>
<br><>
<br>fallocate -l 100M file.out
<br>
<br>
<br> <h1>Как заставить tab работать по vnc, а не по ctrl+tab XFCE vncserver</h1>
<br>1) mcedit ~/.config/xfce4/xfconf/xfce-perchannel-xml/xfce4-keyboard-shortcuts.xml
<br>2) Ищем строку
<!--<property name="&lt;Super&gt;Tab" type="string" value="switch_window_key"/>
<br>3) Меняем на строку
<br><property name="&lt;Super&gt;Tab" type="empty"/>
-->
<br>4) Перезапускаем vncserver
<br>$ tightvncserver -geometry 1920x1080 -depth 24 :1
<br>убить
<br>tightvncserver -kill :1
<br>
<br>
    <br> <h1> Pfsense</h1>
<br>
        <br><h1>Git</h1>
        Если вы что-то поменяли и вам надо отправить что-то в удлаённый  репозиторий сделайте  в корне локального репозитория три команды: <br>
        1. ? <br>
        | click me | click me | <br>
        | 1 | git add . | <br>

        -- прямо вот так с точкой через пробел, позволит добавить в индекс  репозитория новые файлы, которые вы создали и которых не было в  предыдущей фиксации (коммите) <br>
        <br>
        2. ? <br>
        | click me | click me | <br>
        | 1 | git commit -m "текст сообщения о том, что вы изменили" | <br>
        <br>
        -- очередная фиксация этапа разработки. <br>
        <br>
        3. ? <br>
        | click me | click me | <br>
        | 1 | git push | <br>
        <br>
        -- именно это команда отправит ваши изменения в удалённый репозиторий. <br>
        <br>
        <br>
        Вам надо забрать что-то из внешней репы <br>
        Если нужно забрать что-то из внешнего репозитория  (например, коллеги  что-то поправили и просят вам подтянуть изменения), то делаем гит пулл (подробности тут): <br>
        ? <br>
        | click me | click me | <br>
        | 1 | git pull | <br>
        <br>
        -- это команда подтянет изменения в вашу текущую ветку, из той ветки внешнего репозитория, которая с ней ассоциирована. <br>
        <br>
        <br>
        <br>
        Имя пользователя <br>
        $ git config --global user.name "John Doe" <br>
        $ git config --global user.email johndoe@example.com <br>
        <br>
        <br>
        Проверка настроек <br>
        $ git config --list <br>
        $ git config user.name <br>
        <br>
        Как получить помощь? <br>
        $ git help глагол <br>

            <br>

            <br>
            Определение состояния файлов <br>
            $ git status <br>
            <br>

            Отслеживание новых файлов <br>
            $ git add README <br>

            <br>

            Сокращенный вывод статуса <br>

            $ git status -s <br>
            <br>


            Игнорирование файлов <br>
            $ cat .gitignore <br>
            *.[oa] <br>
            *~ <br>


            <br>
            Просмотр индексированных и неиндексированных изменений <br>
            $ git diff <br>
            <br>
            Эта команда сравнивает ваши индексированные изменения с последним коммитом:
            $ git diff --staged <br>

            <br>

            Коммит изменений <br>
            $ git commit <br>
            <br>
            или <br>
            $ git commit -m "Story 182: Fix benchmarks for speed" <br>
            <br>
            Добавление параметра -a в команду git commit заставляет Git автоматически индексировать каждый уже отслеживаемый на момент коммита файл, позволяя вам обойтись без git add:
            $ git commit -a -m 'added new benchmarks'
            <br>


            Удаление файлов <br>
            $ rm PROJECTS.md
            <br>
            $ git rm PROJECTS.md
            <br>
            это удалить файл из индекса, оставив его при этом в рабочем каталоге. Другими словами, вы можете захотеть оставить файл на жёстком диске, и убрать его из-под бдительного ока  <br>
            <br>
            git rm --cached README <br>


    <h1>Сететвой интерфейс eth0 отпадает когда перезапускаешь сеть помогает только перезагрузка</h1>
    <br>  systemctl status networking.service
    <br> Process: 546 ExecStartPre=/bin/sh -c [ "$CONFIGURE_INTERFACES" != "no" ] && [
    <br> -n "$(ifquery --read-environment --list --exclude=lo)" ] && udevadm settle
    <br> (code=exited, status=1/FAILURE)
    <br> проблема решается когда в файле
    <br>
    <br> /etc/network/interfaces
    <br> добавить
    <br> auto eth0



    <br>Востановление файлов ext4 c помощью testdisk на lvm
    <br>   запускаем Сreage журналk
    <br>   /dev/dm-0 - 48 GB / 45 GiB - Msft Virtual Disk
    <br>выбирараем
    <br> >[None   ] Non partitioned media
    <br>  >[ Advanced ] Filesystem Utils

    <br>123
    >[  List  ]
    <br>


  </body>
</html>
